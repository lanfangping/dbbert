#FORMAT=WebAnno TSV 3.3


#Text=OnGres | EXPLAIN ANALYZE may be lying to you Resources Blog Services Professional Services Consulting Training Products StackGres PostgresqlCO.NF About
1-1	0-6	OnGres	
1-2	7-8	|	
1-3	9-16	EXPLAIN	
1-4	17-24	ANALYZE	
1-5	25-28	may	
1-6	29-31	be	
1-7	32-37	lying	
1-8	38-40	to	
1-9	41-44	you	
1-10	45-54	Resources	
1-11	55-59	Blog	
1-12	60-68	Services	
1-13	69-81	Professional	
1-14	82-90	Services	
1-15	91-101	Consulting	
1-16	102-110	Training	
1-17	111-119	Products	
1-18	120-129	StackGres	
1-19	130-145	PostgresqlCO.NF	
1-20	146-151	About	

#Text=Contact Post EXPLAIN ANALYZE may be lying to you Álvaro Hernández May 26, 2020 · 10 min read postgresql performance Share this post Álvaro Hernández Founder and CEO
2-1	152-159	Contact	
2-2	160-164	Post	
2-3	165-172	EXPLAIN	
2-4	173-180	ANALYZE	
2-5	181-184	may	
2-6	185-187	be	
2-7	188-193	lying	
2-8	194-196	to	
2-9	197-200	you	
2-10	201-207	Álvaro	
2-11	208-217	Hernández	
2-12	218-221	May	
2-13	222-224	26	
2-14	224-225	,	
2-15	226-230	2020	
2-16	231-232	·	
2-17	233-235	10	
2-18	236-239	min	
2-19	240-244	read	
2-20	245-255	postgresql	
2-21	256-267	performance	
2-22	268-273	Share	
2-23	274-278	this	
2-24	279-283	post	
2-25	284-290	Álvaro	
2-26	291-300	Hernández	
2-27	301-308	Founder	
2-28	309-312	and	
2-29	313-316	CEO	

#Text=The Observer effect In physics, the observer effect is the theory that the mere observation of a phenomenon inevitably changes that phenomenon. This is often the result of instruments that, by necessity, alter the state of what they measure in some manner. Observer effect, Wikipedia (edit; this previously referred to the
3-1	317-320	The	
3-2	321-329	Observer	
3-3	330-336	effect	
3-4	337-339	In	
3-5	340-347	physics	
3-6	347-348	,	
3-7	349-352	the	
3-8	353-361	observer	
3-9	362-368	effect	
3-10	369-371	is	
3-11	372-375	the	
3-12	376-382	theory	
3-13	383-387	that	
3-14	388-391	the	
3-15	392-396	mere	
3-16	397-408	observation	
3-17	409-411	of	
3-18	412-413	a	
3-19	414-424	phenomenon	
3-20	425-435	inevitably	
3-21	436-443	changes	
3-22	444-448	that	
3-23	449-459	phenomenon	
3-24	459-460	.	
3-25	461-465	This	
3-26	466-468	is	
3-27	469-474	often	
3-28	475-478	the	
3-29	479-485	result	
3-30	486-488	of	
3-31	489-500	instruments	
3-32	501-505	that	
3-33	505-506	,	
3-34	507-509	by	
3-35	510-519	necessity	
3-36	519-520	,	
3-37	521-526	alter	
3-38	527-530	the	
3-39	531-536	state	
3-40	537-539	of	
3-41	540-544	what	
3-42	545-549	they	
3-43	550-557	measure	
3-44	558-560	in	
3-45	561-565	some	
3-46	566-572	manner	
3-47	572-573	.	
3-48	574-582	Observer	
3-49	583-589	effect	
3-50	589-590	,	
3-51	591-600	Wikipedia	
3-52	601-602	(	
3-53	602-606	edit	
3-54	606-607	;	
3-55	608-612	this	
3-56	613-623	previously	
3-57	624-632	referred	
3-58	633-635	to	
3-59	636-639	the	

#Text=Uncertainty principle) In layman’s terms, what the Observer effect states is that by measuring a property of a system, you may be altering that system itself: your observation becomes a distorted version of the reality. In most cases, this distortion is negligible and we can simply ignore it. If
4-1	640-651	Uncertainty	
4-2	652-661	principle	
4-3	661-662	)	
4-4	663-665	In	
4-5	666-672	layman	
4-6	672-673	’	
4-7	673-674	s	
4-8	675-680	terms	
4-9	680-681	,	
4-10	682-686	what	
4-11	687-690	the	
4-12	691-699	Observer	
4-13	700-706	effect	
4-14	707-713	states	
4-15	714-716	is	
4-16	717-721	that	
4-17	722-724	by	
4-18	725-734	measuring	
4-19	735-736	a	
4-20	737-745	property	
4-21	746-748	of	
4-22	749-750	a	
4-23	751-757	system	
4-24	757-758	,	
4-25	759-762	you	
4-26	763-766	may	
4-27	767-769	be	
4-28	770-778	altering	
4-29	779-783	that	
4-30	784-790	system	
4-31	791-797	itself	
4-32	797-798	:	
4-33	799-803	your	
4-34	804-815	observation	
4-35	816-823	becomes	
4-36	824-825	a	
4-37	826-835	distorted	
4-38	836-843	version	
4-39	844-846	of	
4-40	847-850	the	
4-41	851-858	reality	
4-42	858-859	.	
4-43	860-862	In	
4-44	863-867	most	
4-45	868-873	cases	
4-46	873-874	,	
4-47	875-879	this	
4-48	880-890	distortion	
4-49	891-893	is	
4-50	894-904	negligible	
4-51	905-908	and	
4-52	909-911	we	
4-53	912-915	can	
4-54	916-922	simply	
4-55	923-929	ignore	
4-56	930-932	it	
4-57	932-933	.	
4-58	934-936	If	

#Text=we use a thermometer to measure someone’s temperature, some heat will be transferred from the person to the termometer, effectively lowering the person’s temperature. But it should not be noticeable, and well below the error margin of the thermometer. But what happens when the measurement may not just affect, but rather completely ruin the measurement?
5-1	937-939	we	
5-2	940-943	use	
5-3	944-945	a	
5-4	946-957	thermometer	
5-5	958-960	to	
5-6	961-968	measure	
5-7	969-976	someone	
5-8	976-977	’	
5-9	977-978	s	
5-10	979-990	temperature	
5-11	990-991	,	
5-12	992-996	some	
5-13	997-1001	heat	
5-14	1002-1006	will	
5-15	1007-1009	be	
5-16	1010-1021	transferred	
5-17	1022-1026	from	
5-18	1027-1030	the	
5-19	1031-1037	person	
5-20	1038-1040	to	
5-21	1041-1044	the	
5-22	1045-1055	termometer	
5-23	1055-1056	,	
5-24	1057-1068	effectively	
5-25	1069-1077	lowering	
5-26	1078-1081	the	
5-27	1082-1088	person	
5-28	1088-1089	’	
5-29	1089-1090	s	
5-30	1091-1102	temperature	
5-31	1102-1103	.	
5-32	1104-1107	But	
5-33	1108-1110	it	
5-34	1111-1117	should	
5-35	1118-1121	not	
5-36	1122-1124	be	
5-37	1125-1135	noticeable	
5-38	1135-1136	,	
5-39	1137-1140	and	
5-40	1141-1145	well	
5-41	1146-1151	below	
5-42	1152-1155	the	
5-43	1156-1161	error	
5-44	1162-1168	margin	
5-45	1169-1171	of	
5-46	1172-1175	the	
5-47	1176-1187	thermometer	
5-48	1187-1188	.	
5-49	1189-1192	But	
5-50	1193-1197	what	
5-51	1198-1205	happens	
5-52	1206-1210	when	
5-53	1211-1214	the	
5-54	1215-1226	measurement	
5-55	1227-1230	may	
5-56	1231-1234	not	
5-57	1235-1239	just	
5-58	1240-1246	affect	
5-59	1246-1247	,	
5-60	1248-1251	but	
5-61	1252-1258	rather	
5-62	1259-1269	completely	
5-63	1270-1274	ruin	
5-64	1275-1278	the	
5-65	1279-1290	measurement	
5-66	1290-1291	?	

#Text=Where the potential lie is You are probably resorting a lot to use Postgres' EXPLAIN ANALYZE command when you want to optimize a query’s performance. You probably look at the query nodes, see which ones have the highest execution time and then try to
6-1	1292-1297	Where	
6-2	1298-1301	the	
6-3	1302-1311	potential	
6-4	1312-1315	lie	
6-5	1316-1318	is	
6-6	1319-1322	You	
6-7	1323-1326	are	
6-8	1327-1335	probably	
6-9	1336-1345	resorting	
6-10	1346-1347	a	
6-11	1348-1351	lot	
6-12	1352-1354	to	
6-13	1355-1358	use	
6-14	1359-1367	Postgres	
6-15	1367-1368	'	
6-16	1369-1376	EXPLAIN	
6-17	1377-1384	ANALYZE	
6-18	1385-1392	command	
6-19	1393-1397	when	
6-20	1398-1401	you	
6-21	1402-1406	want	
6-22	1407-1409	to	
6-23	1410-1418	optimize	
6-24	1419-1420	a	
6-25	1421-1426	query	
6-26	1426-1427	’	
6-27	1427-1428	s	
6-28	1429-1440	performance	
6-29	1440-1441	.	
6-30	1442-1445	You	
6-31	1446-1454	probably	
6-32	1455-1459	look	
6-33	1460-1462	at	
6-34	1463-1466	the	
6-35	1467-1472	query	
6-36	1473-1478	nodes	
6-37	1478-1479	,	
6-38	1480-1483	see	
6-39	1484-1489	which	
6-40	1490-1494	ones	
6-41	1495-1499	have	
6-42	1500-1503	the	
6-43	1504-1511	highest	
6-44	1512-1521	execution	
6-45	1522-1526	time	
6-46	1527-1530	and	
6-47	1531-1535	then	
6-48	1536-1539	try	
6-49	1540-1542	to	

#Text=optimize them. The costlier the node is, the biggest return of investment you get if you can optimize it. Obviously, a query optimization may change the query plan altogether, but you get the point: you want to know where most of the query execution time is going. Now grab your favorite Postgres and run the following commands:
7-1	1543-1551	optimize	
7-2	1552-1556	them	
7-3	1556-1557	.	
7-4	1558-1561	The	
7-5	1562-1570	costlier	
7-6	1571-1574	the	
7-7	1575-1579	node	
7-8	1580-1582	is	
7-9	1582-1583	,	
7-10	1584-1587	the	
7-11	1588-1595	biggest	
7-12	1596-1602	return	
7-13	1603-1605	of	
7-14	1606-1616	investment	
7-15	1617-1620	you	
7-16	1621-1624	get	
7-17	1625-1627	if	
7-18	1628-1631	you	
7-19	1632-1635	can	
7-20	1636-1644	optimize	
7-21	1645-1647	it	
7-22	1647-1648	.	
7-23	1649-1658	Obviously	
7-24	1658-1659	,	
7-25	1660-1661	a	
7-26	1662-1667	query	
7-27	1668-1680	optimization	
7-28	1681-1684	may	
7-29	1685-1691	change	
7-30	1692-1695	the	
7-31	1696-1701	query	
7-32	1702-1706	plan	
7-33	1707-1717	altogether	
7-34	1717-1718	,	
7-35	1719-1722	but	
7-36	1723-1726	you	
7-37	1727-1730	get	
7-38	1731-1734	the	
7-39	1735-1740	point	
7-40	1740-1741	:	
7-41	1742-1745	you	
7-42	1746-1750	want	
7-43	1751-1753	to	
7-44	1754-1758	know	
7-45	1759-1764	where	
7-46	1765-1769	most	
7-47	1770-1772	of	
7-48	1773-1776	the	
7-49	1777-1782	query	
7-50	1783-1792	execution	
7-51	1793-1797	time	
7-52	1798-1800	is	
7-53	1801-1806	going	
7-54	1806-1807	.	
7-55	1808-1811	Now	
7-56	1812-1816	grab	
7-57	1817-1821	your	
7-58	1822-1830	favorite	
7-59	1831-1839	Postgres	
7-60	1840-1843	and	
7-61	1844-1847	run	
7-62	1848-1851	the	
7-63	1852-1861	following	
7-64	1862-1870	commands	
7-65	1870-1871	:	

#Text=create table i1 as select i from generate_series(1,1000*1000) as i; create table i2 as select i from generate_series(1,1000) as i; analyze; explain analyze select sum(i1.i * i2.i) from i1 inner join i2 using (i);
8-1	1872-1878	create	
8-2	1879-1884	table	
8-3	1885-1887	i1	
8-4	1888-1890	as	
8-5	1891-1897	select	
8-6	1898-1899	i	
8-7	1900-1904	from	
8-8	1905-1920	generate_series	
8-9	1920-1921	(	
8-10	1921-1927	1,1000	
8-11	1927-1928	*	
8-12	1928-1932	1000	
8-13	1932-1933	)	
8-14	1934-1936	as	
8-15	1937-1938	i	
8-16	1938-1939	;	
8-17	1940-1946	create	
8-18	1947-1952	table	
8-19	1953-1955	i2	
8-20	1956-1958	as	
8-21	1959-1965	select	
8-22	1966-1967	i	
8-23	1968-1972	from	
8-24	1973-1988	generate_series	
8-25	1988-1989	(	
8-26	1989-1995	1,1000	
8-27	1995-1996	)	
8-28	1997-1999	as	
8-29	2000-2001	i	
8-30	2001-2002	;	
8-31	2003-2010	analyze	
8-32	2010-2011	;	
8-33	2012-2019	explain	
8-34	2020-2027	analyze	
8-35	2028-2034	select	
8-36	2035-2038	sum	
8-37	2038-2039	(	
8-38	2039-2041	i1	
8-39	2041-2042	.	
8-40	2042-2043	i	
8-41	2044-2045	*	
8-42	2046-2048	i2	
8-43	2048-2049	.	
8-44	2049-2050	i	
8-45	2050-2051	)	
8-46	2052-2056	from	
8-47	2057-2059	i1	
8-48	2060-2065	inner	
8-49	2066-2070	join	
8-50	2071-2073	i2	
8-51	2074-2079	using	
8-52	2080-2081	(	
8-53	2081-2082	i	
8-54	2082-2083	)	
8-55	2083-2084	;	

#Text=Note that the first analyze command is not related at all with the explain analyze command that follows it. Run the query. Note the time reported by explain analyze. Now run the query again and note the execution time without explain analyze. You can do this, for example, by: Running from psql and using both \\timing and \\o /dev/null.
9-1	2085-2089	Note	
9-2	2090-2094	that	
9-3	2095-2098	the	
9-4	2099-2104	first	
9-5	2105-2112	analyze	
9-6	2113-2120	command	
9-7	2121-2123	is	
9-8	2124-2127	not	
9-9	2128-2135	related	
9-10	2136-2138	at	
9-11	2139-2142	all	
9-12	2143-2147	with	
9-13	2148-2151	the	
9-14	2152-2159	explain	
9-15	2160-2167	analyze	
9-16	2168-2175	command	
9-17	2176-2180	that	
9-18	2181-2188	follows	
9-19	2189-2191	it	
9-20	2191-2192	.	
9-21	2193-2196	Run	
9-22	2197-2200	the	
9-23	2201-2206	query	
9-24	2206-2207	.	
9-25	2208-2212	Note	
9-26	2213-2216	the	
9-27	2217-2221	time	
9-28	2222-2230	reported	
9-29	2231-2233	by	
9-30	2234-2241	explain	
9-31	2242-2249	analyze	
9-32	2249-2250	.	
9-33	2251-2254	Now	
9-34	2255-2258	run	
9-35	2259-2262	the	
9-36	2263-2268	query	
9-37	2269-2274	again	
9-38	2275-2278	and	
9-39	2279-2283	note	
9-40	2284-2287	the	
9-41	2288-2297	execution	
9-42	2298-2302	time	
9-43	2303-2310	without	
9-44	2311-2318	explain	
9-45	2319-2326	analyze	
9-46	2326-2327	.	
9-47	2328-2331	You	
9-48	2332-2335	can	
9-49	2336-2338	do	
9-50	2339-2343	this	
9-51	2343-2344	,	
9-52	2345-2348	for	
9-53	2349-2356	example	
9-54	2356-2357	,	
9-55	2358-2360	by	
9-56	2360-2361	:	
9-57	2362-2369	Running	
9-58	2370-2374	from	
9-59	2375-2379	psql	
9-60	2380-2383	and	
9-61	2384-2389	using	
9-62	2390-2394	both	
9-63	2395-2396	\	
9-64	2396-2402	timing	
9-65	2403-2406	and	
9-66	2407-2408	\	
9-67	2408-2409	o	
9-68	2410-2411	/	
9-69	2411-2414	dev	
9-70	2414-2415	/	
9-71	2415-2419	null	
9-72	2419-2420	.	

#Text=Using pg_stat_statements. The latter is a better method, as the former includes client round-trip time and processing. But this overhead should be negligible for this case. Do you see anything wrong? The execution time as reported by EXPLAIN ANALYZE
10-1	2421-2426	Using	
10-2	2427-2445	pg_stat_statements	
10-3	2445-2446	.	
10-4	2447-2450	The	
10-5	2451-2457	latter	
10-6	2458-2460	is	
10-7	2461-2462	a	
10-8	2463-2469	better	
10-9	2470-2476	method	
10-10	2476-2477	,	
10-11	2478-2480	as	
10-12	2481-2484	the	
10-13	2485-2491	former	
10-14	2492-2500	includes	
10-15	2501-2507	client	
10-16	2508-2518	round-trip	
10-17	2519-2523	time	
10-18	2524-2527	and	
10-19	2528-2538	processing	
10-20	2538-2539	.	
10-21	2540-2543	But	
10-22	2544-2548	this	
10-23	2549-2557	overhead	
10-24	2558-2564	should	
10-25	2565-2567	be	
10-26	2568-2578	negligible	
10-27	2579-2582	for	
10-28	2583-2587	this	
10-29	2588-2592	case	
10-30	2592-2593	.	
10-31	2594-2596	Do	
10-32	2597-2600	you	
10-33	2601-2604	see	
10-34	2605-2613	anything	
10-35	2614-2619	wrong	
10-36	2619-2620	?	
10-37	2621-2624	The	
10-38	2625-2634	execution	
10-39	2635-2639	time	
10-40	2640-2642	as	
10-41	2643-2651	reported	
10-42	2652-2654	by	
10-43	2655-2662	EXPLAIN	
10-44	2663-2670	ANALYZE	

#Text=is substantially higher than that of the real query execution time. On my system, running 20 times after another 20 times of warmup: query calls total mean min max stddev explain analyze select sum(i1.i * i2.i) from i1 inner join i2 using (i)
11-1	2671-2673	is	
11-2	2674-2687	substantially	
11-3	2688-2694	higher	
11-4	2695-2699	than	
11-5	2700-2704	that	
11-6	2705-2707	of	
11-7	2708-2711	the	
11-8	2712-2716	real	
11-9	2717-2722	query	
11-10	2723-2732	execution	
11-11	2733-2737	time	
11-12	2737-2738	.	
11-13	2739-2741	On	
11-14	2742-2744	my	
11-15	2745-2751	system	
11-16	2751-2752	,	
11-17	2753-2760	running	
11-18	2761-2763	20	
11-19	2764-2769	times	
11-20	2770-2775	after	
11-21	2776-2783	another	
11-22	2784-2786	20	
11-23	2787-2792	times	
11-24	2793-2795	of	
11-25	2796-2802	warmup	
11-26	2802-2803	:	
11-27	2804-2809	query	
11-28	2810-2815	calls	
11-29	2816-2821	total	
11-30	2822-2826	mean	
11-31	2827-2830	min	
11-32	2831-2834	max	
11-33	2835-2841	stddev	
11-34	2842-2849	explain	
11-35	2850-2857	analyze	
11-36	2858-2864	select	
11-37	2865-2868	sum	
11-38	2868-2869	(	
11-39	2869-2871	i1	
11-40	2871-2872	.	
11-41	2872-2873	i	
11-42	2874-2875	*	
11-43	2876-2878	i2	
11-44	2878-2879	.	
11-45	2879-2880	i	
11-46	2880-2881	)	
11-47	2882-2886	from	
11-48	2887-2889	i1	
11-49	2890-2895	inner	
11-50	2896-2900	join	
11-51	2901-2903	i2	
11-52	2904-2909	using	
11-53	2910-2911	(	
11-54	2911-2912	i	
11-55	2912-2913	)	

#Text=917.20 45.86 45.32 49.24 0.84 select sum(i1.i * i2.i) from i1 inner join i2 using (i) 615.73 30.79 30.06
12-1	2914-2920	917.20	
12-2	2921-2926	45.86	
12-3	2927-2932	45.32	
12-4	2933-2938	49.24	
12-5	2939-2943	0.84	
12-6	2944-2950	select	
12-7	2951-2954	sum	
12-8	2954-2955	(	
12-9	2955-2957	i1	
12-10	2957-2958	.	
12-11	2958-2959	i	
12-12	2960-2961	*	
12-13	2962-2964	i2	
12-14	2964-2965	.	
12-15	2965-2966	i	
12-16	2966-2967	)	
12-17	2968-2972	from	
12-18	2973-2975	i1	
12-19	2976-2981	inner	
12-20	2982-2986	join	
12-21	2987-2989	i2	
12-22	2990-2995	using	
12-23	2996-2997	(	
12-24	2997-2998	i	
12-25	2998-2999	)	
12-26	3000-3006	615.73	
12-27	3007-3012	30.79	
12-28	3013-3018	30.06	

#Text=34.48 0.92 That’s about a 50% overhead! As we can see here, the measurement is significantly altering the observed fact. But it can get much worse. For instance, on a virtual instance running on a non Nitro EC2 instance (r4.large):
13-1	3019-3024	34.48	
13-2	3025-3029	0.92	
13-3	3030-3034	That	
13-4	3034-3035	’	
13-5	3035-3036	s	
13-6	3037-3042	about	
13-7	3043-3044	a	
13-8	3045-3048	50%	
13-9	3049-3057	overhead	
13-10	3057-3058	!	
13-11	3059-3061	As	
13-12	3062-3064	we	
13-13	3065-3068	can	
13-14	3069-3072	see	
13-15	3073-3077	here	
13-16	3077-3078	,	
13-17	3079-3082	the	
13-18	3083-3094	measurement	
13-19	3095-3097	is	
13-20	3098-3111	significantly	
13-21	3112-3120	altering	
13-22	3121-3124	the	
13-23	3125-3133	observed	
13-24	3134-3138	fact	
13-25	3138-3139	.	
13-26	3140-3143	But	
13-27	3144-3146	it	
13-28	3147-3150	can	
13-29	3151-3154	get	
13-30	3155-3159	much	
13-31	3160-3165	worse	
13-32	3165-3166	.	
13-33	3167-3170	For	
13-34	3171-3179	instance	
13-35	3179-3180	,	
13-36	3181-3183	on	
13-37	3184-3185	a	
13-38	3186-3193	virtual	
13-39	3194-3202	instance	
13-40	3203-3210	running	
13-41	3211-3213	on	
13-42	3214-3215	a	
13-43	3216-3219	non	
13-44	3220-3225	Nitro	
13-45	3226-3229	EC2	
13-46	3230-3238	instance	
13-47	3239-3240	(	
13-48	3240-3242	r4	
13-49	3242-3243	.	
13-50	3243-3248	large	
13-51	3248-3249	)	
13-52	3249-3250	:	

#Text=query calls total mean min max stddev explain analyze select sum(i1.i * i2.i) from i1 inner join i2 using (i) 21080.18 1054.01
14-1	3251-3256	query	
14-2	3257-3262	calls	
14-3	3263-3268	total	
14-4	3269-3273	mean	
14-5	3274-3277	min	
14-6	3278-3281	max	
14-7	3282-3288	stddev	
14-8	3289-3296	explain	
14-9	3297-3304	analyze	
14-10	3305-3311	select	
14-11	3312-3315	sum	
14-12	3315-3316	(	
14-13	3316-3318	i1	
14-14	3318-3319	.	
14-15	3319-3320	i	
14-16	3321-3322	*	
14-17	3323-3325	i2	
14-18	3325-3326	.	
14-19	3326-3327	i	
14-20	3327-3328	)	
14-21	3329-3333	from	
14-22	3334-3336	i1	
14-23	3337-3342	inner	
14-24	3343-3347	join	
14-25	3348-3350	i2	
14-26	3351-3356	using	
14-27	3357-3358	(	
14-28	3358-3359	i	
14-29	3359-3360	)	
14-30	3361-3369	21080.18	
14-31	3370-3377	1054.01	

#Text=1053.36 1055.96 0.55 select sum(i1.i * i2.i) from i1 inner join i2 using (i) 2596.85 129.84 129.33 130.45 0.28
15-1	3378-3385	1053.36	
15-2	3386-3393	1055.96	
15-3	3394-3398	0.55	
15-4	3399-3405	select	
15-5	3406-3409	sum	
15-6	3409-3410	(	
15-7	3410-3412	i1	
15-8	3412-3413	.	
15-9	3413-3414	i	
15-10	3415-3416	*	
15-11	3417-3419	i2	
15-12	3419-3420	.	
15-13	3420-3421	i	
15-14	3421-3422	)	
15-15	3423-3427	from	
15-16	3428-3430	i1	
15-17	3431-3436	inner	
15-18	3437-3441	join	
15-19	3442-3444	i2	
15-20	3445-3450	using	
15-21	3451-3452	(	
15-22	3452-3453	i	
15-23	3453-3454	)	
15-24	3455-3462	2596.85	
15-25	3463-3469	129.84	
15-26	3470-3476	129.33	
15-27	3477-3483	130.45	
15-28	3484-3488	0.28	

#Text=Here EXPLAIN ANALYZE got 8 times slower, a 700% overhead! Astute readers may realize that this effect is related to the system clock. Non Nitro instances are virtualized with Xen, which exposes a xen virtualized clock to the VMs. On Nitro instances and other virtualized environments where
16-1	3489-3493	Here	
16-2	3494-3501	EXPLAIN	
16-3	3502-3509	ANALYZE	
16-4	3510-3513	got	
16-5	3514-3515	8	
16-6	3516-3521	times	
16-7	3522-3528	slower	
16-8	3528-3529	,	
16-9	3530-3531	a	
16-10	3532-3536	700%	
16-11	3537-3545	overhead	
16-12	3545-3546	!	
16-13	3547-3553	Astute	
16-14	3554-3561	readers	
16-15	3562-3565	may	
16-16	3566-3573	realize	
16-17	3574-3578	that	
16-18	3579-3583	this	
16-19	3584-3590	effect	
16-20	3591-3593	is	
16-21	3594-3601	related	
16-22	3602-3604	to	
16-23	3605-3608	the	
16-24	3609-3615	system	
16-25	3616-3621	clock	
16-26	3621-3622	.	
16-27	3623-3626	Non	
16-28	3627-3632	Nitro	
16-29	3633-3642	instances	
16-30	3643-3646	are	
16-31	3647-3658	virtualized	
16-32	3659-3663	with	
16-33	3664-3667	Xen	
16-34	3667-3668	,	
16-35	3669-3674	which	
16-36	3675-3682	exposes	
16-37	3683-3684	a	
16-38	3685-3688	xen	
16-39	3689-3700	virtualized	
16-40	3701-3706	clock	
16-41	3707-3709	to	
16-42	3710-3713	the	
16-43	3714-3717	VMs	
16-44	3717-3718	.	
16-45	3719-3721	On	
16-46	3722-3727	Nitro	
16-47	3728-3737	instances	
16-48	3738-3741	and	
16-49	3742-3747	other	
16-50	3748-3759	virtualized	
16-51	3760-3772	environments	
16-52	3773-3778	where	

#Text=KVM is used, clock is as fast as the hypervisor’s, and results are similar to the first ones shown here. We may also mitigate this effort on r4.large by switching to the tsc time source: echo tsc | sudo tee -a /sys/devices/system/clocksource/clocksource0/current_clocksource
17-1	3779-3782	KVM	
17-2	3783-3785	is	
17-3	3786-3790	used	
17-4	3790-3791	,	
17-5	3792-3797	clock	
17-6	3798-3800	is	
17-7	3801-3803	as	
17-8	3804-3808	fast	
17-9	3809-3811	as	
17-10	3812-3815	the	
17-11	3816-3826	hypervisor	
17-12	3826-3827	’	
17-13	3827-3828	s	
17-14	3828-3829	,	
17-15	3830-3833	and	
17-16	3834-3841	results	
17-17	3842-3845	are	
17-18	3846-3853	similar	
17-19	3854-3856	to	
17-20	3857-3860	the	
17-21	3861-3866	first	
17-22	3867-3871	ones	
17-23	3872-3877	shown	
17-24	3878-3882	here	
17-25	3882-3883	.	
17-26	3884-3886	We	
17-27	3887-3890	may	
17-28	3891-3895	also	
17-29	3896-3904	mitigate	
17-30	3905-3909	this	
17-31	3910-3916	effort	
17-32	3917-3919	on	
17-33	3920-3922	r4	
17-34	3922-3923	.	
17-35	3923-3928	large	
17-36	3929-3931	by	
17-37	3932-3941	switching	
17-38	3942-3944	to	
17-39	3945-3948	the	
17-40	3949-3952	tsc	
17-41	3953-3957	time	
17-42	3958-3964	source	
17-43	3964-3965	:	
17-44	3966-3970	echo	
17-45	3971-3974	tsc	
17-46	3975-3976	|	
17-47	3977-3981	sudo	
17-48	3982-3985	tee	
17-49	3986-3987	-	
17-50	3987-3988	a	
17-51	3989-3990	/	
17-52	3990-3993	sys	
17-53	3993-3994	/	
17-54	3994-4001	devices	
17-55	4001-4002	/	
17-56	4002-4008	system	
17-57	4008-4009	/	
17-58	4009-4020	clocksource	
17-59	4020-4021	/	
17-60	4021-4033	clocksource0	
17-61	4033-4034	/	
17-62	4034-4053	current_clocksource	

#Text=query calls total mean min max stddev explain analyze select sum(i1.i * i2.i) from i1 inner join i2 using (i) 3747.07 187.37 187.12
18-1	4054-4059	query	
18-2	4060-4065	calls	
18-3	4066-4071	total	
18-4	4072-4076	mean	
18-5	4077-4080	min	
18-6	4081-4084	max	
18-7	4085-4091	stddev	
18-8	4092-4099	explain	
18-9	4100-4107	analyze	
18-10	4108-4114	select	
18-11	4115-4118	sum	
18-12	4118-4119	(	
18-13	4119-4121	i1	
18-14	4121-4122	.	
18-15	4122-4123	i	
18-16	4124-4125	*	
18-17	4126-4128	i2	
18-18	4128-4129	.	
18-19	4129-4130	i	
18-20	4130-4131	)	
18-21	4132-4136	from	
18-22	4137-4139	i1	
18-23	4140-4145	inner	
18-24	4146-4150	join	
18-25	4151-4153	i2	
18-26	4154-4159	using	
18-27	4160-4161	(	
18-28	4161-4162	i	
18-29	4162-4163	)	
18-30	4164-4171	3747.07	
18-31	4172-4178	187.37	
18-32	4179-4185	187.12	

#Text=187.56 0.12 select sum(i1.i * i2.i) from i1 inner join i2 using (i) 2602.45 130.12 129.88 130.77 0.21
19-1	4186-4192	187.56	
19-2	4193-4197	0.12	
19-3	4198-4204	select	
19-4	4205-4208	sum	
19-5	4208-4209	(	
19-6	4209-4211	i1	
19-7	4211-4212	.	
19-8	4212-4213	i	
19-9	4214-4215	*	
19-10	4216-4218	i2	
19-11	4218-4219	.	
19-12	4219-4220	i	
19-13	4220-4221	)	
19-14	4222-4226	from	
19-15	4227-4229	i1	
19-16	4230-4235	inner	
19-17	4236-4240	join	
19-18	4241-4243	i2	
19-19	4244-4249	using	
19-20	4250-4251	(	
19-21	4251-4252	i	
19-22	4252-4253	)	
19-23	4254-4261	2602.45	
19-24	4262-4268	130.12	
19-25	4269-4275	129.88	
19-26	4276-4282	130.77	
19-27	4283-4287	0.21	

#Text=Also note that results will change if you configure differently max_parallel_workers_per_gather as these results are affected by the level of parallelism used. The good news You shouldn’t be surprised, however. This behavior is known and documented. As usual, Postgres documentation is as complete as it can be:
20-1	4288-4292	Also	
20-2	4293-4297	note	
20-3	4298-4302	that	
20-4	4303-4310	results	
20-5	4311-4315	will	
20-6	4316-4322	change	
20-7	4323-4325	if	
20-8	4326-4329	you	
20-9	4330-4339	configure	
20-10	4340-4351	differently	
20-11	4352-4383	max_parallel_workers_per_gather	
20-12	4384-4386	as	
20-13	4387-4392	these	
20-14	4393-4400	results	
20-15	4401-4404	are	
20-16	4405-4413	affected	
20-17	4414-4416	by	
20-18	4417-4420	the	
20-19	4421-4426	level	
20-20	4427-4429	of	
20-21	4430-4441	parallelism	
20-22	4442-4446	used	
20-23	4446-4447	.	
20-24	4448-4451	The	
20-25	4452-4456	good	
20-26	4457-4461	news	
20-27	4462-4465	You	
20-28	4466-4473	shouldn	
20-29	4473-4474	’	
20-30	4474-4475	t	
20-31	4476-4478	be	
20-32	4479-4488	surprised	
20-33	4488-4489	,	
20-34	4490-4497	however	
20-35	4497-4498	.	
20-36	4499-4503	This	
20-37	4504-4512	behavior	
20-38	4513-4515	is	
20-39	4516-4521	known	
20-40	4522-4525	and	
20-41	4526-4536	documented	
20-42	4536-4537	.	
20-43	4538-4540	As	
20-44	4541-4546	usual	
20-45	4546-4547	,	
20-46	4548-4556	Postgres	
20-47	4557-4570	documentation	
20-48	4571-4573	is	
20-49	4574-4576	as	
20-50	4577-4585	complete	
20-51	4586-4588	as	
20-52	4589-4591	it	
20-53	4592-4595	can	
20-54	4596-4598	be	
20-55	4598-4599	:	

#Text=The measurement overhead added by EXPLAIN ANALYZE can be significant, especially on machines with slow gettimeofday() operating-system calls. You can use the pg_test_timing tool to measure the overhead of timing on your system. EXPLAIN caveats However, I have found that many users and DBAs are either unaware of this effect
21-1	4600-4603	The	
21-2	4604-4615	measurement	
21-3	4616-4624	overhead	
21-4	4625-4630	added	
21-5	4631-4633	by	
21-6	4634-4641	EXPLAIN	
21-7	4642-4649	ANALYZE	
21-8	4650-4653	can	
21-9	4654-4656	be	
21-10	4657-4668	significant	
21-11	4668-4669	,	
21-12	4670-4680	especially	
21-13	4681-4683	on	
21-14	4684-4692	machines	
21-15	4693-4697	with	
21-16	4698-4702	slow	
21-17	4703-4715	gettimeofday	
21-18	4715-4716	(	
21-19	4716-4717	)	
21-20	4718-4734	operating-system	
21-21	4735-4740	calls	
21-22	4740-4741	.	
21-23	4742-4745	You	
21-24	4746-4749	can	
21-25	4750-4753	use	
21-26	4754-4757	the	
21-27	4758-4772	pg_test_timing	
21-28	4773-4777	tool	
21-29	4778-4780	to	
21-30	4781-4788	measure	
21-31	4789-4792	the	
21-32	4793-4801	overhead	
21-33	4802-4804	of	
21-34	4805-4811	timing	
21-35	4812-4814	on	
21-36	4815-4819	your	
21-37	4820-4826	system	
21-38	4826-4827	.	
21-39	4828-4835	EXPLAIN	
21-40	4836-4843	caveats	
21-41	4844-4851	However	
21-42	4851-4852	,	
21-43	4853-4854	I	
21-44	4855-4859	have	
21-45	4860-4865	found	
21-46	4866-4870	that	
21-47	4871-4875	many	
21-48	4876-4881	users	
21-49	4882-4885	and	
21-50	4886-4890	DBAs	
21-51	4891-4894	are	
21-52	4895-4901	either	
21-53	4902-4909	unaware	
21-54	4910-4912	of	
21-55	4913-4917	this	
21-56	4918-4924	effect	

#Text=or not aware of how significant it may be. This post is my humble contribution to make this effect more widely unserstood. The Volcano Why is this happening, after all? Postgres, like other OLTP databases, follows a query execution model named the Volcano model.
22-1	4925-4927	or	
22-2	4928-4931	not	
22-3	4932-4937	aware	
22-4	4938-4940	of	
22-5	4941-4944	how	
22-6	4945-4956	significant	
22-7	4957-4959	it	
22-8	4960-4963	may	
22-9	4964-4966	be	
22-10	4966-4967	.	
22-11	4968-4972	This	
22-12	4973-4977	post	
22-13	4978-4980	is	
22-14	4981-4983	my	
22-15	4984-4990	humble	
22-16	4991-5003	contribution	
22-17	5004-5006	to	
22-18	5007-5011	make	
22-19	5012-5016	this	
22-20	5017-5023	effect	
22-21	5024-5028	more	
22-22	5029-5035	widely	
22-23	5036-5046	unserstood	
22-24	5046-5047	.	
22-25	5048-5051	The	
22-26	5052-5059	Volcano	
22-27	5060-5063	Why	
22-28	5064-5066	is	
22-29	5067-5071	this	
22-30	5072-5081	happening	
22-31	5081-5082	,	
22-32	5083-5088	after	
22-33	5089-5092	all	
22-34	5092-5093	?	
22-35	5094-5102	Postgres	
22-36	5102-5103	,	
22-37	5104-5108	like	
22-38	5109-5114	other	
22-39	5115-5119	OLTP	
22-40	5120-5129	databases	
22-41	5129-5130	,	
22-42	5131-5138	follows	
22-43	5139-5140	a	
22-44	5141-5146	query	
22-45	5147-5156	execution	
22-46	5157-5162	model	
22-47	5163-5168	named	
22-48	5169-5172	the	
22-49	5173-5180	Volcano	
22-50	5181-5186	model	
22-51	5186-5187	.	

#Text=Under this model, also known as one-row-at-a-time, each node of the query execution tree contains code to process rows one by one. Instead of every node gathering all the rows belonging to it before combining with the next node, as soon as a row is gathered at one node, it is processed through the rest of the tree. This makes sense –gathering all the rows at a given node may require to
23-1	5188-5193	Under	
23-2	5194-5198	this	
23-3	5199-5204	model	
23-4	5204-5205	,	
23-5	5206-5210	also	
23-6	5211-5216	known	
23-7	5217-5219	as	
23-8	5220-5237	one-row-at-a-time	
23-9	5237-5238	,	
23-10	5239-5243	each	
23-11	5244-5248	node	
23-12	5249-5251	of	
23-13	5252-5255	the	
23-14	5256-5261	query	
23-15	5262-5271	execution	
23-16	5272-5276	tree	
23-17	5277-5285	contains	
23-18	5286-5290	code	
23-19	5291-5293	to	
23-20	5294-5301	process	
23-21	5302-5306	rows	
23-22	5307-5310	one	
23-23	5311-5313	by	
23-24	5314-5317	one	
23-25	5317-5318	.	
23-26	5319-5326	Instead	
23-27	5327-5329	of	
23-28	5330-5335	every	
23-29	5336-5340	node	
23-30	5341-5350	gathering	
23-31	5351-5354	all	
23-32	5355-5358	the	
23-33	5359-5363	rows	
23-34	5364-5373	belonging	
23-35	5374-5376	to	
23-36	5377-5379	it	
23-37	5380-5386	before	
23-38	5387-5396	combining	
23-39	5397-5401	with	
23-40	5402-5405	the	
23-41	5406-5410	next	
23-42	5411-5415	node	
23-43	5415-5416	,	
23-44	5417-5419	as	
23-45	5420-5424	soon	
23-46	5425-5427	as	
23-47	5428-5429	a	
23-48	5430-5433	row	
23-49	5434-5436	is	
23-50	5437-5445	gathered	
23-51	5446-5448	at	
23-52	5449-5452	one	
23-53	5453-5457	node	
23-54	5457-5458	,	
23-55	5459-5461	it	
23-56	5462-5464	is	
23-57	5465-5474	processed	
23-58	5475-5482	through	
23-59	5483-5486	the	
23-60	5487-5491	rest	
23-61	5492-5494	of	
23-62	5495-5498	the	
23-63	5499-5503	tree	
23-64	5503-5504	.	
23-65	5505-5509	This	
23-66	5510-5515	makes	
23-67	5516-5521	sense	
23-68	5522-5523	–	
23-69	5523-5532	gathering	
23-70	5533-5536	all	
23-71	5537-5540	the	
23-72	5541-5545	rows	
23-73	5546-5548	at	
23-74	5549-5550	a	
23-75	5551-5556	given	
23-76	5557-5561	node	
23-77	5562-5565	may	
23-78	5566-5573	require	
23-79	5574-5576	to	

#Text=hold all that data in memory, which could be impossible–, but it introduced the EXPLAIN ANALYZE problem described here. The executor processes a tree of “plan nodes”. The plan tree is essentially a demand-pull pipeline of tuple processing operations. Each node, when
24-1	5577-5581	hold	
24-2	5582-5585	all	
24-3	5586-5590	that	
24-4	5591-5595	data	
24-5	5596-5598	in	
24-6	5599-5605	memory	
24-7	5605-5606	,	
24-8	5607-5612	which	
24-9	5613-5618	could	
24-10	5619-5621	be	
24-11	5622-5632	impossible	
24-12	5632-5633	–	
24-13	5633-5634	,	
24-14	5635-5638	but	
24-15	5639-5641	it	
24-16	5642-5652	introduced	
24-17	5653-5656	the	
24-18	5657-5664	EXPLAIN	
24-19	5665-5672	ANALYZE	
24-20	5673-5680	problem	
24-21	5681-5690	described	
24-22	5691-5695	here	
24-23	5695-5696	.	
24-24	5697-5700	The	
24-25	5701-5709	executor	
24-26	5710-5719	processes	
24-27	5720-5721	a	
24-28	5722-5726	tree	
24-29	5727-5729	of	
24-30	5730-5731	“	
24-31	5731-5735	plan	
24-32	5736-5741	nodes	
24-33	5741-5742	”	
24-34	5742-5743	.	
24-35	5744-5747	The	
24-36	5748-5752	plan	
24-37	5753-5757	tree	
24-38	5758-5760	is	
24-39	5761-5772	essentially	
24-40	5773-5774	a	
24-41	5775-5786	demand-pull	
24-42	5787-5795	pipeline	
24-43	5796-5798	of	
24-44	5799-5804	tuple	
24-45	5805-5815	processing	
24-46	5816-5826	operations	
24-47	5826-5827	.	
24-48	5828-5832	Each	
24-49	5833-5837	node	
24-50	5837-5838	,	
24-51	5839-5843	when	

#Text=called, will produce the next tuple in its output sequence, or NULL if no more tuples are available. If the node is not a primitive relation-scanning node, it will have child node(s) that it calls in turn to obtain input tuples. src/backend/executor/README
25-1	5844-5850	called	
25-2	5850-5851	,	
25-3	5852-5856	will	
25-4	5857-5864	produce	
25-5	5865-5868	the	
25-6	5869-5873	next	
25-7	5874-5879	tuple	
25-8	5880-5882	in	
25-9	5883-5886	its	
25-10	5887-5893	output	
25-11	5894-5902	sequence	
25-12	5902-5903	,	
25-13	5904-5906	or	
25-14	5907-5911	NULL	
25-15	5912-5914	if	
25-16	5915-5917	no	
25-17	5918-5922	more	
25-18	5923-5929	tuples	
25-19	5930-5933	are	
25-20	5934-5943	available	
25-21	5943-5944	.	
25-22	5945-5947	If	
25-23	5948-5951	the	
25-24	5952-5956	node	
25-25	5957-5959	is	
25-26	5960-5963	not	
25-27	5964-5965	a	
25-28	5966-5975	primitive	
25-29	5976-5993	relation-scanning	
25-30	5994-5998	node	
25-31	5998-5999	,	
25-32	6000-6002	it	
25-33	6003-6007	will	
25-34	6008-6012	have	
25-35	6013-6018	child	
25-36	6019-6023	node	
25-37	6023-6024	(	
25-38	6024-6025	s	
25-39	6025-6026	)	
25-40	6027-6031	that	
25-41	6032-6034	it	
25-42	6035-6040	calls	
25-43	6041-6043	in	
25-44	6044-6048	turn	
25-45	6049-6051	to	
25-46	6052-6058	obtain	
25-47	6059-6064	input	
25-48	6065-6071	tuples	
25-49	6071-6072	.	
25-50	6073-6076	src	
25-51	6076-6077	/	
25-52	6077-6084	backend	
25-53	6084-6085	/	
25-54	6085-6093	executor	
25-55	6093-6094	/	
25-56	6094-6100	README	

#Text=So we can already explain exactly where the overhead comes from: in order to measure the execution time of a given node, as shown by explain analyze, you need to measure the execution time on a per-row basis, and then aggregate them per node, to obtain the total execution time per node. Since rows are not executed one after the other (since a row may be processed by
26-1	6101-6103	So	
26-2	6104-6106	we	
26-3	6107-6110	can	
26-4	6111-6118	already	
26-5	6119-6126	explain	
26-6	6127-6134	exactly	
26-7	6135-6140	where	
26-8	6141-6144	the	
26-9	6145-6153	overhead	
26-10	6154-6159	comes	
26-11	6160-6164	from	
26-12	6164-6165	:	
26-13	6166-6168	in	
26-14	6169-6174	order	
26-15	6175-6177	to	
26-16	6178-6185	measure	
26-17	6186-6189	the	
26-18	6190-6199	execution	
26-19	6200-6204	time	
26-20	6205-6207	of	
26-21	6208-6209	a	
26-22	6210-6215	given	
26-23	6216-6220	node	
26-24	6220-6221	,	
26-25	6222-6224	as	
26-26	6225-6230	shown	
26-27	6231-6233	by	
26-28	6234-6241	explain	
26-29	6242-6249	analyze	
26-30	6249-6250	,	
26-31	6251-6254	you	
26-32	6255-6259	need	
26-33	6260-6262	to	
26-34	6263-6270	measure	
26-35	6271-6274	the	
26-36	6275-6284	execution	
26-37	6285-6289	time	
26-38	6290-6292	on	
26-39	6293-6294	a	
26-40	6295-6302	per-row	
26-41	6303-6308	basis	
26-42	6308-6309	,	
26-43	6310-6313	and	
26-44	6314-6318	then	
26-45	6319-6328	aggregate	
26-46	6329-6333	them	
26-47	6334-6337	per	
26-48	6338-6342	node	
26-49	6342-6343	,	
26-50	6344-6346	to	
26-51	6347-6353	obtain	
26-52	6354-6357	the	
26-53	6358-6363	total	
26-54	6364-6373	execution	
26-55	6374-6378	time	
26-56	6379-6382	per	
26-57	6383-6387	node	
26-58	6387-6388	.	
26-59	6389-6394	Since	
26-60	6395-6399	rows	
26-61	6400-6403	are	
26-62	6404-6407	not	
26-63	6408-6416	executed	
26-64	6417-6420	one	
26-65	6421-6426	after	
26-66	6427-6430	the	
26-67	6431-6436	other	
26-68	6437-6438	(	
26-69	6438-6443	since	
26-70	6444-6445	a	
26-71	6446-6449	row	
26-72	6450-6453	may	
26-73	6454-6456	be	
26-74	6457-6466	processed	
26-75	6467-6469	by	

#Text=other nodes first), you basically need to get the system time before and after processing every row. In other words: you are calling the system twice per row. On a node that processes millions of rows, you are then calling the system time millions of times. But how cheap (or expensive) is it to call the system clock? In Postgres, this
27-1	6470-6475	other	
27-2	6476-6481	nodes	
27-3	6482-6487	first	
27-4	6487-6488	)	
27-5	6488-6489	,	
27-6	6490-6493	you	
27-7	6494-6503	basically	
27-8	6504-6508	need	
27-9	6509-6511	to	
27-10	6512-6515	get	
27-11	6516-6519	the	
27-12	6520-6526	system	
27-13	6527-6531	time	
27-14	6532-6538	before	
27-15	6539-6542	and	
27-16	6543-6548	after	
27-17	6549-6559	processing	
27-18	6560-6565	every	
27-19	6566-6569	row	
27-20	6569-6570	.	
27-21	6571-6573	In	
27-22	6574-6579	other	
27-23	6580-6585	words	
27-24	6585-6586	:	
27-25	6587-6590	you	
27-26	6591-6594	are	
27-27	6595-6602	calling	
27-28	6603-6606	the	
27-29	6607-6613	system	
27-30	6614-6619	twice	
27-31	6620-6623	per	
27-32	6624-6627	row	
27-33	6627-6628	.	
27-34	6629-6631	On	
27-35	6632-6633	a	
27-36	6634-6638	node	
27-37	6639-6643	that	
27-38	6644-6653	processes	
27-39	6654-6662	millions	
27-40	6663-6665	of	
27-41	6666-6670	rows	
27-42	6670-6671	,	
27-43	6672-6675	you	
27-44	6676-6679	are	
27-45	6680-6684	then	
27-46	6685-6692	calling	
27-47	6693-6696	the	
27-48	6697-6703	system	
27-49	6704-6708	time	
27-50	6709-6717	millions	
27-51	6718-6720	of	
27-52	6721-6726	times	
27-53	6726-6727	.	
27-54	6728-6731	But	
27-55	6732-6735	how	
27-56	6736-6741	cheap	
27-57	6742-6743	(	
27-58	6743-6745	or	
27-59	6746-6755	expensive	
27-60	6755-6756	)	
27-61	6757-6759	is	
27-62	6760-6762	it	
27-63	6763-6765	to	
27-64	6766-6770	call	
27-65	6771-6774	the	
27-66	6775-6781	system	
27-67	6782-6787	clock	
27-68	6787-6788	?	
27-69	6789-6791	In	
27-70	6792-6800	Postgres	
27-71	6800-6801	,	
27-72	6802-6806	this	

#Text=is implemented in the elapsed_time function, which in turn relies on the INSTR_TIME macros defined in instr_time.h. Which calls the system call clock_gettime, a fast system call on most systems.
28-1	6807-6809	is	
28-2	6810-6821	implemented	
28-3	6822-6824	in	
28-4	6825-6828	the	
28-5	6829-6841	elapsed_time	
28-6	6842-6850	function	
28-7	6850-6851	,	
28-8	6852-6857	which	
28-9	6858-6860	in	
28-10	6861-6865	turn	
28-11	6866-6872	relies	
28-12	6873-6875	on	
28-13	6876-6879	the	
28-14	6880-6890	INSTR_TIME	
28-15	6891-6897	macros	
28-16	6898-6905	defined	
28-17	6906-6908	in	
28-18	6909-6921	instr_time.h	
28-19	6921-6922	.	
28-20	6923-6928	Which	
28-21	6929-6934	calls	
28-22	6935-6938	the	
28-23	6939-6945	system	
28-24	6946-6950	call	
28-25	6951-6964	clock_gettime	
28-26	6964-6965	,	
28-27	6966-6967	a	
28-28	6968-6972	fast	
28-29	6973-6979	system	
28-30	6980-6984	call	
28-31	6985-6987	on	
28-32	6988-6992	most	
28-33	6993-7000	systems	
28-34	7000-7001	.	

#Text=In particular, on Linux, is typically implemented as a VDSO, meaning that there’s no context switch between user and kernel space, making the call significantly faster. But again, how fast is “fast”, if we might be calling this millions of times? Again, Postgres documentation comes to
29-1	7002-7004	In	
29-2	7005-7015	particular	
29-3	7015-7016	,	
29-4	7017-7019	on	
29-5	7020-7025	Linux	
29-6	7025-7026	,	
29-7	7027-7029	is	
29-8	7030-7039	typically	
29-9	7040-7051	implemented	
29-10	7052-7054	as	
29-11	7055-7056	a	
29-12	7057-7061	VDSO	
29-13	7061-7062	,	
29-14	7063-7070	meaning	
29-15	7071-7075	that	
29-16	7076-7081	there	
29-17	7081-7082	’	
29-18	7082-7083	s	
29-19	7084-7086	no	
29-20	7087-7094	context	
29-21	7095-7101	switch	
29-22	7102-7109	between	
29-23	7110-7114	user	
29-24	7115-7118	and	
29-25	7119-7125	kernel	
29-26	7126-7131	space	
29-27	7131-7132	,	
29-28	7133-7139	making	
29-29	7140-7143	the	
29-30	7144-7148	call	
29-31	7149-7162	significantly	
29-32	7163-7169	faster	
29-33	7169-7170	.	
29-34	7171-7174	But	
29-35	7175-7180	again	
29-36	7180-7181	,	
29-37	7182-7185	how	
29-38	7186-7190	fast	
29-39	7191-7193	is	
29-40	7194-7195	“	
29-41	7195-7199	fast	
29-42	7199-7200	”	
29-43	7200-7201	,	
29-44	7202-7204	if	
29-45	7205-7207	we	
29-46	7208-7213	might	
29-47	7214-7216	be	
29-48	7217-7224	calling	
29-49	7225-7229	this	
29-50	7230-7238	millions	
29-51	7239-7241	of	
29-52	7242-7247	times	
29-53	7247-7248	?	
29-54	7249-7254	Again	
29-55	7254-7255	,	
29-56	7256-7264	Postgres	
29-57	7265-7278	documentation	
29-58	7279-7284	comes	
29-59	7285-7287	to	

#Text=the rescue, as there’s a binary included in Postgres to precisely do this, pg_test_timing. Indeed, it has a documentation section explaining how to use it to measure the EXPLAIN ANALYZE overhead. On one of the systems used for the measurements above, it reports: Testing timing overhead for 3 seconds.
30-1	7288-7291	the	
30-2	7292-7298	rescue	
30-3	7298-7299	,	
30-4	7300-7302	as	
30-5	7303-7308	there	
30-6	7308-7309	’	
30-7	7309-7310	s	
30-8	7311-7312	a	
30-9	7313-7319	binary	
30-10	7320-7328	included	
30-11	7329-7331	in	
30-12	7332-7340	Postgres	
30-13	7341-7343	to	
30-14	7344-7353	precisely	
30-15	7354-7356	do	
30-16	7357-7361	this	
30-17	7361-7362	,	
30-18	7363-7377	pg_test_timing	
30-19	7377-7378	.	
30-20	7379-7385	Indeed	
30-21	7385-7386	,	
30-22	7387-7389	it	
30-23	7390-7393	has	
30-24	7394-7395	a	
30-25	7396-7409	documentation	
30-26	7410-7417	section	
30-27	7418-7428	explaining	
30-28	7429-7432	how	
30-29	7433-7435	to	
30-30	7436-7439	use	
30-31	7440-7442	it	
30-32	7443-7445	to	
30-33	7446-7453	measure	
30-34	7454-7457	the	
30-35	7458-7465	EXPLAIN	
30-36	7466-7473	ANALYZE	
30-37	7474-7482	overhead	
30-38	7482-7483	.	
30-39	7484-7486	On	
30-40	7487-7490	one	
30-41	7491-7493	of	
30-42	7494-7497	the	
30-43	7498-7505	systems	
30-44	7506-7510	used	
30-45	7511-7514	for	
30-46	7515-7518	the	
30-47	7519-7531	measurements	
30-48	7532-7537	above	
30-49	7537-7538	,	
30-50	7539-7541	it	
30-51	7542-7549	reports	
30-52	7549-7550	:	
30-53	7551-7558	Testing	
30-54	7559-7565	timing	
30-55	7566-7574	overhead	
30-56	7575-7578	for	
30-57	7579-7580	3	
30-58	7581-7588	seconds	
30-59	7588-7589	.	

#Text=Per loop time including overhead: 4620,82 ns Histogram of timing durations: < us % of total count 0,00000 0,00000 0,00000 99,85491 648295 0,01586 103
31-1	7590-7593	Per	
31-2	7594-7598	loop	
31-3	7599-7603	time	
31-4	7604-7613	including	
31-5	7614-7622	overhead	
31-6	7622-7623	:	
31-7	7624-7631	4620,82	
31-8	7632-7634	ns	
31-9	7635-7644	Histogram	
31-10	7645-7647	of	
31-11	7648-7654	timing	
31-12	7655-7664	durations	
31-13	7664-7665	:	
31-14	7666-7667	<	
31-15	7668-7670	us	
31-16	7671-7672	%	
31-17	7673-7675	of	
31-18	7676-7681	total	
31-19	7682-7687	count	
31-20	7688-7695	0,00000	
31-21	7696-7703	0,00000	
31-22	7704-7711	0,00000	
31-23	7712-7720	99,85491	
31-24	7721-7727	648295	
31-25	7728-7735	0,01586	
31-26	7736-7739	103	

#Text=0,12060 783 0,00863 Basically, the overhead is for most cases around 5 micro seconds. That time multiplied by millions means seconds or dozens of seconds of overhead. I recommend you to read Clock sources in Linux if you want to dive deeper into the topic.
32-1	7740-7747	0,12060	
32-2	7748-7751	783	
32-3	7752-7759	0,00863	
32-4	7760-7769	Basically	
32-5	7769-7770	,	
32-6	7771-7774	the	
32-7	7775-7783	overhead	
32-8	7784-7786	is	
32-9	7787-7790	for	
32-10	7791-7795	most	
32-11	7796-7801	cases	
32-12	7802-7808	around	
32-13	7809-7810	5	
32-14	7811-7816	micro	
32-15	7817-7824	seconds	
32-16	7824-7825	.	
32-17	7826-7830	That	
32-18	7831-7835	time	
32-19	7836-7846	multiplied	
32-20	7847-7849	by	
32-21	7850-7858	millions	
32-22	7859-7864	means	
32-23	7865-7872	seconds	
32-24	7873-7875	or	
32-25	7876-7882	dozens	
32-26	7883-7885	of	
32-27	7886-7893	seconds	
32-28	7894-7896	of	
32-29	7897-7905	overhead	
32-30	7905-7906	.	
32-31	7907-7908	I	
32-32	7909-7918	recommend	
32-33	7919-7922	you	
32-34	7923-7925	to	
32-35	7926-7930	read	
32-36	7931-7936	Clock	
32-37	7937-7944	sources	
32-38	7945-7947	in	
32-39	7948-7953	Linux	
32-40	7954-7956	if	
32-41	7957-7960	you	
32-42	7961-7965	want	
32-43	7966-7968	to	
32-44	7969-7973	dive	
32-45	7974-7980	deeper	
32-46	7981-7985	into	
32-47	7986-7989	the	
32-48	7990-7995	topic	
32-49	7995-7996	.	

#Text=The not-that-good news Let’s go back to our goal of using the execution timing information to see how we can optimize a query. If profiling overhead is substantial, but it is proportional to real execution time, it wouldn’t matter much –as all query
33-1	7997-8000	The	
33-2	8001-8014	not-that-good	
33-3	8015-8019	news	
33-4	8020-8023	Let	
33-5	8023-8024	’	
33-6	8024-8025	s	
33-7	8026-8028	go	
33-8	8029-8033	back	
33-9	8034-8036	to	
33-10	8037-8040	our	
33-11	8041-8045	goal	
33-12	8046-8048	of	
33-13	8049-8054	using	
33-14	8055-8058	the	
33-15	8059-8068	execution	
33-16	8069-8075	timing	
33-17	8076-8087	information	
33-18	8088-8090	to	
33-19	8091-8094	see	
33-20	8095-8098	how	
33-21	8099-8101	we	
33-22	8102-8105	can	
33-23	8106-8114	optimize	
33-24	8115-8116	a	
33-25	8117-8122	query	
33-26	8122-8123	.	
33-27	8124-8126	If	
33-28	8127-8136	profiling	
33-29	8137-8145	overhead	
33-30	8146-8148	is	
33-31	8149-8160	substantial	
33-32	8160-8161	,	
33-33	8162-8165	but	
33-34	8166-8168	it	
33-35	8169-8171	is	
33-36	8172-8184	proportional	
33-37	8185-8187	to	
33-38	8188-8192	real	
33-39	8193-8202	execution	
33-40	8203-8207	time	
33-41	8207-8208	,	
33-42	8209-8211	it	
33-43	8212-8218	wouldn	
33-44	8218-8219	’	
33-45	8219-8220	t	
33-46	8221-8227	matter	
33-47	8228-8232	much	
33-48	8233-8234	–	
33-49	8234-8236	as	
33-50	8237-8240	all	
33-51	8241-8246	query	

#Text=execution times would be scaled alike, and the slowest node would remain the slowest node. But the problem is that they aren’t: some nodes suffer significantly higher overhead, and may appear to be slower than others, while it’s not the case in reality. Unfortunately, this means that you cannot trust EXPLAIN ANALYZE to optimize your queries.
34-1	8247-8256	execution	
34-2	8257-8262	times	
34-3	8263-8268	would	
34-4	8269-8271	be	
34-5	8272-8278	scaled	
34-6	8279-8284	alike	
34-7	8284-8285	,	
34-8	8286-8289	and	
34-9	8290-8293	the	
34-10	8294-8301	slowest	
34-11	8302-8306	node	
34-12	8307-8312	would	
34-13	8313-8319	remain	
34-14	8320-8323	the	
34-15	8324-8331	slowest	
34-16	8332-8336	node	
34-17	8336-8337	.	
34-18	8338-8341	But	
34-19	8342-8345	the	
34-20	8346-8353	problem	
34-21	8354-8356	is	
34-22	8357-8361	that	
34-23	8362-8366	they	
34-24	8367-8371	aren	
34-25	8371-8372	’	
34-26	8372-8373	t	
34-27	8373-8374	:	
34-28	8375-8379	some	
34-29	8380-8385	nodes	
34-30	8386-8392	suffer	
34-31	8393-8406	significantly	
34-32	8407-8413	higher	
34-33	8414-8422	overhead	
34-34	8422-8423	,	
34-35	8424-8427	and	
34-36	8428-8431	may	
34-37	8432-8438	appear	
34-38	8439-8441	to	
34-39	8442-8444	be	
34-40	8445-8451	slower	
34-41	8452-8456	than	
34-42	8457-8463	others	
34-43	8463-8464	,	
34-44	8465-8470	while	
34-45	8471-8473	it	
34-46	8473-8474	’	
34-47	8474-8475	s	
34-48	8476-8479	not	
34-49	8480-8483	the	
34-50	8484-8488	case	
34-51	8489-8491	in	
34-52	8492-8499	reality	
34-53	8499-8500	.	
34-54	8501-8514	Unfortunately	
34-55	8514-8515	,	
34-56	8516-8520	this	
34-57	8521-8526	means	
34-58	8527-8531	that	
34-59	8532-8535	you	
34-60	8536-8542	cannot	
34-61	8543-8548	trust	
34-62	8549-8556	EXPLAIN	
34-63	8557-8564	ANALYZE	
34-64	8565-8567	to	
34-65	8568-8576	optimize	
34-66	8577-8581	your	
34-67	8582-8589	queries	
34-68	8589-8590	.	

#Text=It completely depends on the query and its execution nodes. We can use ltrace to count the number of times the clock_gettime is called: sudo ltrace -p $postgres_backend_pid -c -e clock_gettime query clock_gettime calls parallel
35-1	8591-8593	It	
35-2	8594-8604	completely	
35-3	8605-8612	depends	
35-4	8613-8615	on	
35-5	8616-8619	the	
35-6	8620-8625	query	
35-7	8626-8629	and	
35-8	8630-8633	its	
35-9	8634-8643	execution	
35-10	8644-8649	nodes	
35-11	8649-8650	.	
35-12	8651-8653	We	
35-13	8654-8657	can	
35-14	8658-8661	use	
35-15	8662-8668	ltrace	
35-16	8669-8671	to	
35-17	8672-8677	count	
35-18	8678-8681	the	
35-19	8682-8688	number	
35-20	8689-8691	of	
35-21	8692-8697	times	
35-22	8698-8701	the	
35-23	8702-8715	clock_gettime	
35-24	8716-8718	is	
35-25	8719-8725	called	
35-26	8725-8726	:	
35-27	8727-8731	sudo	
35-28	8732-8738	ltrace	
35-29	8739-8740	-	
35-30	8740-8741	p	
35-31	8742-8743	$	
35-32	8743-8763	postgres_backend_pid	
35-33	8764-8765	-	
35-34	8765-8766	c	
35-35	8767-8768	-	
35-36	8768-8769	e	
35-37	8770-8783	clock_gettime	
35-38	8784-8789	query	
35-39	8790-8803	clock_gettime	
35-40	8804-8809	calls	
35-41	8810-8818	parallel	

#Text=explain analyze select sum(i1.i * i2.i) from i1 inner join i2 using (i) 2004028 off select sum(i1.i * i2.i) from i1 inner join i2 using (i) off explain analyze select sum(i2.i) from i2 2016 off
36-1	8819-8826	explain	
36-2	8827-8834	analyze	
36-3	8835-8841	select	
36-4	8842-8845	sum	
36-5	8845-8846	(	
36-6	8846-8848	i1	
36-7	8848-8849	.	
36-8	8849-8850	i	
36-9	8851-8852	*	
36-10	8853-8855	i2	
36-11	8855-8856	.	
36-12	8856-8857	i	
36-13	8857-8858	)	
36-14	8859-8863	from	
36-15	8864-8866	i1	
36-16	8867-8872	inner	
36-17	8873-8877	join	
36-18	8878-8880	i2	
36-19	8881-8886	using	
36-20	8887-8888	(	
36-21	8888-8889	i	
36-22	8889-8890	)	
36-23	8891-8898	2004028	
36-24	8899-8902	off	
36-25	8903-8909	select	
36-26	8910-8913	sum	
36-27	8913-8914	(	
36-28	8914-8916	i1	
36-29	8916-8917	.	
36-30	8917-8918	i	
36-31	8919-8920	*	
36-32	8921-8923	i2	
36-33	8923-8924	.	
36-34	8924-8925	i	
36-35	8925-8926	)	
36-36	8927-8931	from	
36-37	8932-8934	i1	
36-38	8935-8940	inner	
36-39	8941-8945	join	
36-40	8946-8948	i2	
36-41	8949-8954	using	
36-42	8955-8956	(	
36-43	8956-8957	i	
36-44	8957-8958	)	
36-45	8959-8962	off	
36-46	8963-8970	explain	
36-47	8971-8978	analyze	
36-48	8979-8985	select	
36-49	8986-8989	sum	
36-50	8989-8990	(	
36-51	8990-8992	i2	
36-52	8992-8993	.	
36-53	8993-8994	i	
36-54	8994-8995	)	
36-55	8996-9000	from	
36-56	9001-9003	i2	
36-57	9004-9008	2016	
36-58	9009-9012	off	

#Text=explain analyze select sum(i1.i * i2.i) from i1 inner join i2 using (i) 38656 Here are some examples. For the join query, we can observe that the clock is called 2N+4M+K times, where N is the number of rows of i1, M the number of rows of i2 and K is a constant factor; 28 in this case, 16 in the case
37-1	9013-9020	explain	
37-2	9021-9028	analyze	
37-3	9029-9035	select	
37-4	9036-9039	sum	
37-5	9039-9040	(	
37-6	9040-9042	i1	
37-7	9042-9043	.	
37-8	9043-9044	i	
37-9	9045-9046	*	
37-10	9047-9049	i2	
37-11	9049-9050	.	
37-12	9050-9051	i	
37-13	9051-9052	)	
37-14	9053-9057	from	
37-15	9058-9060	i1	
37-16	9061-9066	inner	
37-17	9067-9071	join	
37-18	9072-9074	i2	
37-19	9075-9080	using	
37-20	9081-9082	(	
37-21	9082-9083	i	
37-22	9083-9084	)	
37-23	9085-9090	38656	
37-24	9091-9095	Here	
37-25	9096-9099	are	
37-26	9100-9104	some	
37-27	9105-9113	examples	
37-28	9113-9114	.	
37-29	9115-9118	For	
37-30	9119-9122	the	
37-31	9123-9127	join	
37-32	9128-9133	query	
37-33	9133-9134	,	
37-34	9135-9137	we	
37-35	9138-9141	can	
37-36	9142-9149	observe	
37-37	9150-9154	that	
37-38	9155-9158	the	
37-39	9159-9164	clock	
37-40	9165-9167	is	
37-41	9168-9174	called	
37-42	9175-9177	2N	
37-43	9177-9178	+	
37-44	9178-9180	4M	
37-45	9180-9181	+	
37-46	9181-9182	K	
37-47	9183-9188	times	
37-48	9188-9189	,	
37-49	9190-9195	where	
37-50	9196-9197	N	
37-51	9198-9200	is	
37-52	9201-9204	the	
37-53	9205-9211	number	
37-54	9212-9214	of	
37-55	9215-9219	rows	
37-56	9220-9222	of	
37-57	9223-9225	i1	
37-58	9225-9226	,	
37-59	9227-9228	M	
37-60	9229-9232	the	
37-61	9233-9239	number	
37-62	9240-9242	of	
37-63	9243-9247	rows	
37-64	9248-9250	of	
37-65	9251-9253	i2	
37-66	9254-9257	and	
37-67	9258-9259	K	
37-68	9260-9262	is	
37-69	9263-9264	a	
37-70	9265-9273	constant	
37-71	9274-9280	factor	
37-72	9280-9281	;	
37-73	9282-9284	28	
37-74	9285-9287	in	
37-75	9288-9292	this	
37-76	9293-9297	case	
37-77	9297-9298	,	
37-78	9299-9301	16	
37-79	9302-9304	in	
37-80	9305-9308	the	
37-81	9309-9313	case	

#Text=of the summing query (the third one). It is a very interesting the case when parallel mode is activated. Here the time is reported in blocks to some degree, significantly lowering the number of times the clock is called. The overhead EXPLAIN ANALYZE introduces is not proportional to the real
38-1	9314-9316	of	
38-2	9317-9320	the	
38-3	9321-9328	summing	
38-4	9329-9334	query	
38-5	9335-9336	(	
38-6	9336-9339	the	
38-7	9340-9345	third	
38-8	9346-9349	one	
38-9	9349-9350	)	
38-10	9350-9351	.	
38-11	9352-9354	It	
38-12	9355-9357	is	
38-13	9358-9359	a	
38-14	9360-9364	very	
38-15	9365-9376	interesting	
38-16	9377-9380	the	
38-17	9381-9385	case	
38-18	9386-9390	when	
38-19	9391-9399	parallel	
38-20	9400-9404	mode	
38-21	9405-9407	is	
38-22	9408-9417	activated	
38-23	9417-9418	.	
38-24	9419-9423	Here	
38-25	9424-9427	the	
38-26	9428-9432	time	
38-27	9433-9435	is	
38-28	9436-9444	reported	
38-29	9445-9447	in	
38-30	9448-9454	blocks	
38-31	9455-9457	to	
38-32	9458-9462	some	
38-33	9463-9469	degree	
38-34	9469-9470	,	
38-35	9471-9484	significantly	
38-36	9485-9493	lowering	
38-37	9494-9497	the	
38-38	9498-9504	number	
38-39	9505-9507	of	
38-40	9508-9513	times	
38-41	9514-9517	the	
38-42	9518-9523	clock	
38-43	9524-9526	is	
38-44	9527-9533	called	
38-45	9533-9534	.	
38-46	9535-9538	The	
38-47	9539-9547	overhead	
38-48	9548-9555	EXPLAIN	
38-49	9556-9563	ANALYZE	
38-50	9564-9574	introduces	
38-51	9575-9577	is	
38-52	9578-9581	not	
38-53	9582-9594	proportional	
38-54	9595-9597	to	
38-55	9598-9601	the	
38-56	9602-9606	real	

#Text=duration of the query plan, but rather proportional to the number of rows processed by the node. While they may be aligned, more rows processed does not always lead to higher execution times, and counting on this assumption may lead to believing a node is slower when it is in fact faster than another one. In turn leading to a bad query optimization strategy.
39-1	9607-9615	duration	
39-2	9616-9618	of	
39-3	9619-9622	the	
39-4	9623-9628	query	
39-5	9629-9633	plan	
39-6	9633-9634	,	
39-7	9635-9638	but	
39-8	9639-9645	rather	
39-9	9646-9658	proportional	
39-10	9659-9661	to	
39-11	9662-9665	the	
39-12	9666-9672	number	
39-13	9673-9675	of	
39-14	9676-9680	rows	
39-15	9681-9690	processed	
39-16	9691-9693	by	
39-17	9694-9697	the	
39-18	9698-9702	node	
39-19	9702-9703	.	
39-20	9704-9709	While	
39-21	9710-9714	they	
39-22	9715-9718	may	
39-23	9719-9721	be	
39-24	9722-9729	aligned	
39-25	9729-9730	,	
39-26	9731-9735	more	
39-27	9736-9740	rows	
39-28	9741-9750	processed	
39-29	9751-9755	does	
39-30	9756-9759	not	
39-31	9760-9766	always	
39-32	9767-9771	lead	
39-33	9772-9774	to	
39-34	9775-9781	higher	
39-35	9782-9791	execution	
39-36	9792-9797	times	
39-37	9797-9798	,	
39-38	9799-9802	and	
39-39	9803-9811	counting	
39-40	9812-9814	on	
39-41	9815-9819	this	
39-42	9820-9830	assumption	
39-43	9831-9834	may	
39-44	9835-9839	lead	
39-45	9840-9842	to	
39-46	9843-9852	believing	
39-47	9853-9854	a	
39-48	9855-9859	node	
39-49	9860-9862	is	
39-50	9863-9869	slower	
39-51	9870-9874	when	
39-52	9875-9877	it	
39-53	9878-9880	is	
39-54	9881-9883	in	
39-55	9884-9888	fact	
39-56	9889-9895	faster	
39-57	9896-9900	than	
39-58	9901-9908	another	
39-59	9909-9912	one	
39-60	9912-9913	.	
39-61	9914-9916	In	
39-62	9917-9921	turn	
39-63	9922-9929	leading	
39-64	9930-9932	to	
39-65	9933-9934	a	
39-66	9935-9938	bad	
39-67	9939-9944	query	
39-68	9945-9957	optimization	
39-69	9958-9966	strategy	
39-70	9966-9967	.	

#Text=I have worked deeper on the topic and tried the following: Take some queries and the number of calls to clock_gettime, as in the previous table, and measure the EXPLAIN ANALYZE execution times (without the additional overhead introduced by ltrace). Then solve the equation with
40-1	9968-9969	I	
40-2	9970-9974	have	
40-3	9975-9981	worked	
40-4	9982-9988	deeper	
40-5	9989-9991	on	
40-6	9992-9995	the	
40-7	9996-10001	topic	
40-8	10002-10005	and	
40-9	10006-10011	tried	
40-10	10012-10015	the	
40-11	10016-10025	following	
40-12	10025-10026	:	
40-13	10027-10031	Take	
40-14	10032-10036	some	
40-15	10037-10044	queries	
40-16	10045-10048	and	
40-17	10049-10052	the	
40-18	10053-10059	number	
40-19	10060-10062	of	
40-20	10063-10068	calls	
40-21	10069-10071	to	
40-22	10072-10085	clock_gettime	
40-23	10085-10086	,	
40-24	10087-10089	as	
40-25	10090-10092	in	
40-26	10093-10096	the	
40-27	10097-10105	previous	
40-28	10106-10111	table	
40-29	10111-10112	,	
40-30	10113-10116	and	
40-31	10117-10124	measure	
40-32	10125-10128	the	
40-33	10129-10136	EXPLAIN	
40-34	10137-10144	ANALYZE	
40-35	10145-10154	execution	
40-36	10155-10160	times	
40-37	10161-10162	(	
40-38	10162-10169	without	
40-39	10170-10173	the	
40-40	10174-10184	additional	
40-41	10185-10193	overhead	
40-42	10194-10204	introduced	
40-43	10205-10207	by	
40-44	10208-10214	ltrace	
40-45	10214-10215	)	
40-46	10215-10216	.	
40-47	10217-10221	Then	
40-48	10222-10227	solve	
40-49	10228-10231	the	
40-50	10232-10240	equation	
40-51	10241-10245	with	

#Text=the clock time as an unknown. However, the results vary significantly from query execution to query execution, and are not comparable. I have obtained results diverging up to one order of magnitude. Not even a linear regression helps here with such disparate results. Try measuring the clock_gettime overhead with the fastest and most advanced
41-1	10246-10249	the	
41-2	10250-10255	clock	
41-3	10256-10260	time	
41-4	10261-10263	as	
41-5	10264-10266	an	
41-6	10267-10274	unknown	
41-7	10274-10275	.	
41-8	10276-10283	However	
41-9	10283-10284	,	
41-10	10285-10288	the	
41-11	10289-10296	results	
41-12	10297-10301	vary	
41-13	10302-10315	significantly	
41-14	10316-10320	from	
41-15	10321-10326	query	
41-16	10327-10336	execution	
41-17	10337-10339	to	
41-18	10340-10345	query	
41-19	10346-10355	execution	
41-20	10355-10356	,	
41-21	10357-10360	and	
41-22	10361-10364	are	
41-23	10365-10368	not	
41-24	10369-10379	comparable	
41-25	10379-10380	.	
41-26	10381-10382	I	
41-27	10383-10387	have	
41-28	10388-10396	obtained	
41-29	10397-10404	results	
41-30	10405-10414	diverging	
41-31	10415-10417	up	
41-32	10418-10420	to	
41-33	10421-10424	one	
41-34	10425-10430	order	
41-35	10431-10433	of	
41-36	10434-10443	magnitude	
41-37	10443-10444	.	
41-38	10445-10448	Not	
41-39	10449-10453	even	
41-40	10454-10455	a	
41-41	10456-10462	linear	
41-42	10463-10473	regression	
41-43	10474-10479	helps	
41-44	10480-10484	here	
41-45	10485-10489	with	
41-46	10490-10494	such	
41-47	10495-10504	disparate	
41-48	10505-10512	results	
41-49	10512-10513	.	
41-50	10514-10517	Try	
41-51	10518-10527	measuring	
41-52	10528-10531	the	
41-53	10532-10545	clock_gettime	
41-54	10546-10554	overhead	
41-55	10555-10559	with	
41-56	10560-10563	the	
41-57	10564-10571	fastest	
41-58	10572-10575	and	
41-59	10576-10580	most	
41-60	10581-10589	advanced	

#Text=perf profiler available: eBPF. However, even then, BPF’s overhead is higher than that of the clock_gettime, making it uneffective. How to become a bit more truthful I guess it’s not easy. The fact that parallel mode appears to call the system
42-1	10590-10594	perf	
42-2	10595-10603	profiler	
42-3	10604-10613	available	
42-4	10613-10614	:	
42-5	10615-10619	eBPF	
42-6	10619-10620	.	
42-7	10621-10628	However	
42-8	10628-10629	,	
42-9	10630-10634	even	
42-10	10635-10639	then	
42-11	10639-10640	,	
42-12	10641-10644	BPF	
42-13	10644-10645	’	
42-14	10645-10646	s	
42-15	10647-10655	overhead	
42-16	10656-10658	is	
42-17	10659-10665	higher	
42-18	10666-10670	than	
42-19	10671-10675	that	
42-20	10676-10678	of	
42-21	10679-10682	the	
42-22	10683-10696	clock_gettime	
42-23	10696-10697	,	
42-24	10698-10704	making	
42-25	10705-10707	it	
42-26	10708-10719	uneffective	
42-27	10719-10720	.	
42-28	10721-10724	How	
42-29	10725-10727	to	
42-30	10728-10734	become	
42-31	10735-10736	a	
42-32	10737-10740	bit	
42-33	10741-10745	more	
42-34	10746-10754	truthful	
42-35	10755-10756	I	
42-36	10757-10762	guess	
42-37	10763-10765	it	
42-38	10765-10766	’	
42-39	10766-10767	s	
42-40	10768-10771	not	
42-41	10772-10776	easy	
42-42	10776-10777	.	
42-43	10778-10781	The	
42-44	10782-10786	fact	
42-45	10787-10791	that	
42-46	10792-10800	parallel	
42-47	10801-10805	mode	
42-48	10806-10813	appears	
42-49	10814-10816	to	
42-50	10817-10821	call	
42-51	10822-10825	the	
42-52	10826-10832	system	

#Text=time in blocks, at certain cases, could be a good way to move forward. Another alternative would be to provide a “correction mechanism”. If the clock time can be measured precisely, and the number of times the clock is called is known –Postgres certainly could keep track of it–, its countribution could be
43-1	10833-10837	time	
43-2	10838-10840	in	
43-3	10841-10847	blocks	
43-4	10847-10848	,	
43-5	10849-10851	at	
43-6	10852-10859	certain	
43-7	10860-10865	cases	
43-8	10865-10866	,	
43-9	10867-10872	could	
43-10	10873-10875	be	
43-11	10876-10877	a	
43-12	10878-10882	good	
43-13	10883-10886	way	
43-14	10887-10889	to	
43-15	10890-10894	move	
43-16	10895-10902	forward	
43-17	10902-10903	.	
43-18	10904-10911	Another	
43-19	10912-10923	alternative	
43-20	10924-10929	would	
43-21	10930-10932	be	
43-22	10933-10935	to	
43-23	10936-10943	provide	
43-24	10944-10945	a	
43-25	10946-10947	“	
43-26	10947-10957	correction	
43-27	10958-10967	mechanism	
43-28	10967-10968	”	
43-29	10968-10969	.	
43-30	10970-10972	If	
43-31	10973-10976	the	
43-32	10977-10982	clock	
43-33	10983-10987	time	
43-34	10988-10991	can	
43-35	10992-10994	be	
43-36	10995-11003	measured	
43-37	11004-11013	precisely	
43-38	11013-11014	,	
43-39	11015-11018	and	
43-40	11019-11022	the	
43-41	11023-11029	number	
43-42	11030-11032	of	
43-43	11033-11038	times	
43-44	11039-11042	the	
43-45	11043-11048	clock	
43-46	11049-11051	is	
43-47	11052-11058	called	
43-48	11059-11061	is	
43-49	11062-11067	known	
43-50	11068-11069	–	
43-51	11069-11077	Postgres	
43-52	11078-11087	certainly	
43-53	11088-11093	could	
43-54	11094-11098	keep	
43-55	11099-11104	track	
43-56	11105-11107	of	
43-57	11108-11110	it	
43-58	11110-11111	–	
43-59	11111-11112	,	
43-60	11113-11116	its	
43-61	11117-11130	countribution	
43-62	11131-11136	could	
43-63	11137-11139	be	

#Text=substracted from the total measured time. While probably not 100% exact, it would be much better than what it is as of today. Extra thoughts In reality, EXPLAIN ANALYZE is a query execution profiler. Being aware of this, we all know that profilers introduce more or less profiling overhead.
44-1	11140-11151	substracted	
44-2	11152-11156	from	
44-3	11157-11160	the	
44-4	11161-11166	total	
44-5	11167-11175	measured	
44-6	11176-11180	time	
44-7	11180-11181	.	
44-8	11182-11187	While	
44-9	11188-11196	probably	
44-10	11197-11200	not	
44-11	11201-11205	100%	
44-12	11206-11211	exact	
44-13	11211-11212	,	
44-14	11213-11215	it	
44-15	11216-11221	would	
44-16	11222-11224	be	
44-17	11225-11229	much	
44-18	11230-11236	better	
44-19	11237-11241	than	
44-20	11242-11246	what	
44-21	11247-11249	it	
44-22	11250-11252	is	
44-23	11253-11255	as	
44-24	11256-11258	of	
44-25	11259-11264	today	
44-26	11264-11265	.	
44-27	11266-11271	Extra	
44-28	11272-11280	thoughts	
44-29	11281-11283	In	
44-30	11284-11291	reality	
44-31	11291-11292	,	
44-32	11293-11300	EXPLAIN	
44-33	11301-11308	ANALYZE	
44-34	11309-11311	is	
44-35	11312-11313	a	
44-36	11314-11319	query	
44-37	11320-11329	execution	
44-38	11330-11338	profiler	
44-39	11338-11339	.	
44-40	11340-11345	Being	
44-41	11346-11351	aware	
44-42	11352-11354	of	
44-43	11355-11359	this	
44-44	11359-11360	,	
44-45	11361-11363	we	
44-46	11364-11367	all	
44-47	11368-11372	know	
44-48	11373-11377	that	
44-49	11378-11387	profilers	
44-50	11388-11397	introduce	
44-51	11398-11402	more	
44-52	11403-11405	or	
44-53	11406-11410	less	
44-54	11411-11420	profiling	
44-55	11421-11429	overhead	
44-56	11429-11430	.	

#Text=This is the key takeaway: EXPLAIN ANALYZE is a profiler, and its overhead ranges from high to very/extremely high on systems with slow virtualized clocks. Why EXPLAIN and EXPLAIN ANALYZE share the same “command”? They are, in reality, two very different things: the former gives you the query execution
45-1	11431-11435	This	
45-2	11436-11438	is	
45-3	11439-11442	the	
45-4	11443-11446	key	
45-5	11447-11455	takeaway	
45-6	11455-11456	:	
45-7	11457-11464	EXPLAIN	
45-8	11465-11472	ANALYZE	
45-9	11473-11475	is	
45-10	11476-11477	a	
45-11	11478-11486	profiler	
45-12	11486-11487	,	
45-13	11488-11491	and	
45-14	11492-11495	its	
45-15	11496-11504	overhead	
45-16	11505-11511	ranges	
45-17	11512-11516	from	
45-18	11517-11521	high	
45-19	11522-11524	to	
45-20	11525-11529	very	
45-21	11529-11530	/	
45-22	11530-11539	extremely	
45-23	11540-11544	high	
45-24	11545-11547	on	
45-25	11548-11555	systems	
45-26	11556-11560	with	
45-27	11561-11565	slow	
45-28	11566-11577	virtualized	
45-29	11578-11584	clocks	
45-30	11584-11585	.	
45-31	11586-11589	Why	
45-32	11590-11597	EXPLAIN	
45-33	11598-11601	and	
45-34	11602-11609	EXPLAIN	
45-35	11610-11617	ANALYZE	
45-36	11618-11623	share	
45-37	11624-11627	the	
45-38	11628-11632	same	
45-39	11633-11634	“	
45-40	11634-11641	command	
45-41	11641-11642	”	
45-42	11642-11643	?	
45-43	11644-11648	They	
45-44	11649-11652	are	
45-45	11652-11653	,	
45-46	11654-11656	in	
45-47	11657-11664	reality	
45-48	11664-11665	,	
45-49	11666-11669	two	
45-50	11670-11674	very	
45-51	11675-11684	different	
45-52	11685-11691	things	
45-53	11691-11692	:	
45-54	11693-11696	the	
45-55	11697-11703	former	
45-56	11704-11709	gives	
45-57	11710-11713	you	
45-58	11714-11717	the	
45-59	11718-11723	query	
45-60	11724-11733	execution	

#Text=plan; the latter profiles the query. While the output is similar –but only that, similar– they do very different things. I’d rename the latter to PROFILE SELECT.... Pretty much the same story with VACUUM and VACUUM FULL. The latter should
46-1	11734-11738	plan	
46-2	11738-11739	;	
46-3	11740-11743	the	
46-4	11744-11750	latter	
46-5	11751-11759	profiles	
46-6	11760-11763	the	
46-7	11764-11769	query	
46-8	11769-11770	.	
46-9	11771-11776	While	
46-10	11777-11780	the	
46-11	11781-11787	output	
46-12	11788-11790	is	
46-13	11791-11798	similar	
46-14	11799-11800	–	
46-15	11800-11803	but	
46-16	11804-11808	only	
46-17	11809-11813	that	
46-18	11813-11814	,	
46-19	11815-11822	similar	
46-20	11822-11823	–	
46-21	11824-11828	they	
46-22	11829-11831	do	
46-23	11832-11836	very	
46-24	11837-11846	different	
46-25	11847-11853	things	
46-26	11853-11854	.	
46-27	11855-11856	I	
46-28	11856-11857	’	
46-29	11857-11858	d	
46-30	11859-11865	rename	
46-31	11866-11869	the	
46-32	11870-11876	latter	
46-33	11877-11879	to	
46-34	11880-11887	PROFILE	
46-35	11888-11894	SELECT	
46-36	11894-11895	.	
46-37	11895-11896	.	
46-38	11896-11897	.	
46-39	11897-11898	.	
46-40	11899-11905	Pretty	
46-41	11906-11910	much	
46-42	11911-11914	the	
46-43	11915-11919	same	
46-44	11920-11925	story	
46-45	11926-11930	with	
46-46	11931-11937	VACUUM	
46-47	11938-11941	and	
46-48	11942-11948	VACUUM	
46-49	11949-11953	FULL	
46-50	11953-11954	.	
46-51	11955-11958	The	
46-52	11959-11965	latter	
46-53	11966-11972	should	

#Text=be renamed to DEFRAG or REWRITE TABLE –or VACUUM FULL YES I REALLY KNOW WHAT I AM DOING PLEASE DO LOCK MY TABLE, for that matter. Comments Please enable JavaScript to view the comments powered by Disqus. comments powered by Disqus More Posts You may also likethis related content Boost your User-Defined Functions in PostgreSQL
47-1	11973-11975	be	
47-2	11976-11983	renamed	
47-3	11984-11986	to	
47-4	11987-11993	DEFRAG	
47-5	11994-11996	or	
47-6	11997-12004	REWRITE	
47-7	12005-12010	TABLE	
47-8	12011-12012	–	
47-9	12012-12014	or	
47-10	12015-12021	VACUUM	
47-11	12022-12026	FULL	
47-12	12027-12030	YES	
47-13	12031-12032	I	
47-14	12033-12039	REALLY	
47-15	12040-12044	KNOW	
47-16	12045-12049	WHAT	
47-17	12050-12051	I	
47-18	12052-12054	AM	
47-19	12055-12060	DOING	
47-20	12061-12067	PLEASE	
47-21	12068-12070	DO	
47-22	12071-12075	LOCK	
47-23	12076-12078	MY	
47-24	12079-12084	TABLE	
47-25	12084-12085	,	
47-26	12086-12089	for	
47-27	12090-12094	that	
47-28	12095-12101	matter	
47-29	12101-12102	.	
47-30	12103-12111	Comments	
47-31	12112-12118	Please	
47-32	12119-12125	enable	
47-33	12126-12136	JavaScript	
47-34	12137-12139	to	
47-35	12140-12144	view	
47-36	12145-12148	the	
47-37	12149-12157	comments	
47-38	12158-12165	powered	
47-39	12166-12168	by	
47-40	12169-12175	Disqus	
47-41	12175-12176	.	
47-42	12177-12185	comments	
47-43	12186-12193	powered	
47-44	12194-12196	by	
47-45	12197-12203	Disqus	
47-46	12204-12208	More	
47-47	12209-12214	Posts	
47-48	12215-12218	You	
47-49	12219-12222	may	
47-50	12223-12227	also	
47-51	12228-12236	likethis	
47-52	12237-12244	related	
47-53	12245-12252	content	
47-54	12253-12258	Boost	
47-55	12259-12263	your	
47-56	12264-12276	User-Defined	
47-57	12277-12286	Functions	
47-58	12287-12289	in	
47-59	12290-12300	PostgreSQL	

#Text=Emanuel Calvo Anthony Sotolongo Feb 5, 2021 · 9 min read Introduction Using the RDBMS only to store data is restricting the full potential of the database systems, which were designed for server-side processing and provide other options besides being a data container. Read post
48-1	12301-12308	Emanuel	
48-2	12309-12314	Calvo	
48-3	12315-12322	Anthony	
48-4	12323-12332	Sotolongo	
48-5	12333-12336	Feb	
48-6	12337-12338	5	
48-7	12338-12339	,	
48-8	12340-12344	2021	
48-9	12345-12346	·	
48-10	12347-12348	9	
48-11	12349-12352	min	
48-12	12353-12357	read	
48-13	12358-12370	Introduction	
48-14	12371-12376	Using	
48-15	12377-12380	the	
48-16	12381-12386	RDBMS	
48-17	12387-12391	only	
48-18	12392-12394	to	
48-19	12395-12400	store	
48-20	12401-12405	data	
48-21	12406-12408	is	
48-22	12409-12420	restricting	
48-23	12421-12424	the	
48-24	12425-12429	full	
48-25	12430-12439	potential	
48-26	12440-12442	of	
48-27	12443-12446	the	
48-28	12447-12455	database	
48-29	12456-12463	systems	
48-30	12463-12464	,	
48-31	12465-12470	which	
48-32	12471-12475	were	
48-33	12476-12484	designed	
48-34	12485-12488	for	
48-35	12489-12500	server-side	
48-36	12501-12511	processing	
48-37	12512-12515	and	
48-38	12516-12523	provide	
48-39	12524-12529	other	
48-40	12530-12537	options	
48-41	12538-12545	besides	
48-42	12546-12551	being	
48-43	12552-12553	a	
48-44	12554-12558	data	
48-45	12559-12568	container	
48-46	12568-12569	.	
48-47	12570-12574	Read	
48-48	12575-12579	post	

#Text=63-Node EKS Cluster running on a Single Instance with Firecracker Álvaro Hernández Jan 13, 2021 · 7 min read 63-Node EKS Cluster running on a Single Instance with Firecracker This blog post is a part of a series of posts devoted to Firecracker automation. Currently it consists of the following posts:
49-1	12580-12582	63	
49-2	12582-12583	-	
49-3	12583-12587	Node	
49-4	12588-12591	EKS	
49-5	12592-12599	Cluster	
49-6	12600-12607	running	
49-7	12608-12610	on	
49-8	12611-12612	a	
49-9	12613-12619	Single	
49-10	12620-12628	Instance	
49-11	12629-12633	with	
49-12	12634-12645	Firecracker	
49-13	12646-12652	Álvaro	
49-14	12653-12662	Hernández	
49-15	12663-12666	Jan	
49-16	12667-12669	13	
49-17	12669-12670	,	
49-18	12671-12675	2021	
49-19	12676-12677	·	
49-20	12678-12679	7	
49-21	12680-12683	min	
49-22	12684-12688	read	
49-23	12689-12691	63	
49-24	12691-12692	-	
49-25	12692-12696	Node	
49-26	12697-12700	EKS	
49-27	12701-12708	Cluster	
49-28	12709-12716	running	
49-29	12717-12719	on	
49-30	12720-12721	a	
49-31	12722-12728	Single	
49-32	12729-12737	Instance	
49-33	12738-12742	with	
49-34	12743-12754	Firecracker	
49-35	12755-12759	This	
49-36	12760-12764	blog	
49-37	12765-12769	post	
49-38	12770-12772	is	
49-39	12773-12774	a	
49-40	12775-12779	part	
49-41	12780-12782	of	
49-42	12783-12784	a	
49-43	12785-12791	series	
49-44	12792-12794	of	
49-45	12795-12800	posts	
49-46	12801-12808	devoted	
49-47	12809-12811	to	
49-48	12812-12823	Firecracker	
49-49	12824-12834	automation	
49-50	12834-12835	.	
49-51	12836-12845	Currently	
49-52	12846-12848	it	
49-53	12849-12857	consists	
49-54	12858-12860	of	
49-55	12861-12864	the	
49-56	12865-12874	following	
49-57	12875-12880	posts	
49-58	12880-12881	:	

#Text=Read post Repository, Tuning Guide and API for your postgresql.conf Álvaro Hernández Dec 18, 2020 · 3 min read
50-1	12882-12886	Read	
50-2	12887-12891	post	
50-3	12892-12902	Repository	
50-4	12902-12903	,	
50-5	12904-12910	Tuning	
50-6	12911-12916	Guide	
50-7	12917-12920	and	
50-8	12921-12924	API	
50-9	12925-12928	for	
50-10	12929-12933	your	
50-11	12934-12949	postgresql.conf	
50-12	12950-12956	Álvaro	
50-13	12957-12966	Hernández	
50-14	12967-12970	Dec	
50-15	12971-12973	18	
50-16	12973-12974	,	
50-17	12975-12979	2020	
50-18	12980-12981	·	
50-19	12982-12983	3	
50-20	12984-12987	min	
50-21	12988-12992	read	

#Text=Repository, Tuning Guide and API for your postgresql.conf postgresqlco.nf (aka postgresqlCO.NF, or simply &ldquo;CONF&rdquo;) was born a little bit more than two years ago. CONF&rsquo;s main goal was to help Postgres users find more and easier help to understand and tune their postgresql. Read post Free 1GB Postgres Database on AWS CloudShell Álvaro Hernández Dec 17, 2020 · 5 min read
51-1	12993-13003	Repository	
51-2	13003-13004	,	
51-3	13005-13011	Tuning	
51-4	13012-13017	Guide	
51-5	13018-13021	and	
51-6	13022-13025	API	
51-7	13026-13029	for	
51-8	13030-13034	your	
51-9	13035-13050	postgresql.conf	
51-10	13051-13066	postgresqlco.nf	
51-11	13067-13068	(	
51-12	13068-13071	aka	
51-13	13072-13087	postgresqlCO.NF	
51-14	13087-13088	,	
51-15	13089-13091	or	
51-16	13092-13098	simply	
51-17	13099-13100	&	
51-18	13100-13105	ldquo	
51-19	13105-13106	;	
51-20	13106-13110	CONF	
51-21	13110-13111	&	
51-22	13111-13116	rdquo	
51-23	13116-13117	;	
51-24	13117-13118	)	
51-25	13119-13122	was	
51-26	13123-13127	born	
51-27	13128-13129	a	
51-28	13130-13136	little	
51-29	13137-13140	bit	
51-30	13141-13145	more	
51-31	13146-13150	than	
51-32	13151-13154	two	
51-33	13155-13160	years	
51-34	13161-13164	ago	
51-35	13164-13165	.	
51-36	13166-13170	CONF	
51-37	13170-13171	&	
51-38	13171-13176	rsquo	
51-39	13176-13177	;	
51-40	13177-13178	s	
51-41	13179-13183	main	
51-42	13184-13188	goal	
51-43	13189-13192	was	
51-44	13193-13195	to	
51-45	13196-13200	help	
51-46	13201-13209	Postgres	
51-47	13210-13215	users	
51-48	13216-13220	find	
51-49	13221-13225	more	
51-50	13226-13229	and	
51-51	13230-13236	easier	
51-52	13237-13241	help	
51-53	13242-13244	to	
51-54	13245-13255	understand	
51-55	13256-13259	and	
51-56	13260-13264	tune	
51-57	13265-13270	their	
51-58	13271-13281	postgresql	
51-59	13281-13282	.	
51-60	13283-13287	Read	
51-61	13288-13292	post	
51-62	13293-13297	Free	
51-63	13298-13301	1GB	
51-64	13302-13310	Postgres	
51-65	13311-13319	Database	
51-66	13320-13322	on	
51-67	13323-13326	AWS	
51-68	13327-13337	CloudShell	
51-69	13338-13344	Álvaro	
51-70	13345-13354	Hernández	
51-71	13355-13358	Dec	
51-72	13359-13361	17	
51-73	13361-13362	,	
51-74	13363-13367	2020	
51-75	13368-13369	·	
51-76	13370-13371	5	
51-77	13372-13375	min	
51-78	13376-13380	read	

#Text=Free 1GB Postgres Database on AWS CloudShell TL;DR AWS CloudShell is a CLI embedded in the AWS Web Console. It is meant to make it easier to run the AWS CLI, SDK and other scripts from your web browser, without having to install anything locally or having to deal with local credential and profiles management. Read post About OnGres We like open source, we develop open source software, and we are very active and well known at Postgres community. We build very innovative projects in Postgres ecosystem and are the founders of Fundación PostgreSQL. Contact us
52-1	13381-13385	Free	
52-2	13386-13389	1GB	
52-3	13390-13398	Postgres	
52-4	13399-13407	Database	
52-5	13408-13410	on	
52-6	13411-13414	AWS	
52-7	13415-13425	CloudShell	
52-8	13426-13428	TL	
52-9	13428-13429	;	
52-10	13429-13431	DR	
52-11	13432-13435	AWS	
52-12	13436-13446	CloudShell	
52-13	13447-13449	is	
52-14	13450-13451	a	
52-15	13452-13455	CLI	
52-16	13456-13464	embedded	
52-17	13465-13467	in	
52-18	13468-13471	the	
52-19	13472-13475	AWS	
52-20	13476-13479	Web	
52-21	13480-13487	Console	
52-22	13487-13488	.	
52-23	13489-13491	It	
52-24	13492-13494	is	
52-25	13495-13500	meant	
52-26	13501-13503	to	
52-27	13504-13508	make	
52-28	13509-13511	it	
52-29	13512-13518	easier	
52-30	13519-13521	to	
52-31	13522-13525	run	
52-32	13526-13529	the	
52-33	13530-13533	AWS	
52-34	13534-13537	CLI	
52-35	13537-13538	,	
52-36	13539-13542	SDK	
52-37	13543-13546	and	
52-38	13547-13552	other	
52-39	13553-13560	scripts	
52-40	13561-13565	from	
52-41	13566-13570	your	
52-42	13571-13574	web	
52-43	13575-13582	browser	
52-44	13582-13583	,	
52-45	13584-13591	without	
52-46	13592-13598	having	
52-47	13599-13601	to	
52-48	13602-13609	install	
52-49	13610-13618	anything	
52-50	13619-13626	locally	
52-51	13627-13629	or	
52-52	13630-13636	having	
52-53	13637-13639	to	
52-54	13640-13644	deal	
52-55	13645-13649	with	
52-56	13650-13655	local	
52-57	13656-13666	credential	
52-58	13667-13670	and	
52-59	13671-13679	profiles	
52-60	13680-13690	management	
52-61	13690-13691	.	
52-62	13692-13696	Read	
52-63	13697-13701	post	
52-64	13702-13707	About	
52-65	13708-13714	OnGres	
52-66	13715-13717	We	
52-67	13718-13722	like	
52-68	13723-13727	open	
52-69	13728-13734	source	
52-70	13734-13735	,	
52-71	13736-13738	we	
52-72	13739-13746	develop	
52-73	13747-13751	open	
52-74	13752-13758	source	
52-75	13759-13767	software	
52-76	13767-13768	,	
52-77	13769-13772	and	
52-78	13773-13775	we	
52-79	13776-13779	are	
52-80	13780-13784	very	
52-81	13785-13791	active	
52-82	13792-13795	and	
52-83	13796-13800	well	
52-84	13801-13806	known	
52-85	13807-13809	at	
52-86	13810-13818	Postgres	
52-87	13819-13828	community	
52-88	13828-13829	.	
52-89	13830-13832	We	
52-90	13833-13838	build	
52-91	13839-13843	very	
52-92	13844-13854	innovative	
52-93	13855-13863	projects	
52-94	13864-13866	in	
52-95	13867-13875	Postgres	
52-96	13876-13885	ecosystem	
52-97	13886-13889	and	
52-98	13890-13893	are	
52-99	13894-13897	the	
52-100	13898-13906	founders	
52-101	13907-13909	of	
52-102	13910-13919	Fundación	
52-103	13920-13930	PostgreSQL	
52-104	13930-13931	.	
52-105	13932-13939	Contact	
52-106	13940-13942	us	

#Text=We are currently working on more awesome stuff Subscribe to our newsletter to be up to date! -None- Newsletter Contact Form Careers StackGres I accept the OnGres Privacy Policy and agree to receive news and promotions every now and then Resources
53-1	13943-13945	We	
53-2	13946-13949	are	
53-3	13950-13959	currently	
53-4	13960-13967	working	
53-5	13968-13970	on	
53-6	13971-13975	more	
53-7	13976-13983	awesome	
53-8	13984-13989	stuff	
53-9	13990-13999	Subscribe	
53-10	14000-14002	to	
53-11	14003-14006	our	
53-12	14007-14017	newsletter	
53-13	14018-14020	to	
53-14	14021-14023	be	
53-15	14024-14026	up	
53-16	14027-14029	to	
53-17	14030-14034	date	
53-18	14034-14035	!	
53-19	14036-14037	-	
53-20	14037-14041	None	
53-21	14041-14042	-	
53-22	14043-14053	Newsletter	
53-23	14054-14061	Contact	
53-24	14062-14066	Form	
53-25	14067-14074	Careers	
53-26	14075-14084	StackGres	
53-27	14085-14086	I	
53-28	14087-14093	accept	
53-29	14094-14097	the	
53-30	14098-14104	OnGres	
53-31	14105-14112	Privacy	
53-32	14113-14119	Policy	
53-33	14120-14123	and	
53-34	14124-14129	agree	
53-35	14130-14132	to	
53-36	14133-14140	receive	
53-37	14141-14145	news	
53-38	14146-14149	and	
53-39	14150-14160	promotions	
53-40	14161-14166	every	
53-41	14167-14170	now	
53-42	14171-14174	and	
53-43	14175-14179	then	
53-44	14180-14189	Resources	

#Text=Blog Services Professional Services Consulting Training Products StackGres PostgreSQLCO.NF Company Team Careers Contact //Language English © 2021 OnGres Inc.
54-1	14190-14194	Blog	
54-2	14195-14203	Services	
54-3	14204-14216	Professional	
54-4	14217-14225	Services	
54-5	14226-14236	Consulting	
54-6	14237-14245	Training	
54-7	14246-14254	Products	
54-8	14255-14264	StackGres	
54-9	14265-14280	PostgreSQLCO.NF	
54-10	14281-14288	Company	
54-11	14289-14293	Team	
54-12	14294-14301	Careers	
54-13	14302-14309	Contact	
54-14	14310-14311	/	
54-15	14311-14312	/	
54-16	14312-14320	Language	
54-17	14321-14328	English	
54-18	14329-14330	©	
54-19	14331-14335	2021	
54-20	14336-14342	OnGres	
54-21	14343-14346	Inc	
54-22	14346-14347	.	
