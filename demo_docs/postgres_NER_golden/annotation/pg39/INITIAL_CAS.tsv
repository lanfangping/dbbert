#FORMAT=WebAnno TSV 3.3


#Text=Performance Tuning in Athena - Amazon Athena Performance Tuning in Athena - Amazon Athena AWSDocumentationAmazon AthenaUser Guide Physical LimitsQuery Optimization TechniquesAdditional Resources Performance Tuning in Athena
1-1	0-11	Performance	
1-2	12-18	Tuning	
1-3	19-21	in	
1-4	22-28	Athena	
1-5	29-30	-	
1-6	31-37	Amazon	
1-7	38-44	Athena	
1-8	45-56	Performance	
1-9	57-63	Tuning	
1-10	64-66	in	
1-11	67-73	Athena	
1-12	74-75	-	
1-13	76-82	Amazon	
1-14	83-89	Athena	
1-15	90-112	AWSDocumentationAmazon	
1-16	113-123	AthenaUser	
1-17	124-129	Guide	
1-18	130-138	Physical	
1-19	139-150	LimitsQuery	
1-20	151-163	Optimization	
1-21	164-184	TechniquesAdditional	
1-22	185-194	Resources	
1-23	195-206	Performance	
1-24	207-213	Tuning	
1-25	214-216	in	
1-26	217-223	Athena	

#Text=This topic provides general information and specific suggestions for improving the performance of Athena when you have large amounts of data and experience memory usage performance issues. Physical Limits In general, Athena limits the runtime of each query to 30 minutes. Queries that run beyond this limit are automatically cancelled without charge. If a query runs out
2-1	224-228	This	
2-2	229-234	topic	
2-3	235-243	provides	
2-4	244-251	general	
2-5	252-263	information	
2-6	264-267	and	
2-7	268-276	specific	
2-8	277-288	suggestions	
2-9	289-292	for	
2-10	293-302	improving	
2-11	303-306	the	
2-12	307-318	performance	
2-13	319-321	of	
2-14	322-328	Athena	
2-15	329-333	when	
2-16	334-337	you	
2-17	338-342	have	
2-18	343-348	large	
2-19	349-356	amounts	
2-20	357-359	of	
2-21	360-364	data	
2-22	365-368	and	
2-23	369-379	experience	
2-24	380-386	memory	
2-25	387-392	usage	
2-26	393-404	performance	
2-27	405-411	issues	
2-28	411-412	.	
2-29	413-421	Physical	
2-30	422-428	Limits	
2-31	429-431	In	
2-32	432-439	general	
2-33	439-440	,	
2-34	441-447	Athena	
2-35	448-454	limits	
2-36	455-458	the	
2-37	459-466	runtime	
2-38	467-469	of	
2-39	470-474	each	
2-40	475-480	query	
2-41	481-483	to	
2-42	484-486	30	
2-43	487-494	minutes	
2-44	494-495	.	
2-45	496-503	Queries	
2-46	504-508	that	
2-47	509-512	run	
2-48	513-519	beyond	
2-49	520-524	this	
2-50	525-530	limit	
2-51	531-534	are	
2-52	535-548	automatically	
2-53	549-558	cancelled	
2-54	559-566	without	
2-55	567-573	charge	
2-56	573-574	.	
2-57	575-577	If	
2-58	578-579	a	
2-59	580-585	query	
2-60	586-590	runs	
2-61	591-594	out	

#Text=memory or a node crashes during processing, errors like the following can occur: INTERNAL_ERROR_QUERY_ENGINE EXCEEDED_MEMORY_LIMIT: Query exceeded local memory limit Query exhausted resources at this scale factor
3-1	595-601	memory	
3-2	602-604	or	
3-3	605-606	a	
3-4	607-611	node	
3-5	612-619	crashes	
3-6	620-626	during	
3-7	627-637	processing	
3-8	637-638	,	
3-9	639-645	errors	
3-10	646-650	like	
3-11	651-654	the	
3-12	655-664	following	
3-13	665-668	can	
3-14	669-674	occur	
3-15	674-675	:	
3-16	676-703	INTERNAL_ERROR_QUERY_ENGINE	
3-17	704-725	EXCEEDED_MEMORY_LIMIT	
3-18	725-726	:	
3-19	727-732	Query	
3-20	733-741	exceeded	
3-21	742-747	local	
3-22	748-754	memory	
3-23	755-760	limit	
3-24	761-766	Query	
3-25	767-776	exhausted	
3-26	777-786	resources	
3-27	787-789	at	
3-28	790-794	this	
3-29	795-800	scale	
3-30	801-807	factor	

#Text=Encountered too many errors talking to a worker node. The node may have crashed or be under too much load. Query Optimization Techniques For queries that require resources beyond existing limits, you can either optimize the query or restructure the data being queried. To optimize your queries, consider the suggestions in this section.
4-1	808-819	Encountered	
4-2	820-823	too	
4-3	824-828	many	
4-4	829-835	errors	
4-5	836-843	talking	
4-6	844-846	to	
4-7	847-848	a	
4-8	849-855	worker	
4-9	856-860	node	
4-10	860-861	.	
4-11	862-865	The	
4-12	866-870	node	
4-13	871-874	may	
4-14	875-879	have	
4-15	880-887	crashed	
4-16	888-890	or	
4-17	891-893	be	
4-18	894-899	under	
4-19	900-903	too	
4-20	904-908	much	
4-21	909-913	load	
4-22	913-914	.	
4-23	915-920	Query	
4-24	921-933	Optimization	
4-25	934-944	Techniques	
4-26	945-948	For	
4-27	949-956	queries	
4-28	957-961	that	
4-29	962-969	require	
4-30	970-979	resources	
4-31	980-986	beyond	
4-32	987-995	existing	
4-33	996-1002	limits	
4-34	1002-1003	,	
4-35	1004-1007	you	
4-36	1008-1011	can	
4-37	1012-1018	either	
4-38	1019-1027	optimize	
4-39	1028-1031	the	
4-40	1032-1037	query	
4-41	1038-1040	or	
4-42	1041-1052	restructure	
4-43	1053-1056	the	
4-44	1057-1061	data	
4-45	1062-1067	being	
4-46	1068-1075	queried	
4-47	1075-1076	.	
4-48	1077-1079	To	
4-49	1080-1088	optimize	
4-50	1089-1093	your	
4-51	1094-1101	queries	
4-52	1101-1102	,	
4-53	1103-1111	consider	
4-54	1112-1115	the	
4-55	1116-1127	suggestions	
4-56	1128-1130	in	
4-57	1131-1135	this	
4-58	1136-1143	section	
4-59	1143-1144	.	

#Text=Data Size File Formats Joins, Grouping, and Unions Partitioning Window Functions Use More Efficient Functions Data Size Avoid single large files – Single files are
5-1	1145-1149	Data	
5-2	1150-1154	Size	
5-3	1155-1159	File	
5-4	1160-1167	Formats	
5-5	1168-1173	Joins	
5-6	1173-1174	,	
5-7	1175-1183	Grouping	
5-8	1183-1184	,	
5-9	1185-1188	and	
5-10	1189-1195	Unions	
5-11	1196-1208	Partitioning	
5-12	1209-1215	Window	
5-13	1216-1225	Functions	
5-14	1226-1229	Use	
5-15	1230-1234	More	
5-16	1235-1244	Efficient	
5-17	1245-1254	Functions	
5-18	1255-1259	Data	
5-19	1260-1264	Size	
5-20	1265-1270	Avoid	
5-21	1271-1277	single	
5-22	1278-1283	large	
5-23	1284-1289	files	
5-24	1290-1291	–	
5-25	1292-1298	Single	
5-26	1299-1304	files	
5-27	1305-1308	are	

#Text=loaded into a single node for processing. If your file size is extremely large, try to break up the file into smaller files and use partitions to organize them. Read a smaller amount of data at once – Scanning a large amount of data at one time can slow down the query and increase cost. Use partitions or filters to limit the files to be scanned.
6-1	1309-1315	loaded	
6-2	1316-1320	into	
6-3	1321-1322	a	
6-4	1323-1329	single	
6-5	1330-1334	node	
6-6	1335-1338	for	
6-7	1339-1349	processing	
6-8	1349-1350	.	
6-9	1351-1353	If	
6-10	1354-1358	your	
6-11	1359-1363	file	
6-12	1364-1368	size	
6-13	1369-1371	is	
6-14	1372-1381	extremely	
6-15	1382-1387	large	
6-16	1387-1388	,	
6-17	1389-1392	try	
6-18	1393-1395	to	
6-19	1396-1401	break	
6-20	1402-1404	up	
6-21	1405-1408	the	
6-22	1409-1413	file	
6-23	1414-1418	into	
6-24	1419-1426	smaller	
6-25	1427-1432	files	
6-26	1433-1436	and	
6-27	1437-1440	use	
6-28	1441-1451	partitions	
6-29	1452-1454	to	
6-30	1455-1463	organize	
6-31	1464-1468	them	
6-32	1468-1469	.	
6-33	1470-1474	Read	
6-34	1475-1476	a	
6-35	1477-1484	smaller	
6-36	1485-1491	amount	
6-37	1492-1494	of	
6-38	1495-1499	data	
6-39	1500-1502	at	
6-40	1503-1507	once	
6-41	1508-1509	–	
6-42	1510-1518	Scanning	
6-43	1519-1520	a	
6-44	1521-1526	large	
6-45	1527-1533	amount	
6-46	1534-1536	of	
6-47	1537-1541	data	
6-48	1542-1544	at	
6-49	1545-1548	one	
6-50	1549-1553	time	
6-51	1554-1557	can	
6-52	1558-1562	slow	
6-53	1563-1567	down	
6-54	1568-1571	the	
6-55	1572-1577	query	
6-56	1578-1581	and	
6-57	1582-1590	increase	
6-58	1591-1595	cost	
6-59	1595-1596	.	
6-60	1597-1600	Use	
6-61	1601-1611	partitions	
6-62	1612-1614	or	
6-63	1615-1622	filters	
6-64	1623-1625	to	
6-65	1626-1631	limit	
6-66	1632-1635	the	
6-67	1636-1641	files	
6-68	1642-1644	to	
6-69	1645-1647	be	
6-70	1648-1655	scanned	
6-71	1655-1656	.	

#Text=Avoid having too many columns – The message GENERIC_INTERNAL_ERROR: io.airlift.bytecode.CompilationException can occur when Athena fails to compile the query to bytecode. This exception is usually caused by having too
7-1	1657-1662	Avoid	
7-2	1663-1669	having	
7-3	1670-1673	too	
7-4	1674-1678	many	
7-5	1679-1686	columns	
7-6	1687-1688	–	
7-7	1689-1692	The	
7-8	1693-1700	message	
7-9	1701-1723	GENERIC_INTERNAL_ERROR	
7-10	1723-1724	:	
7-11	1725-1765	io.airlift.bytecode.CompilationException	
7-12	1766-1769	can	
7-13	1770-1775	occur	
7-14	1776-1780	when	
7-15	1781-1787	Athena	
7-16	1788-1793	fails	
7-17	1794-1796	to	
7-18	1797-1804	compile	
7-19	1805-1808	the	
7-20	1809-1814	query	
7-21	1815-1817	to	
7-22	1818-1826	bytecode	
7-23	1826-1827	.	
7-24	1828-1832	This	
7-25	1833-1842	exception	
7-26	1843-1845	is	
7-27	1846-1853	usually	
7-28	1854-1860	caused	
7-29	1861-1863	by	
7-30	1864-1870	having	
7-31	1871-1874	too	

#Text=many columns in the query. Reduce the number of the columns in the query or create subqueries and use a JOIN that retrieves a smaller amount of data. Avoid large query outputs – Because query results are written to Amazon S3 by a single Athena node, a large amount of output data
8-1	1875-1879	many	
8-2	1880-1887	columns	
8-3	1888-1890	in	
8-4	1891-1894	the	
8-5	1895-1900	query	
8-6	1900-1901	.	
8-7	1902-1908	Reduce	
8-8	1909-1912	the	
8-9	1913-1919	number	
8-10	1920-1922	of	
8-11	1923-1926	the	
8-12	1927-1934	columns	
8-13	1935-1937	in	
8-14	1938-1941	the	
8-15	1942-1947	query	
8-16	1948-1950	or	
8-17	1951-1957	create	
8-18	1958-1968	subqueries	
8-19	1969-1972	and	
8-20	1973-1976	use	
8-21	1977-1978	a	
8-22	1979-1983	JOIN	
8-23	1984-1988	that	
8-24	1989-1998	retrieves	
8-25	1999-2000	a	
8-26	2001-2008	smaller	
8-27	2009-2015	amount	
8-28	2016-2018	of	
8-29	2019-2023	data	
8-30	2023-2024	.	
8-31	2025-2030	Avoid	
8-32	2031-2036	large	
8-33	2037-2042	query	
8-34	2043-2050	outputs	
8-35	2051-2052	–	
8-36	2053-2060	Because	
8-37	2061-2066	query	
8-38	2067-2074	results	
8-39	2075-2078	are	
8-40	2079-2086	written	
8-41	2087-2089	to	
8-42	2090-2096	Amazon	
8-43	2097-2099	S3	
8-44	2100-2102	by	
8-45	2103-2104	a	
8-46	2105-2111	single	
8-47	2112-2118	Athena	
8-48	2119-2123	node	
8-49	2123-2124	,	
8-50	2125-2126	a	
8-51	2127-2132	large	
8-52	2133-2139	amount	
8-53	2140-2142	of	
8-54	2143-2149	output	
8-55	2150-2154	data	

#Text=can slow performance. To work around this, try using CTAS to create a new table with the result of the query or INSERT INTO to append new results into an existing table. Avoid CTAS queries with a large output – Because output data is written by a single node, CTAS queries can also use a large
9-1	2155-2158	can	
9-2	2159-2163	slow	
9-3	2164-2175	performance	
9-4	2175-2176	.	
9-5	2177-2179	To	
9-6	2180-2184	work	
9-7	2185-2191	around	
9-8	2192-2196	this	
9-9	2196-2197	,	
9-10	2198-2201	try	
9-11	2202-2207	using	
9-12	2208-2212	CTAS	
9-13	2213-2215	to	
9-14	2216-2222	create	
9-15	2223-2224	a	
9-16	2225-2228	new	
9-17	2229-2234	table	
9-18	2235-2239	with	
9-19	2240-2243	the	
9-20	2244-2250	result	
9-21	2251-2253	of	
9-22	2254-2257	the	
9-23	2258-2263	query	
9-24	2264-2266	or	
9-25	2267-2273	INSERT	
9-26	2274-2278	INTO	
9-27	2279-2281	to	
9-28	2282-2288	append	
9-29	2289-2292	new	
9-30	2293-2300	results	
9-31	2301-2305	into	
9-32	2306-2308	an	
9-33	2309-2317	existing	
9-34	2318-2323	table	
9-35	2323-2324	.	
9-36	2325-2330	Avoid	
9-37	2331-2335	CTAS	
9-38	2336-2343	queries	
9-39	2344-2348	with	
9-40	2349-2350	a	
9-41	2351-2356	large	
9-42	2357-2363	output	
9-43	2364-2365	–	
9-44	2366-2373	Because	
9-45	2374-2380	output	
9-46	2381-2385	data	
9-47	2386-2388	is	
9-48	2389-2396	written	
9-49	2397-2399	by	
9-50	2400-2401	a	
9-51	2402-2408	single	
9-52	2409-2413	node	
9-53	2413-2414	,	
9-54	2415-2419	CTAS	
9-55	2420-2427	queries	
9-56	2428-2431	can	
9-57	2432-2436	also	
9-58	2437-2440	use	
9-59	2441-2442	a	
9-60	2443-2448	large	

#Text=amount of memory. If you are outputting large amount of data, try separating the task into smaller queries. If possible, avoid having a large number of small files – Amazon S3 has a limit of 5500 requests per second. Athena queries share the same limit. If you need to scan millions of small objects in a single query, your query can be easily throttled by
10-1	2449-2455	amount	
10-2	2456-2458	of	
10-3	2459-2465	memory	
10-4	2465-2466	.	
10-5	2467-2469	If	
10-6	2470-2473	you	
10-7	2474-2477	are	
10-8	2478-2488	outputting	
10-9	2489-2494	large	
10-10	2495-2501	amount	
10-11	2502-2504	of	
10-12	2505-2509	data	
10-13	2509-2510	,	
10-14	2511-2514	try	
10-15	2515-2525	separating	
10-16	2526-2529	the	
10-17	2530-2534	task	
10-18	2535-2539	into	
10-19	2540-2547	smaller	
10-20	2548-2555	queries	
10-21	2555-2556	.	
10-22	2557-2559	If	
10-23	2560-2568	possible	
10-24	2568-2569	,	
10-25	2570-2575	avoid	
10-26	2576-2582	having	
10-27	2583-2584	a	
10-28	2585-2590	large	
10-29	2591-2597	number	
10-30	2598-2600	of	
10-31	2601-2606	small	
10-32	2607-2612	files	
10-33	2613-2614	–	
10-34	2615-2621	Amazon	
10-35	2622-2624	S3	
10-36	2625-2628	has	
10-37	2629-2630	a	
10-38	2631-2636	limit	
10-39	2637-2639	of	
10-40	2640-2644	5500	
10-41	2645-2653	requests	
10-42	2654-2657	per	
10-43	2658-2664	second	
10-44	2664-2665	.	
10-45	2666-2672	Athena	
10-46	2673-2680	queries	
10-47	2681-2686	share	
10-48	2687-2690	the	
10-49	2691-2695	same	
10-50	2696-2701	limit	
10-51	2701-2702	.	
10-52	2703-2705	If	
10-53	2706-2709	you	
10-54	2710-2714	need	
10-55	2715-2717	to	
10-56	2718-2722	scan	
10-57	2723-2731	millions	
10-58	2732-2734	of	
10-59	2735-2740	small	
10-60	2741-2748	objects	
10-61	2749-2751	in	
10-62	2752-2753	a	
10-63	2754-2760	single	
10-64	2761-2766	query	
10-65	2766-2767	,	
10-66	2768-2772	your	
10-67	2773-2778	query	
10-68	2779-2782	can	
10-69	2783-2785	be	
10-70	2786-2792	easily	
10-71	2793-2802	throttled	
10-72	2803-2805	by	

#Text=Amazon S3. To avoid excessive scanning, use AWS Glue ETL to periodically compact your files or partition the table and add partition key filters. For more information, see Reading Input Files in Larger Groups in the AWS Glue Developer Guide or How can I configure an AWS Glue ETL job to output larger files? in the AWS
11-1	2806-2812	Amazon	
11-2	2813-2815	S3	
11-3	2815-2816	.	
11-4	2817-2819	To	
11-5	2820-2825	avoid	
11-6	2826-2835	excessive	
11-7	2836-2844	scanning	
11-8	2844-2845	,	
11-9	2846-2849	use	
11-10	2850-2853	AWS	
11-11	2854-2858	Glue	
11-12	2859-2862	ETL	
11-13	2863-2865	to	
11-14	2866-2878	periodically	
11-15	2879-2886	compact	
11-16	2887-2891	your	
11-17	2892-2897	files	
11-18	2898-2900	or	
11-19	2901-2910	partition	
11-20	2911-2914	the	
11-21	2915-2920	table	
11-22	2921-2924	and	
11-23	2925-2928	add	
11-24	2929-2938	partition	
11-25	2939-2942	key	
11-26	2943-2950	filters	
11-27	2950-2951	.	
11-28	2952-2955	For	
11-29	2956-2960	more	
11-30	2961-2972	information	
11-31	2972-2973	,	
11-32	2974-2977	see	
11-33	2978-2985	Reading	
11-34	2986-2991	Input	
11-35	2992-2997	Files	
11-36	2998-3000	in	
11-37	3001-3007	Larger	
11-38	3008-3014	Groups	
11-39	3015-3017	in	
11-40	3018-3021	the	
11-41	3022-3025	AWS	
11-42	3026-3030	Glue	
11-43	3031-3040	Developer	
11-44	3041-3046	Guide	
11-45	3047-3049	or	
11-46	3050-3053	How	
11-47	3054-3057	can	
11-48	3058-3059	I	
11-49	3060-3069	configure	
11-50	3070-3072	an	
11-51	3073-3076	AWS	
11-52	3077-3081	Glue	
11-53	3082-3085	ETL	
11-54	3086-3089	job	
11-55	3090-3092	to	
11-56	3093-3099	output	
11-57	3100-3106	larger	
11-58	3107-3112	files	
11-59	3112-3113	?	
11-60	3114-3116	in	
11-61	3117-3120	the	
11-62	3121-3124	AWS	

#Text=Knowledge Center. Avoid scanning an entire table – Use the following techniques to avoid scanning entire tables: Limit the use of "*". Try not to select all columns unless necessary. Avoid scanning the same table multiple times in the same query
12-1	3125-3134	Knowledge	
12-2	3135-3141	Center	
12-3	3141-3142	.	
12-4	3143-3148	Avoid	
12-5	3149-3157	scanning	
12-6	3158-3160	an	
12-7	3161-3167	entire	
12-8	3168-3173	table	
12-9	3174-3175	–	
12-10	3176-3179	Use	
12-11	3180-3183	the	
12-12	3184-3193	following	
12-13	3194-3204	techniques	
12-14	3205-3207	to	
12-15	3208-3213	avoid	
12-16	3214-3222	scanning	
12-17	3223-3229	entire	
12-18	3230-3236	tables	
12-19	3236-3237	:	
12-20	3238-3243	Limit	
12-21	3244-3247	the	
12-22	3248-3251	use	
12-23	3252-3254	of	
12-24	3255-3256	"	
12-25	3256-3257	*	
12-26	3257-3258	"	
12-27	3258-3259	.	
12-28	3260-3263	Try	
12-29	3264-3267	not	
12-30	3268-3270	to	
12-31	3271-3277	select	
12-32	3278-3281	all	
12-33	3282-3289	columns	
12-34	3290-3296	unless	
12-35	3297-3306	necessary	
12-36	3306-3307	.	
12-37	3308-3313	Avoid	
12-38	3314-3322	scanning	
12-39	3323-3326	the	
12-40	3327-3331	same	
12-41	3332-3337	table	
12-42	3338-3346	multiple	
12-43	3347-3352	times	
12-44	3353-3355	in	
12-45	3356-3359	the	
12-46	3360-3364	same	
12-47	3365-3370	query	

#Text=Use filters to reduce the amount of data to be scanned. Whenever possible, add a LIMIT clause. Avoid referring to many views and tables in a single query – Because queries with many views and/or tables must load a large amount of data to a single node, out of memory errors can occur. If
13-1	3371-3374	Use	
13-2	3375-3382	filters	
13-3	3383-3385	to	
13-4	3386-3392	reduce	
13-5	3393-3396	the	
13-6	3397-3403	amount	
13-7	3404-3406	of	
13-8	3407-3411	data	
13-9	3412-3414	to	
13-10	3415-3417	be	
13-11	3418-3425	scanned	
13-12	3425-3426	.	
13-13	3427-3435	Whenever	
13-14	3436-3444	possible	
13-15	3444-3445	,	
13-16	3446-3449	add	
13-17	3450-3451	a	
13-18	3452-3457	LIMIT	
13-19	3458-3464	clause	
13-20	3464-3465	.	
13-21	3466-3471	Avoid	
13-22	3472-3481	referring	
13-23	3482-3484	to	
13-24	3485-3489	many	
13-25	3490-3495	views	
13-26	3496-3499	and	
13-27	3500-3506	tables	
13-28	3507-3509	in	
13-29	3510-3511	a	
13-30	3512-3518	single	
13-31	3519-3524	query	
13-32	3525-3526	–	
13-33	3527-3534	Because	
13-34	3535-3542	queries	
13-35	3543-3547	with	
13-36	3548-3552	many	
13-37	3553-3558	views	
13-38	3559-3562	and	
13-39	3562-3563	/	
13-40	3563-3565	or	
13-41	3566-3572	tables	
13-42	3573-3577	must	
13-43	3578-3582	load	
13-44	3583-3584	a	
13-45	3585-3590	large	
13-46	3591-3597	amount	
13-47	3598-3600	of	
13-48	3601-3605	data	
13-49	3606-3608	to	
13-50	3609-3610	a	
13-51	3611-3617	single	
13-52	3618-3622	node	
13-53	3622-3623	,	
13-54	3624-3627	out	
13-55	3628-3630	of	
13-56	3631-3637	memory	
13-57	3638-3644	errors	
13-58	3645-3648	can	
13-59	3649-3654	occur	
13-60	3654-3655	.	
13-61	3656-3658	If	

#Text=possible, avoid referring to an excessive number of views or tables in a single query. Avoid large JSON strings – If data is stored in a single JSON string and the size of the JSON data is large, out of memory errors can occur when the JSON data is processed. File Formats
14-1	3659-3667	possible	
14-2	3667-3668	,	
14-3	3669-3674	avoid	
14-4	3675-3684	referring	
14-5	3685-3687	to	
14-6	3688-3690	an	
14-7	3691-3700	excessive	
14-8	3701-3707	number	
14-9	3708-3710	of	
14-10	3711-3716	views	
14-11	3717-3719	or	
14-12	3720-3726	tables	
14-13	3727-3729	in	
14-14	3730-3731	a	
14-15	3732-3738	single	
14-16	3739-3744	query	
14-17	3744-3745	.	
14-18	3746-3751	Avoid	
14-19	3752-3757	large	
14-20	3758-3762	JSON	
14-21	3763-3770	strings	
14-22	3771-3772	–	
14-23	3773-3775	If	
14-24	3776-3780	data	
14-25	3781-3783	is	
14-26	3784-3790	stored	
14-27	3791-3793	in	
14-28	3794-3795	a	
14-29	3796-3802	single	
14-30	3803-3807	JSON	
14-31	3808-3814	string	
14-32	3815-3818	and	
14-33	3819-3822	the	
14-34	3823-3827	size	
14-35	3828-3830	of	
14-36	3831-3834	the	
14-37	3835-3839	JSON	
14-38	3840-3844	data	
14-39	3845-3847	is	
14-40	3848-3853	large	
14-41	3853-3854	,	
14-42	3855-3858	out	
14-43	3859-3861	of	
14-44	3862-3868	memory	
14-45	3869-3875	errors	
14-46	3876-3879	can	
14-47	3880-3885	occur	
14-48	3886-3890	when	
14-49	3891-3894	the	
14-50	3895-3899	JSON	
14-51	3900-3904	data	
14-52	3905-3907	is	
14-53	3908-3917	processed	
14-54	3917-3918	.	
14-55	3919-3923	File	
14-56	3924-3931	Formats	

#Text=Use an efficient file format such as Parquet or ORC – To dramatically reduce query running time and costs, use compressed Parquet or ORC files to store your data. To convert your existing dataset to those formats in Athena, you can use CTAS. For more information, see Using CTAS and INSERT INTO for ETL and Data
15-1	3932-3935	Use	
15-2	3936-3938	an	
15-3	3939-3948	efficient	
15-4	3949-3953	file	
15-5	3954-3960	format	
15-6	3961-3965	such	
15-7	3966-3968	as	
15-8	3969-3976	Parquet	
15-9	3977-3979	or	
15-10	3980-3983	ORC	
15-11	3984-3985	–	
15-12	3986-3988	To	
15-13	3989-4001	dramatically	
15-14	4002-4008	reduce	
15-15	4009-4014	query	
15-16	4015-4022	running	
15-17	4023-4027	time	
15-18	4028-4031	and	
15-19	4032-4037	costs	
15-20	4037-4038	,	
15-21	4039-4042	use	
15-22	4043-4053	compressed	
15-23	4054-4061	Parquet	
15-24	4062-4064	or	
15-25	4065-4068	ORC	
15-26	4069-4074	files	
15-27	4075-4077	to	
15-28	4078-4083	store	
15-29	4084-4088	your	
15-30	4089-4093	data	
15-31	4093-4094	.	
15-32	4095-4097	To	
15-33	4098-4105	convert	
15-34	4106-4110	your	
15-35	4111-4119	existing	
15-36	4120-4127	dataset	
15-37	4128-4130	to	
15-38	4131-4136	those	
15-39	4137-4144	formats	
15-40	4145-4147	in	
15-41	4148-4154	Athena	
15-42	4154-4155	,	
15-43	4156-4159	you	
15-44	4160-4163	can	
15-45	4164-4167	use	
15-46	4168-4172	CTAS	
15-47	4172-4173	.	
15-48	4174-4177	For	
15-49	4178-4182	more	
15-50	4183-4194	information	
15-51	4194-4195	,	
15-52	4196-4199	see	
15-53	4200-4205	Using	
15-54	4206-4210	CTAS	
15-55	4211-4214	and	
15-56	4215-4221	INSERT	
15-57	4222-4226	INTO	
15-58	4227-4230	for	
15-59	4231-4234	ETL	
15-60	4235-4238	and	
15-61	4239-4243	Data	

#Text=Analysis. Switch between ORC and Parquet formats – Experience shows that the same set of data can have significant differences in processing time depending on whether it is stored in ORC or Parquet format. If you are experiencing performance issues, try a different format.
16-1	4244-4252	Analysis	
16-2	4252-4253	.	
16-3	4254-4260	Switch	
16-4	4261-4268	between	
16-5	4269-4272	ORC	
16-6	4273-4276	and	
16-7	4277-4284	Parquet	
16-8	4285-4292	formats	
16-9	4293-4294	–	
16-10	4295-4305	Experience	
16-11	4306-4311	shows	
16-12	4312-4316	that	
16-13	4317-4320	the	
16-14	4321-4325	same	
16-15	4326-4329	set	
16-16	4330-4332	of	
16-17	4333-4337	data	
16-18	4338-4341	can	
16-19	4342-4346	have	
16-20	4347-4358	significant	
16-21	4359-4370	differences	
16-22	4371-4373	in	
16-23	4374-4384	processing	
16-24	4385-4389	time	
16-25	4390-4399	depending	
16-26	4400-4402	on	
16-27	4403-4410	whether	
16-28	4411-4413	it	
16-29	4414-4416	is	
16-30	4417-4423	stored	
16-31	4424-4426	in	
16-32	4427-4430	ORC	
16-33	4431-4433	or	
16-34	4434-4441	Parquet	
16-35	4442-4448	format	
16-36	4448-4449	.	
16-37	4450-4452	If	
16-38	4453-4456	you	
16-39	4457-4460	are	
16-40	4461-4473	experiencing	
16-41	4474-4485	performance	
16-42	4486-4492	issues	
16-43	4492-4493	,	
16-44	4494-4497	try	
16-45	4498-4499	a	
16-46	4500-4509	different	
16-47	4510-4516	format	
16-48	4516-4517	.	

#Text=Hudi queries – Because Hudi queries bypass the native reader and split generator for files in parquet format, they can be slow. Keep this in mind when querying Hudi datasets. Joins, Grouping, and Unions Reduce the usage of memory intensive operations
17-1	4518-4522	Hudi	
17-2	4523-4530	queries	
17-3	4531-4532	–	
17-4	4533-4540	Because	
17-5	4541-4545	Hudi	
17-6	4546-4553	queries	
17-7	4554-4560	bypass	
17-8	4561-4564	the	
17-9	4565-4571	native	
17-10	4572-4578	reader	
17-11	4579-4582	and	
17-12	4583-4588	split	
17-13	4589-4598	generator	
17-14	4599-4602	for	
17-15	4603-4608	files	
17-16	4609-4611	in	
17-17	4612-4619	parquet	
17-18	4620-4626	format	
17-19	4626-4627	,	
17-20	4628-4632	they	
17-21	4633-4636	can	
17-22	4637-4639	be	
17-23	4640-4644	slow	
17-24	4644-4645	.	
17-25	4646-4650	Keep	
17-26	4651-4655	this	
17-27	4656-4658	in	
17-28	4659-4663	mind	
17-29	4664-4668	when	
17-30	4669-4677	querying	
17-31	4678-4682	Hudi	
17-32	4683-4691	datasets	
17-33	4691-4692	.	
17-34	4693-4698	Joins	
17-35	4698-4699	,	
17-36	4700-4708	Grouping	
17-37	4708-4709	,	
17-38	4710-4713	and	
17-39	4714-4720	Unions	
17-40	4721-4727	Reduce	
17-41	4728-4731	the	
17-42	4732-4737	usage	
17-43	4738-4740	of	
17-44	4741-4747	memory	
17-45	4748-4757	intensive	
17-46	4758-4768	operations	

#Text=– Operations like JOIN, GROUP BY, ORDER BY, and UNION all require loading large amount of data into memory. To speed up your query, find other ways to achieve the same results, or add a clause like LIMIT to the outer query whenever possible. Consider using UNION ALL – To eliminate
18-1	4769-4770	–	
18-2	4771-4781	Operations	
18-3	4782-4786	like	
18-4	4787-4791	JOIN	
18-5	4791-4792	,	
18-6	4793-4798	GROUP	
18-7	4799-4801	BY	
18-8	4801-4802	,	
18-9	4803-4808	ORDER	
18-10	4809-4811	BY	
18-11	4811-4812	,	
18-12	4813-4816	and	
18-13	4817-4822	UNION	
18-14	4823-4826	all	
18-15	4827-4834	require	
18-16	4835-4842	loading	
18-17	4843-4848	large	
18-18	4849-4855	amount	
18-19	4856-4858	of	
18-20	4859-4863	data	
18-21	4864-4868	into	
18-22	4869-4875	memory	
18-23	4875-4876	.	
18-24	4877-4879	To	
18-25	4880-4885	speed	
18-26	4886-4888	up	
18-27	4889-4893	your	
18-28	4894-4899	query	
18-29	4899-4900	,	
18-30	4901-4905	find	
18-31	4906-4911	other	
18-32	4912-4916	ways	
18-33	4917-4919	to	
18-34	4920-4927	achieve	
18-35	4928-4931	the	
18-36	4932-4936	same	
18-37	4937-4944	results	
18-38	4944-4945	,	
18-39	4946-4948	or	
18-40	4949-4952	add	
18-41	4953-4954	a	
18-42	4955-4961	clause	
18-43	4962-4966	like	
18-44	4967-4972	LIMIT	
18-45	4973-4975	to	
18-46	4976-4979	the	
18-47	4980-4985	outer	
18-48	4986-4991	query	
18-49	4992-5000	whenever	
18-50	5001-5009	possible	
18-51	5009-5010	.	
18-52	5011-5019	Consider	
18-53	5020-5025	using	
18-54	5026-5031	UNION	
18-55	5032-5035	ALL	
18-56	5036-5037	–	
18-57	5038-5040	To	
18-58	5041-5050	eliminate	

#Text=duplicates, UNION builds a hash table, which consumes memory. If your query does not require the elimination of duplicates, consider using UNION ALL for better performance. Use CTAS as an intermediary step to speed up JOIN operations – Instead of loading and processing intermediary data
19-1	5051-5061	duplicates	
19-2	5061-5062	,	
19-3	5063-5068	UNION	
19-4	5069-5075	builds	
19-5	5076-5077	a	
19-6	5078-5082	hash	
19-7	5083-5088	table	
19-8	5088-5089	,	
19-9	5090-5095	which	
19-10	5096-5104	consumes	
19-11	5105-5111	memory	
19-12	5111-5112	.	
19-13	5113-5115	If	
19-14	5116-5120	your	
19-15	5121-5126	query	
19-16	5127-5131	does	
19-17	5132-5135	not	
19-18	5136-5143	require	
19-19	5144-5147	the	
19-20	5148-5159	elimination	
19-21	5160-5162	of	
19-22	5163-5173	duplicates	
19-23	5173-5174	,	
19-24	5175-5183	consider	
19-25	5184-5189	using	
19-26	5190-5195	UNION	
19-27	5196-5199	ALL	
19-28	5200-5203	for	
19-29	5204-5210	better	
19-30	5211-5222	performance	
19-31	5222-5223	.	
19-32	5224-5227	Use	
19-33	5228-5232	CTAS	
19-34	5233-5235	as	
19-35	5236-5238	an	
19-36	5239-5251	intermediary	
19-37	5252-5256	step	
19-38	5257-5259	to	
19-39	5260-5265	speed	
19-40	5266-5268	up	
19-41	5269-5273	JOIN	
19-42	5274-5284	operations	
19-43	5285-5286	–	
19-44	5287-5294	Instead	
19-45	5295-5297	of	
19-46	5298-5305	loading	
19-47	5306-5309	and	
19-48	5310-5320	processing	
19-49	5321-5333	intermediary	
19-50	5334-5338	data	

#Text=with every query, use CTAS to persist the intermediary data into Amazon S3. This can help speed up the performance of operations like JOIN. Partitioning Limit the number of partitions in a table – When a table has more than 100,000 partitions, queries can be slow because of the
20-1	5339-5343	with	
20-2	5344-5349	every	
20-3	5350-5355	query	
20-4	5355-5356	,	
20-5	5357-5360	use	
20-6	5361-5365	CTAS	
20-7	5366-5368	to	
20-8	5369-5376	persist	
20-9	5377-5380	the	
20-10	5381-5393	intermediary	
20-11	5394-5398	data	
20-12	5399-5403	into	
20-13	5404-5410	Amazon	
20-14	5411-5413	S3	
20-15	5413-5414	.	
20-16	5415-5419	This	
20-17	5420-5423	can	
20-18	5424-5428	help	
20-19	5429-5434	speed	
20-20	5435-5437	up	
20-21	5438-5441	the	
20-22	5442-5453	performance	
20-23	5454-5456	of	
20-24	5457-5467	operations	
20-25	5468-5472	like	
20-26	5473-5477	JOIN	
20-27	5477-5478	.	
20-28	5479-5491	Partitioning	
20-29	5492-5497	Limit	
20-30	5498-5501	the	
20-31	5502-5508	number	
20-32	5509-5511	of	
20-33	5512-5522	partitions	
20-34	5523-5525	in	
20-35	5526-5527	a	
20-36	5528-5533	table	
20-37	5534-5535	–	
20-38	5536-5540	When	
20-39	5541-5542	a	
20-40	5543-5548	table	
20-41	5549-5552	has	
20-42	5553-5557	more	
20-43	5558-5562	than	
20-44	5563-5570	100,000	
20-45	5571-5581	partitions	
20-46	5581-5582	,	
20-47	5583-5590	queries	
20-48	5591-5594	can	
20-49	5595-5597	be	
20-50	5598-5602	slow	
20-51	5603-5610	because	
20-52	5611-5613	of	
20-53	5614-5617	the	

#Text=large number of requests sent to AWS Glue to retrieve partition information. To resolve this issue, try one of the following options: Use ALTER TABLE DROP PARTITION to remove stale partitions. If your partition pattern is predictable, use partition projection. Remove old partitions even if they are empty
21-1	5618-5623	large	
21-2	5624-5630	number	
21-3	5631-5633	of	
21-4	5634-5642	requests	
21-5	5643-5647	sent	
21-6	5648-5650	to	
21-7	5651-5654	AWS	
21-8	5655-5659	Glue	
21-9	5660-5662	to	
21-10	5663-5671	retrieve	
21-11	5672-5681	partition	
21-12	5682-5693	information	
21-13	5693-5694	.	
21-14	5695-5697	To	
21-15	5698-5705	resolve	
21-16	5706-5710	this	
21-17	5711-5716	issue	
21-18	5716-5717	,	
21-19	5718-5721	try	
21-20	5722-5725	one	
21-21	5726-5728	of	
21-22	5729-5732	the	
21-23	5733-5742	following	
21-24	5743-5750	options	
21-25	5750-5751	:	
21-26	5752-5755	Use	
21-27	5756-5761	ALTER	
21-28	5762-5767	TABLE	
21-29	5768-5772	DROP	
21-30	5773-5782	PARTITION	
21-31	5783-5785	to	
21-32	5786-5792	remove	
21-33	5793-5798	stale	
21-34	5799-5809	partitions	
21-35	5809-5810	.	
21-36	5811-5813	If	
21-37	5814-5818	your	
21-38	5819-5828	partition	
21-39	5829-5836	pattern	
21-40	5837-5839	is	
21-41	5840-5851	predictable	
21-42	5851-5852	,	
21-43	5853-5856	use	
21-44	5857-5866	partition	
21-45	5867-5877	projection	
21-46	5877-5878	.	
21-47	5879-5885	Remove	
21-48	5886-5889	old	
21-49	5890-5900	partitions	
21-50	5901-5905	even	
21-51	5906-5908	if	
21-52	5909-5913	they	
21-53	5914-5917	are	
21-54	5918-5923	empty	

#Text=– Even if a partition is empty, the metadata of the partition is still stored in AWS Glue. Loading these unneeded partitions can increase query runtimes. To remove the unneeded partitions, use ALTER TABLE DROP PARTITION. Look up a single partition – When looking up
22-1	5924-5925	–	
22-2	5926-5930	Even	
22-3	5931-5933	if	
22-4	5934-5935	a	
22-5	5936-5945	partition	
22-6	5946-5948	is	
22-7	5949-5954	empty	
22-8	5954-5955	,	
22-9	5956-5959	the	
22-10	5960-5968	metadata	
22-11	5969-5971	of	
22-12	5972-5975	the	
22-13	5976-5985	partition	
22-14	5986-5988	is	
22-15	5989-5994	still	
22-16	5995-6001	stored	
22-17	6002-6004	in	
22-18	6005-6008	AWS	
22-19	6009-6013	Glue	
22-20	6013-6014	.	
22-21	6015-6022	Loading	
22-22	6023-6028	these	
22-23	6029-6037	unneeded	
22-24	6038-6048	partitions	
22-25	6049-6052	can	
22-26	6053-6061	increase	
22-27	6062-6067	query	
22-28	6068-6076	runtimes	
22-29	6076-6077	.	
22-30	6078-6080	To	
22-31	6081-6087	remove	
22-32	6088-6091	the	
22-33	6092-6100	unneeded	
22-34	6101-6111	partitions	
22-35	6111-6112	,	
22-36	6113-6116	use	
22-37	6117-6122	ALTER	
22-38	6123-6128	TABLE	
22-39	6129-6133	DROP	
22-40	6134-6143	PARTITION	
22-41	6143-6144	.	
22-42	6145-6149	Look	
22-43	6150-6152	up	
22-44	6153-6154	a	
22-45	6155-6161	single	
22-46	6162-6171	partition	
22-47	6172-6173	–	
22-48	6174-6178	When	
22-49	6179-6186	looking	
22-50	6187-6189	up	

#Text=a single partition, try to provide all partition values so that Athena can locate the partition with a single call to AWS Glue. Otherwise, Athena must retrieve all partitions and filter them. This can be costly and greatly increase the planning time for your query. If you have a predictable partition pattern, you can use partition
23-1	6190-6191	a	
23-2	6192-6198	single	
23-3	6199-6208	partition	
23-4	6208-6209	,	
23-5	6210-6213	try	
23-6	6214-6216	to	
23-7	6217-6224	provide	
23-8	6225-6228	all	
23-9	6229-6238	partition	
23-10	6239-6245	values	
23-11	6246-6248	so	
23-12	6249-6253	that	
23-13	6254-6260	Athena	
23-14	6261-6264	can	
23-15	6265-6271	locate	
23-16	6272-6275	the	
23-17	6276-6285	partition	
23-18	6286-6290	with	
23-19	6291-6292	a	
23-20	6293-6299	single	
23-21	6300-6304	call	
23-22	6305-6307	to	
23-23	6308-6311	AWS	
23-24	6312-6316	Glue	
23-25	6316-6317	.	
23-26	6318-6327	Otherwise	
23-27	6327-6328	,	
23-28	6329-6335	Athena	
23-29	6336-6340	must	
23-30	6341-6349	retrieve	
23-31	6350-6353	all	
23-32	6354-6364	partitions	
23-33	6365-6368	and	
23-34	6369-6375	filter	
23-35	6376-6380	them	
23-36	6380-6381	.	
23-37	6382-6386	This	
23-38	6387-6390	can	
23-39	6391-6393	be	
23-40	6394-6400	costly	
23-41	6401-6404	and	
23-42	6405-6412	greatly	
23-43	6413-6421	increase	
23-44	6422-6425	the	
23-45	6426-6434	planning	
23-46	6435-6439	time	
23-47	6440-6443	for	
23-48	6444-6448	your	
23-49	6449-6454	query	
23-50	6454-6455	.	
23-51	6456-6458	If	
23-52	6459-6462	you	
23-53	6463-6467	have	
23-54	6468-6469	a	
23-55	6470-6481	predictable	
23-56	6482-6491	partition	
23-57	6492-6499	pattern	
23-58	6499-6500	,	
23-59	6501-6504	you	
23-60	6505-6508	can	
23-61	6509-6512	use	
23-62	6513-6522	partition	

#Text=projection to avoid the partition look up calls to AWS Glue. Set reasonable partition projection properties – When using partition projection, Athena tries to create a partition object for every partition name. Because of this, make sure that the table properties that you define do not create a near infinite amount of possible partitions.
24-1	6523-6533	projection	
24-2	6534-6536	to	
24-3	6537-6542	avoid	
24-4	6543-6546	the	
24-5	6547-6556	partition	
24-6	6557-6561	look	
24-7	6562-6564	up	
24-8	6565-6570	calls	
24-9	6571-6573	to	
24-10	6574-6577	AWS	
24-11	6578-6582	Glue	
24-12	6582-6583	.	
24-13	6584-6587	Set	
24-14	6588-6598	reasonable	
24-15	6599-6608	partition	
24-16	6609-6619	projection	
24-17	6620-6630	properties	
24-18	6631-6632	–	
24-19	6633-6637	When	
24-20	6638-6643	using	
24-21	6644-6653	partition	
24-22	6654-6664	projection	
24-23	6664-6665	,	
24-24	6666-6672	Athena	
24-25	6673-6678	tries	
24-26	6679-6681	to	
24-27	6682-6688	create	
24-28	6689-6690	a	
24-29	6691-6700	partition	
24-30	6701-6707	object	
24-31	6708-6711	for	
24-32	6712-6717	every	
24-33	6718-6727	partition	
24-34	6728-6732	name	
24-35	6732-6733	.	
24-36	6734-6741	Because	
24-37	6742-6744	of	
24-38	6745-6749	this	
24-39	6749-6750	,	
24-40	6751-6755	make	
24-41	6756-6760	sure	
24-42	6761-6765	that	
24-43	6766-6769	the	
24-44	6770-6775	table	
24-45	6776-6786	properties	
24-46	6787-6791	that	
24-47	6792-6795	you	
24-48	6796-6802	define	
24-49	6803-6805	do	
24-50	6806-6809	not	
24-51	6810-6816	create	
24-52	6817-6818	a	
24-53	6819-6823	near	
24-54	6824-6832	infinite	
24-55	6833-6839	amount	
24-56	6840-6842	of	
24-57	6843-6851	possible	
24-58	6852-6862	partitions	
24-59	6862-6863	.	

#Text=To add new partitions frequently, use ALTER TABLE ADD PARTITION – If you use MSCK REPAIR TABLE to add new partitions frequently (for example, on a daily basis) and are experiencing query timeouts, consider using ALTER TABLE ADD PARTITION.
25-1	6864-6866	To	
25-2	6867-6870	add	
25-3	6871-6874	new	
25-4	6875-6885	partitions	
25-5	6886-6896	frequently	
25-6	6896-6897	,	
25-7	6898-6901	use	
25-8	6902-6907	ALTER	
25-9	6908-6913	TABLE	
25-10	6914-6917	ADD	
25-11	6918-6927	PARTITION	
25-12	6928-6929	–	
25-13	6930-6932	If	
25-14	6933-6936	you	
25-15	6937-6940	use	
25-16	6941-6945	MSCK	
25-17	6946-6952	REPAIR	
25-18	6953-6958	TABLE	
25-19	6959-6961	to	
25-20	6962-6965	add	
25-21	6966-6969	new	
25-22	6970-6980	partitions	
25-23	6981-6991	frequently	
25-24	6992-6993	(	
25-25	6993-6996	for	
25-26	6997-7004	example	
25-27	7004-7005	,	
25-28	7006-7008	on	
25-29	7009-7010	a	
25-30	7011-7016	daily	
25-31	7017-7022	basis	
25-32	7022-7023	)	
25-33	7024-7027	and	
25-34	7028-7031	are	
25-35	7032-7044	experiencing	
25-36	7045-7050	query	
25-37	7051-7059	timeouts	
25-38	7059-7060	,	
25-39	7061-7069	consider	
25-40	7070-7075	using	
25-41	7076-7081	ALTER	
25-42	7082-7087	TABLE	
25-43	7088-7091	ADD	
25-44	7092-7101	PARTITION	
25-45	7101-7102	.	

#Text=MSCK REPAIR TABLE is best used when creating a table for the first time or when there is uncertainty about parity between data and partition metadata. Avoid using coalesce()in a WHERE clause with partitioned columns – Under some circumstances, using the coalesce() or other functions in a WHERE clause against
26-1	7103-7107	MSCK	
26-2	7108-7114	REPAIR	
26-3	7115-7120	TABLE	
26-4	7121-7123	is	
26-5	7124-7128	best	
26-6	7129-7133	used	
26-7	7134-7138	when	
26-8	7139-7147	creating	
26-9	7148-7149	a	
26-10	7150-7155	table	
26-11	7156-7159	for	
26-12	7160-7163	the	
26-13	7164-7169	first	
26-14	7170-7174	time	
26-15	7175-7177	or	
26-16	7178-7182	when	
26-17	7183-7188	there	
26-18	7189-7191	is	
26-19	7192-7203	uncertainty	
26-20	7204-7209	about	
26-21	7210-7216	parity	
26-22	7217-7224	between	
26-23	7225-7229	data	
26-24	7230-7233	and	
26-25	7234-7243	partition	
26-26	7244-7252	metadata	
26-27	7252-7253	.	
26-28	7254-7259	Avoid	
26-29	7260-7265	using	
26-30	7266-7274	coalesce	
26-31	7274-7275	(	
26-32	7275-7276	)	
26-33	7276-7278	in	
26-34	7279-7280	a	
26-35	7281-7286	WHERE	
26-36	7287-7293	clause	
26-37	7294-7298	with	
26-38	7299-7310	partitioned	
26-39	7311-7318	columns	
26-40	7319-7320	–	
26-41	7321-7326	Under	
26-42	7327-7331	some	
26-43	7332-7345	circumstances	
26-44	7345-7346	,	
26-45	7347-7352	using	
26-46	7353-7356	the	
26-47	7357-7365	coalesce	
26-48	7365-7366	(	
26-49	7366-7367	)	
26-50	7368-7370	or	
26-51	7371-7376	other	
26-52	7377-7386	functions	
26-53	7387-7389	in	
26-54	7390-7391	a	
26-55	7392-7397	WHERE	
26-56	7398-7404	clause	
26-57	7405-7412	against	

#Text=partitioned columns might result in reduced performance. If this occurs, try rewriting your query to provide the same functionality without using coalesce(). Window Functions Minimize the use of window functions – Window functions such as rank() are memory intensive. In general, window functions require an entire dataset to be
27-1	7413-7424	partitioned	
27-2	7425-7432	columns	
27-3	7433-7438	might	
27-4	7439-7445	result	
27-5	7446-7448	in	
27-6	7449-7456	reduced	
27-7	7457-7468	performance	
27-8	7468-7469	.	
27-9	7470-7472	If	
27-10	7473-7477	this	
27-11	7478-7484	occurs	
27-12	7484-7485	,	
27-13	7486-7489	try	
27-14	7490-7499	rewriting	
27-15	7500-7504	your	
27-16	7505-7510	query	
27-17	7511-7513	to	
27-18	7514-7521	provide	
27-19	7522-7525	the	
27-20	7526-7530	same	
27-21	7531-7544	functionality	
27-22	7545-7552	without	
27-23	7553-7558	using	
27-24	7559-7567	coalesce	
27-25	7567-7568	(	
27-26	7568-7569	)	
27-27	7569-7570	.	
27-28	7571-7577	Window	
27-29	7578-7587	Functions	
27-30	7588-7596	Minimize	
27-31	7597-7600	the	
27-32	7601-7604	use	
27-33	7605-7607	of	
27-34	7608-7614	window	
27-35	7615-7624	functions	
27-36	7625-7626	–	
27-37	7627-7633	Window	
27-38	7634-7643	functions	
27-39	7644-7648	such	
27-40	7649-7651	as	
27-41	7652-7656	rank	
27-42	7656-7657	(	
27-43	7657-7658	)	
27-44	7659-7662	are	
27-45	7663-7669	memory	
27-46	7670-7679	intensive	
27-47	7679-7680	.	
27-48	7681-7683	In	
27-49	7684-7691	general	
27-50	7691-7692	,	
27-51	7693-7699	window	
27-52	7700-7709	functions	
27-53	7710-7717	require	
27-54	7718-7720	an	
27-55	7721-7727	entire	
27-56	7728-7735	dataset	
27-57	7736-7738	to	
27-58	7739-7741	be	

#Text=loaded into a single Athena node for processing. With an extremely large dataset, this can risk crashing the node. To avoid this, try the following options: Filter the data and run window functions on a subset of the data. Use the PARTITION BY clause with the window function whenever possible. Find an alternative way to construct the query.
28-1	7742-7748	loaded	
28-2	7749-7753	into	
28-3	7754-7755	a	
28-4	7756-7762	single	
28-5	7763-7769	Athena	
28-6	7770-7774	node	
28-7	7775-7778	for	
28-8	7779-7789	processing	
28-9	7789-7790	.	
28-10	7791-7795	With	
28-11	7796-7798	an	
28-12	7799-7808	extremely	
28-13	7809-7814	large	
28-14	7815-7822	dataset	
28-15	7822-7823	,	
28-16	7824-7828	this	
28-17	7829-7832	can	
28-18	7833-7837	risk	
28-19	7838-7846	crashing	
28-20	7847-7850	the	
28-21	7851-7855	node	
28-22	7855-7856	.	
28-23	7857-7859	To	
28-24	7860-7865	avoid	
28-25	7866-7870	this	
28-26	7870-7871	,	
28-27	7872-7875	try	
28-28	7876-7879	the	
28-29	7880-7889	following	
28-30	7890-7897	options	
28-31	7897-7898	:	
28-32	7899-7905	Filter	
28-33	7906-7909	the	
28-34	7910-7914	data	
28-35	7915-7918	and	
28-36	7919-7922	run	
28-37	7923-7929	window	
28-38	7930-7939	functions	
28-39	7940-7942	on	
28-40	7943-7944	a	
28-41	7945-7951	subset	
28-42	7952-7954	of	
28-43	7955-7958	the	
28-44	7959-7963	data	
28-45	7963-7964	.	
28-46	7965-7968	Use	
28-47	7969-7972	the	
28-48	7973-7982	PARTITION	
28-49	7983-7985	BY	
28-50	7986-7992	clause	
28-51	7993-7997	with	
28-52	7998-8001	the	
28-53	8002-8008	window	
28-54	8009-8017	function	
28-55	8018-8026	whenever	
28-56	8027-8035	possible	
28-57	8035-8036	.	
28-58	8037-8041	Find	
28-59	8042-8044	an	
28-60	8045-8056	alternative	
28-61	8057-8060	way	
28-62	8061-8063	to	
28-63	8064-8073	construct	
28-64	8074-8077	the	
28-65	8078-8083	query	
28-66	8083-8084	.	

#Text=Use More Efficient Functions Replace row_number() OVER (...) as rnk ... WHERE rnk = 1 – To speed up a query with a row_number() clause like this, replace this syntax with a combination
29-1	8085-8088	Use	
29-2	8089-8093	More	
29-3	8094-8103	Efficient	
29-4	8104-8113	Functions	
29-5	8114-8121	Replace	
29-6	8122-8132	row_number	
29-7	8132-8133	(	
29-8	8133-8134	)	
29-9	8135-8139	OVER	
29-10	8140-8141	(	
29-11	8141-8142	.	
29-12	8142-8143	.	
29-13	8143-8144	.	
29-14	8144-8145	)	
29-15	8146-8148	as	
29-16	8149-8152	rnk	
29-17	8153-8154	.	
29-18	8154-8155	.	
29-19	8155-8156	.	
29-20	8157-8162	WHERE	
29-21	8163-8166	rnk	
29-22	8167-8168	=	
29-23	8169-8170	1	
29-24	8171-8172	–	
29-25	8173-8175	To	
29-26	8176-8181	speed	
29-27	8182-8184	up	
29-28	8185-8186	a	
29-29	8187-8192	query	
29-30	8193-8197	with	
29-31	8198-8199	a	
29-32	8200-8210	row_number	
29-33	8210-8211	(	
29-34	8211-8212	)	
29-35	8213-8219	clause	
29-36	8220-8224	like	
29-37	8225-8229	this	
29-38	8229-8230	,	
29-39	8231-8238	replace	
29-40	8239-8243	this	
29-41	8244-8250	syntax	
29-42	8251-8255	with	
29-43	8256-8257	a	
29-44	8258-8269	combination	

#Text=of GROUP BY, ORDER BY, and LIMIT 1. Use regular expressions instead of LIKE on large strings – Queries that include clauses such as LIKE '%string%' on large strings can be very costly. Consider using the regexp_like() function and a regular expression instead.
30-1	8270-8272	of	
30-2	8273-8278	GROUP	
30-3	8279-8281	BY	
30-4	8281-8282	,	
30-5	8283-8288	ORDER	
30-6	8289-8291	BY	
30-7	8291-8292	,	
30-8	8293-8296	and	
30-9	8297-8302	LIMIT	
30-10	8303-8304	1	
30-11	8304-8305	.	
30-12	8306-8309	Use	
30-13	8310-8317	regular	
30-14	8318-8329	expressions	
30-15	8330-8337	instead	
30-16	8338-8340	of	
30-17	8341-8345	LIKE	
30-18	8346-8348	on	
30-19	8349-8354	large	
30-20	8355-8362	strings	
30-21	8363-8364	–	
30-22	8365-8372	Queries	
30-23	8373-8377	that	
30-24	8378-8385	include	
30-25	8386-8393	clauses	
30-26	8394-8398	such	
30-27	8399-8401	as	
30-28	8402-8406	LIKE	
30-29	8407-8408	'	
30-30	8408-8409	%	
30-31	8409-8415	string	
30-32	8415-8416	%	
30-33	8416-8417	'	
30-34	8418-8420	on	
30-35	8421-8426	large	
30-36	8427-8434	strings	
30-37	8435-8438	can	
30-38	8439-8441	be	
30-39	8442-8446	very	
30-40	8447-8453	costly	
30-41	8453-8454	.	
30-42	8455-8463	Consider	
30-43	8464-8469	using	
30-44	8470-8473	the	
30-45	8474-8485	regexp_like	
30-46	8485-8486	(	
30-47	8486-8487	)	
30-48	8488-8496	function	
30-49	8497-8500	and	
30-50	8501-8502	a	
30-51	8503-8510	regular	
30-52	8511-8521	expression	
30-53	8522-8529	instead	
30-54	8529-8530	.	

#Text=Use max() instead of element_at(array_sort(), 1) – For increased speed, replace the nested functions element_at(array_sort(), 1) with max(). Additional Resources For additional information on performance tuning in Athena, consider the following resources: Read the AWS Big Data blog post Top 10
31-1	8531-8534	Use	
31-2	8535-8538	max	
31-3	8538-8539	(	
31-4	8539-8540	)	
31-5	8541-8548	instead	
31-6	8549-8551	of	
31-7	8552-8562	element_at	
31-8	8562-8563	(	
31-9	8563-8573	array_sort	
31-10	8573-8574	(	
31-11	8574-8575	)	
31-12	8575-8576	,	
31-13	8577-8578	1	
31-14	8578-8579	)	
31-15	8580-8581	–	
31-16	8582-8585	For	
31-17	8586-8595	increased	
31-18	8596-8601	speed	
31-19	8601-8602	,	
31-20	8603-8610	replace	
31-21	8611-8614	the	
31-22	8615-8621	nested	
31-23	8622-8631	functions	
31-24	8632-8642	element_at	
31-25	8642-8643	(	
31-26	8643-8653	array_sort	
31-27	8653-8654	(	
31-28	8654-8655	)	
31-29	8655-8656	,	
31-30	8657-8658	1	
31-31	8658-8659	)	
31-32	8660-8664	with	
31-33	8665-8668	max	
31-34	8668-8669	(	
31-35	8669-8670	)	
31-36	8670-8671	.	
31-37	8672-8682	Additional	
31-38	8683-8692	Resources	
31-39	8693-8696	For	
31-40	8697-8707	additional	
31-41	8708-8719	information	
31-42	8720-8722	on	
31-43	8723-8734	performance	
31-44	8735-8741	tuning	
31-45	8742-8744	in	
31-46	8745-8751	Athena	
31-47	8751-8752	,	
31-48	8753-8761	consider	
31-49	8762-8765	the	
31-50	8766-8775	following	
31-51	8776-8785	resources	
31-52	8785-8786	:	
31-53	8787-8791	Read	
31-54	8792-8795	the	
31-55	8796-8799	AWS	
31-56	8800-8803	Big	
31-57	8804-8808	Data	
31-58	8809-8813	blog	
31-59	8814-8818	post	
31-60	8819-8822	Top	
31-61	8823-8825	10	

#Text=Performance Tuning Tips for Amazon Athena Read other Athena posts in the AWS Big Data Blog Visit the Amazon Athena Forum Consult the Athena topics in the AWS Knowledge Center Contact AWS Support (in the AWS console, click Support, Support Center)
32-1	8826-8837	Performance	
32-2	8838-8844	Tuning	
32-3	8845-8849	Tips	
32-4	8850-8853	for	
32-5	8854-8860	Amazon	
32-6	8861-8867	Athena	
32-7	8868-8872	Read	
32-8	8873-8878	other	
32-9	8879-8885	Athena	
32-10	8886-8891	posts	
32-11	8892-8894	in	
32-12	8895-8898	the	
32-13	8899-8902	AWS	
32-14	8903-8906	Big	
32-15	8907-8911	Data	
32-16	8912-8916	Blog	
32-17	8917-8922	Visit	
32-18	8923-8926	the	
32-19	8927-8933	Amazon	
32-20	8934-8940	Athena	
32-21	8941-8946	Forum	
32-22	8947-8954	Consult	
32-23	8955-8958	the	
32-24	8959-8965	Athena	
32-25	8966-8972	topics	
32-26	8973-8975	in	
32-27	8976-8979	the	
32-28	8980-8983	AWS	
32-29	8984-8993	Knowledge	
32-30	8994-9000	Center	
32-31	9001-9008	Contact	
32-32	9009-9012	AWS	
32-33	9013-9020	Support	
32-34	9021-9022	(	
32-35	9022-9024	in	
32-36	9025-9028	the	
32-37	9029-9032	AWS	
32-38	9033-9040	console	
32-39	9040-9041	,	
32-40	9042-9047	click	
32-41	9048-9055	Support	
32-42	9055-9056	,	
32-43	9057-9064	Support	
32-44	9065-9071	Center	
32-45	9071-9072	)	

#Text=Javascript is disabled or is unavailable in your browser. To use the AWS Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions. Document Conventions Troubleshooting Code Samples, Service Quotas, and Previous JDBC Driver
33-1	9073-9083	Javascript	
33-2	9084-9086	is	
33-3	9087-9095	disabled	
33-4	9096-9098	or	
33-5	9099-9101	is	
33-6	9102-9113	unavailable	
33-7	9114-9116	in	
33-8	9117-9121	your	
33-9	9122-9129	browser	
33-10	9129-9130	.	
33-11	9131-9133	To	
33-12	9134-9137	use	
33-13	9138-9141	the	
33-14	9142-9145	AWS	
33-15	9146-9159	Documentation	
33-16	9159-9160	,	
33-17	9161-9171	Javascript	
33-18	9172-9176	must	
33-19	9177-9179	be	
33-20	9180-9187	enabled	
33-21	9187-9188	.	
33-22	9189-9195	Please	
33-23	9196-9201	refer	
33-24	9202-9204	to	
33-25	9205-9209	your	
33-26	9210-9219	browser's	
33-27	9220-9224	Help	
33-28	9225-9230	pages	
33-29	9231-9234	for	
33-30	9235-9247	instructions	
33-31	9247-9248	.	
33-32	9249-9257	Document	
33-33	9258-9269	Conventions	
33-34	9270-9285	Troubleshooting	
33-35	9286-9290	Code	
33-36	9291-9298	Samples	
33-37	9298-9299	,	
33-38	9300-9307	Service	
33-39	9308-9314	Quotas	
33-40	9314-9315	,	
33-41	9316-9319	and	
33-42	9320-9328	Previous	
33-43	9329-9333	JDBC	
33-44	9334-9340	Driver	

#Text=Did this page help you? - Yes Thanks for letting us know we're doing a good job! If you've got a moment, please tell us what we did right so we can do more of it. Did this page help you? - No Thanks for letting us know this page needs work. We're
34-1	9341-9344	Did	
34-2	9345-9349	this	
34-3	9350-9354	page	
34-4	9355-9359	help	
34-5	9360-9363	you	
34-6	9363-9364	?	
34-7	9365-9366	-	
34-8	9367-9370	Yes	
34-9	9371-9377	Thanks	
34-10	9378-9381	for	
34-11	9382-9389	letting	
34-12	9390-9392	us	
34-13	9393-9397	know	
34-14	9398-9403	we're	
34-15	9404-9409	doing	
34-16	9410-9411	a	
34-17	9412-9416	good	
34-18	9417-9420	job	
34-19	9420-9421	!	
34-20	9422-9424	If	
34-21	9425-9431	you've	
34-22	9432-9435	got	
34-23	9436-9437	a	
34-24	9438-9444	moment	
34-25	9444-9445	,	
34-26	9446-9452	please	
34-27	9453-9457	tell	
34-28	9458-9460	us	
34-29	9461-9465	what	
34-30	9466-9468	we	
34-31	9469-9472	did	
34-32	9473-9478	right	
34-33	9479-9481	so	
34-34	9482-9484	we	
34-35	9485-9488	can	
34-36	9489-9491	do	
34-37	9492-9496	more	
34-38	9497-9499	of	
34-39	9500-9502	it	
34-40	9502-9503	.	
34-41	9504-9507	Did	
34-42	9508-9512	this	
34-43	9513-9517	page	
34-44	9518-9522	help	
34-45	9523-9526	you	
34-46	9526-9527	?	
34-47	9528-9529	-	
34-48	9530-9532	No	
34-49	9533-9539	Thanks	
34-50	9540-9543	for	
34-51	9544-9551	letting	
34-52	9552-9554	us	
34-53	9555-9559	know	
34-54	9560-9564	this	
34-55	9565-9569	page	
34-56	9570-9575	needs	
34-57	9576-9580	work	
34-58	9580-9581	.	
34-59	9582-9587	We're	
