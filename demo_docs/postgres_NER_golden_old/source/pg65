Parallel hints - Developer Guide| Alibaba Cloud Documentation Center Document Center PolarDB-O Cloud Native Database Release notes Product Introduction Overview Architecture PolarDB-O terms Limits
Benefits Pricing and Purchase Billable items Billing methods Overview Purchase procedures Purchase a storage plan Change the billing method from subscription to pay-as-you-go Switch the billing method from pay-as-you-go to subscription
Instructions for purchase Manage storage plans View the deducted capacity of a storage plan Renew or upgrade a storage plan Expiration or overdue payments Renew subscription clusters Manual renewal Auto-renewal View bills Billing rules of PolarDB for MySQL
Storage pricing Billing rules of data backups that exceed the free quot Billing rules of SQL Explorer (optional) Configuration change fees FAQ FAQ Quick Start Migrate or Synchronize Data Overview
Migrate data from a self-managed Oracle database to a PolarDB-O cluster Configure one-way data synchronization between PolarDB-O clusters Management Guide Overview Comparison with Oracle on database management Pending events Configure a whitelist for a cluster Connect to PolarDB
View or apply for an endpoint Modify or delete an endpoint Connect to a database cluster Cluster endpoint PolarProxy features PolarDB-O consistency levels Read/write splitting Transaction splitting Create a custom cluster endpoint
Modify a cluster endpoint Delete a custom cluster endpoint Private domain names Cluster management Create a PolarDB-O cluster Storage plan Change the specifications of a cluster Add or remove a read-only node Set a maintenance window Restart nodes
Upgrade the minor version Release a cluster Deploy a cluster across zones and change the primary zone Perform a switchover Account management Account overview Register and log on to an Alibaba Cloud account Create and authorize a RAM user Manage database accounts
Create database accounts DBLink Overview Create a database link from PolarDB-O to PolarDB-O Create a database link from PolarDB-O to Oracle Use a database link to query data across databases Delete a database link Databases
Backup and restoration Back up data Restore data Cluster recycle bin FAQ about the backup feature View the database storage usage Data Security and Encryption Configure SSL encryption Configure TDE Diagnostics and optimization
Performance monitoring Performance insight Manage alert rules SQL Explorer Configuration parameters polar_comp_redwood_date polar_comp_redwood_raw_names polar_comp_redwood_strings
polar_comp_stmt_level_tx polar_create_table_with_full_replica_identity Custom parameters Configure cluster parameters Clone a cluster SQL firewall Developer Guide Oracle compatibility Connect to a PolarDB-O cluster
Clients and Drivers Download clients and drivers Use client tools JDBC OCI ODBC .NET Use PHP to connect to a PolarDB cluster compatible with Oracle Basic operations Create a user Create a database
Create a schema Create a table Delete a table Create a view Create a materialized view Create an index Create and use a sequence Create and use a synonym Data types Data types Numeric type Character type
Date and time type Boolean type Binary data XML type VARCHAR2 Implicit conversion rules Operators Arithmetic operators Logical operators Comparison operators Partition tables Overview
Interval range partitioning Interval range partitioning Switch between range partitioning and interval range partitioning Subpartitioning Introduction Subpartition templates Partition Pruning Partition pruning Example - partition pruning
Handle stray values in a list- or range-partitioned table Specify multiple partition key columns in a RANGE partitioned table Command list for partitioned tables Views for partitioned tables External tables Read and write foreign data files by using oss_fdw Temporary tables Global temporary tables
Built-in packages Overview DBMS_ALERT DBMS_APPLICATION_INFO DBMS_AQ DBMS_AQADM DBMS_CRYPTO DBMS_LOB DBMS_LOCK
DBMS_MVIEW DBMS_OBFUSCATION_TOOLKIT DBMS_OUTPUT DBMS_PIPE DBMS_PROFILER DBMS_RANDOM DBMS_RLS DBMS_SESSION
DBMS_SQL DBMS_STATS DBMS_UTILITY UTL_ENCODE UTL_RAW UTL_URL Built-in functions Mathematical functions Date/Time functions and operators Overview
MONTHS_BETWEEN NEW_TIME ADD_MONTHS CURRENT DATE/TIME TRUNC ROUND EXTRACT NEXT_DAY TZ_OFFSET
String functions Pattern matching string functions Overview REGEXP_COUNT REGEXP_SUBSTR REGEXP_INSTR Use the LIKE operator for pattern matching Functions for formatting data types
Sequence manipulation functions Conditional expressions TO_SINGLE_BYTE and TO_MULTI_BYTE functions Aggregate functions Analytic function RATIO_TO_REPORT Subquery expressions ANYDATA
GROUP_ID dblink_ora Overview of dblink_ora dblink_ora functions and procedures Call dblink_ora functions LNNVL function FROM_TZ function SYS_CONTEXT
Oracle catalog views ALL_ALL_TABLES ALL_CONS_COLUMNS ALL_CONSTRAINTS ALL_DB_LINKS ALL_DIRECTORIES ALL_IND_COLUMNS
ALL_INDEXES ALL_JOBS ALL_OBJECTS ALL_PART_KEY_COLUMNS ALL_PART_TABLES ALL_QUEUES ALL_QUEUE_TABLES
ALL_SEQUENCES ALL_SOURCE ALL_SUBPART_KEY_COLUMNS ALL_SYNONYMS ALL_TAB_COLS ALL_TAB_COLUMNS
ALL_TAB_PARTITIONS ALL_TAB_SUBPARTITIONS ALL_TABLES ALL_TRIGGERS ALL_TYPES ALL_USERS ALL_VIEW_COLUMNS
ALL_VIEWS DBA_ALL_TABLES DBA_CONS_COLUMNS DBA_CONSTRAINTS DBA_DB_LINKS DBA_DIRECTORIES DBA_IND_COLUMNS
DBA_INDEXES DBA_JOBS DBA_OBJECTS DBA_PART_KEY_COLUMNS DBA_PART_TABLES DBA_PROFILES DBA_QUEUES
DBA_QUEUE_TABLES DBA_ROLE_PRIVS DBA_ROLES DBA_SEQUENCES DBA_SOURCE DBA_SUBPART_KEY_COLUMNS DBA_SYNONYMS
DBA_TAB_COLS DBA_TAB_COLUMNS DBA_TAB_PARTITIONS DBA_TAB_SUBPARTITIONS DBA_TABLES DBA_TRIGGERS DBA_TYPES
DBA_USERS DBA_VIEW_COLUMNS DBA_VIEWS PRODUCT_COMPONENT_VERSION USER_ALL_TABLES USER_CONS_COLUMNS
USER_CONSTRAINTS USER_DB_LINKS USER_IND_COLUMNS USER_INDEXES USER_JOBS USER_OBJECTS USER_PART_KEY_COLUMNS
USER_PART_TABLES USER_QUEUES USER_QUEUE_TABLES USER_ROLE_PRIVS USER_SEQUENCES USER_SOURCE USER_SUBPART_KEY_COLUMNS
USER_SYNONYMS USER_TAB_COLS USER_TAB_COLUMNS USER_TAB_PARTITIONS USER_TAB_SUBPARTITIONS USER_TABLES
USER_TRIGGERS USER_TYPES USER_USERS USER_VIEW_COLUMNS USER_VIEWS V$VERSION Views of I/O statistics and I/O latency distribution Triggers
Overview of triggers Types of triggers Create a trigger Trigger variables Transactions and exceptions Trigger examples BEFORE statement-level trigger AFTER statement-level trigger BEFORE row-level trigger AFTER row-level trigger
Packages Package components Package components Package specification syntax Package body syntax Create a package Create a package specification Create a package body Use a package Use packages with user-defined types Delete a package
Stored Procedure Language Overview Basic SPL elements Character sets Case sensitivity Qualifiers Constants User-defined PL/SQL subtypes Identifiers SPL programs Overview SPL block structures
Anonymous blocks Call a function Call a procedure Delete a procedure Create a function Delete a function Create a procedure Compilation errors in procedures and functions Procedure and function parameters Overview Positional and named parameter notation
Parameter modes Use default values in parameters Subprograms - subprocedures and subfunctions Overview Create a subprocedure Create a subfunction Block relationships Invoke subprograms Use forward declarations
Overload subprograms Access subprogram variables Program security EXECUTE privileges Name resolution of database objects Database object privileges Rights of definers and invokers Security examples Variable declarations Use %TYPE in variable declarations
Use %ROWTYPE in record declarations User-defined record types and record variables Declare a variable Basic statements  Assignment SELECT INTO INSERT UPDATE DELETE Use the RETURNING INTO clause
Obtain the result status Control structures RETURN statement GOTO statement CASE expression CASE statement Loops Exception handling User-defined exceptions RAISE_APPLICATION_ERROR PRAGMA EXCEPTION_INIT
IF statements IF-THEN IF-THEN-ELSE IF-THEN-ELSE IF IF-THEN-ELSIF-ELSE Transaction control Overview COMMIT ROLLBACK
PRAGMA AUTONOMOUS_TRANSACTION Dynamic SQL Static cursors Overview Declare a cursor Open a cursor Fetch rows from a cursor Close a cursor Use %ROWTYPE with cursors
Cursor attributes Parameterized cursors Cursor FOR loop REF CURSOR and cursor variable REF CURSOR overview Declare a cursor variable Open a cursor variable Fetch rows from a cursor variable
Close a cursor variable Usage limits Examples Dynamic queries with REF CURSORs Collections Overview Associative arrays Nested tables Varrays Collection methods COUNT DELETE EXISTS
EXTEND FIRST LAST LIMIT NEXT PRIOR TRIM Work with collections TABLE() Use the MULTISET UNION operator Use the FORALL statement
Use the BULK COLLECT clause Errors and messages Object types and objects Basic object concepts Object type components Create an object type Create an object instance Reference an object Delete an object type Plugins Supported extensions Index Advisor
Use the UTL_I18N plug-in PG_CRON polar_utility Use the pldebugger plug-in Use the pg_roaringbitmap plug-in SQL Commands Overview ALTER INDEX ALTER PROCEDURE
ALTER PROFILE ALTER QUEUE ALTER QUEUE TABLE ALTER ROLE ALTER ROLE… IDENTIFIED BY ALTER SEQUENCE ALTER SESSION
ALTER TABLE ALTER TABLESPACE ALTER TABLE...ADD PARTITION ALTER TABLE...ADD SUBPARTITION ALTER TABLE... DROP PARTITION
ALTER TABLE... DROP SUBPARTITION ALTER TABLE...EXCHANGE PARTITION ALTER TABLE…MERGE PARTITION ALTER TABLE...MERGE SUBPARTITION
ALTER TABLE...MOVE PARTITION ALTER TABLE...RENAME PARTITION ALTER TABLE...SPLIT PARTITION ALTER TABLE...SPLIT SUBPARTITION
ALTER TABLE...TRUNCATE PARTITION ALTER TABLE...TRUNCATE SUBPARTITION ALTER TRIGGER ALTER USER… IDENTIFIED BY CALL COMMENT COMMIT
CREATE DATABASE CREATE FUNCTION CREATE INDEX CREATE MATERIALIZED VIEW CREATE PACKAGE CREATE PACKAGE BODY CREATE PROCEDURE
CREATE QUEUE CREATE QUEUE TABLE CREATE ROLE CREATE SCHEMA CREATE SEQUENCE CREATE SYNONYM CREATE TABLE CREATE TABLE AS
CREATE TABLE... PARTITION BY CREATE TABLE ... PARTITION BY HASH CREATE TRIGGER CREATE TYPE CREATE TYPE BODY CREATE VIEW DELETE
DROP FUNCTION DROP INDEX DROP PACKAGE DROP PROCEDURE DROP PROFILE DROP QUEUE DROP QUEUE TABLE DROP SYNONYM DROP SEQUENCE
DROP TABLE DROP TRIGGER DROP TYPE DROP USER DROP VIEW EXEC GRANT GRANT on database objects INSERT LOCK Merge Into
PIVOT REVOKE ROLLBACK ROLLBACK TO SAVEPOINT SAVEPOINT SELECT SELECT SELECT list CONNECT BY clause DISTINCT clause
FOR UPDATE clause FROM clause GROUP BY clause HAVING clause INTERSECT clause MINUS clause ORDER BY clause UNION clause WHERE clause Query a specified partition
SET CONSTRAINTS SET ROLE SET TRANSACTION TRUNCATE TRUNCATE TABLE UPDATE SQL tutorial Get started Overview Create a table Use rows to populate a table
Query a table Joins between tables Aggregate functions Updates Deletions Sample database Install a sample database Advanced concepts Views Foreign keys Pseudo column ROWNUM Synonyms
Hierarchical queries Define parent-child relationships Select root nodes Organization tree in the sample application Node level Order siblings Use CONNECT_BY_ROOT to retrieve a root node Use SYS_CONNECT_BY_PATH to retrieve a path
Overview Optimizer hints Overview Default optimization mode Access Method Hints Specify a join order Joining Relations Hint Global hints Use the APPEND optimizer hint Parallel hints
Conflicting hints Profiles Overview Create a new profile Alter a profile Drop a profile Back up profile management functions Multidimensional analysis Overview ROLLUP extensions CUBE extensions GROUPING SETS extension
GROUPING function GROUPING_ID function Performance Tuning Guide Architecture of PolarDB-O Main components Internal architecture File storage Heap table structure Query mechanism Garbage collection mechanism Locate performance issues View statistics
Use the performance insight feature Optimize cluster performance Parameters Specify parameters Optimize SQL statements Manage indexes B-tree indexes Hash indexes GIN indexes GiST index BRIN indexes
Execution plan analysis EXPLAIN syntax Output of EXPLAIN statements Physical optimization Cost-related concepts Cost calculation Best practices for performance optimization High CPU usage High I/O Network issues Optimize SQL statements
Spatio-temporal Database Overview Models Grid model Vector pyramid Path model Trajectory model Point cloud model Raster model Geometry model Advanced usage Enable spatio-temporal parallel query Enable GPU-accelerated computing
Spatial-temporal object storage optimization Feature signature-based storage optimization for large spatio-temporal objects ST_SetTypeStorage Raster SQL reference Basic concepts Parallel operations Raster creation ST_CreateRast Import and export
ST_AsImage ST_AsPNG ST_AsJPEG ST_ExportTo ST_ImportFrom Pyramid operations ST_BuildPyramid ST_deletePyramid ST_BestPyramidLevel
Coordinate system conversion ST_Rast2WorldCoord ST_World2RastCoord Pixel value operations ST_ClipDimension ST_AddZ ST_Clip ST_ClipToRast
ST_Values ST_Update S​T_MosaicFrom S​T_MosaicTo Overview operations ST_UpdateOverview ST_BuildOverview S​T_EraseOverview DEM operations
ST_Flow_direction ST_Overflow ST_Slope ST_Hillshade ST_Aspect Attribute query and update ST_Name ST_SetName ST_MetaData ST_Width
ST_Height ST_NumBands ST_Value ST_RasterID ST_CellDepth ST_CellType ST_InterleavingType ST_TopPyramidLevel ST_Extent
ST_ConvexHull ST_Envelope ST_Srid ST_SetSrid ST_ScaleX ST_ScaleY ST_SetScale ST_SkewX ST_SkewY ST_SetSkew
ST_UpperLeftX ST_UpperLeftY ST_SetUpperLeft ST_PixelWidth ST_PixelHeight ST_Georeference ST_IsGeoreferenced ST_UnGeoreference
ST_SetGeoreference ST_NoData ST_SetNoData ST_ColorTable ST_SetColorTable ST_Statistics ST_SetStatistics ST_SummaryStats ST_ColorInterp
ST_SetColorInterp ST_Histogram ST_SetHistogram ST_BuildHistogram ST_StatsQuantile ST_Quantile ST_MD5Sum ST_SetMD5Sum ST_XMin
ST_YMin ST_XMax ST_YMax ST_ChunkHeight ST_ChunkWidth ST_ChunkBands ST_MetaItems ST_SetMetaData ST_BeginDateTime
ST_EndDateTime ST_SetBeginDateTime ST_SetEndDateTime ST_DateTime ST_SetDateTime Algebra and Analysis Functions ST_Reclassify ST_MapAlgebra
Raster Image Processing ST_SubRaster ST_Transform ST_Rescale ST_Resize Operators Equal to operator (=) Greater than operator (>) Less than operator (<) Greater than or equal to operator (>=)
Less than or equal to operator (<=) Functions for Identifying Spatial Relationships ST_Intersects ST_Contains ST_ContainsProperly ST_Covers ST_CoveredBy ST_Disjoint ST_overlaps
ST_Touches ST_Within Auxiliary functions ST_AKId ST_SetAccessKey ST_SetAKId ST_SetAKSecret ST_CheckGPU Variables ganos.parallel.transaction
ganos.parallel.degree ganos.raster.calculate_md5 ganos.raster.md5sum_chunk_size ganos.raster.mosaic_must_same_nodata SpatialRef SQL reference ST_SrEqual
ST_SrReg ST_SrFromEsriWkt Point cloud SQL reference Constructors ST_makePatch ST_makePoint ST_Patch Attribute functions ST_summary ST_numPoints
ST_asText ST_get ST_pcID Object operations ST_boundingDiagonalGeometry ST_compress ST_explode ST_patchAvg ST_envelopeGeometry ST_filterGreaterThan
ST_filterLessThan ST_filterEquals ST_filterBetween ST_isSorted ST_patchMax ST_patchMin ST_patchAvg ST_patchMax ST_patchMin ST_pointN
ST_sort ST_range ST_setPcid ST_transform ST_unCompress ST_union OGC WKB operations ST_envelopeAsBinary ST_asBinary ST_boundingDiagonalAsBinary
Spatial relationship judgment ST_intersects Spatial processing ST_intersection Trajectory SQL reference Terms Constructors Overview ST_append ST_makeTrajectory Editing and processing functions
ST_attrDeduplicate ST_Compress ST_CompressSED ST_deviation ST_sort Attribute metadata ST_attrNullable ST_attrType ST_attrDefinition
ST_attrSize ST_attrLength ST_attrName Event functions ST_eventTypes ST_addEvent ST_eventTimes ST_eventTime ST_eventType Attribute functions
ST_attrNullFilter ST_attrIntMin ST_attrIntAverage ST_leafType ST_trajAttrsAsInteger ST_attrFloatMax ST_trajAttrsAsBool
ST_startTime ST_trajAttrsAsText ST_attrFloatMin ST_trajAttrs ST_attrNotNullFilter ST_velocityAtTime ST_samplingInterval
ST_trajectorySpatial ST_subTrajectory ST_leafCount ST_timeToDistance ST_duration ST_trajAttrsMeanMax ST_accelerationAtTime ST_trajectoryTemporal
ST_endTime ST_pointAtTime ST_cumulativeDistanceAtTime ST_timeAtPoint ST_attrFloatFilter ST_subTrajectorySpatial ST_timeAtDistance
ST_trajAttrsAsTimestamp ST_trajAttrsAsDouble ST_timeAtCumulativeDistance ST_attrTimestampFilter ST_attrIntMax ST_attrFloatAverage
ST_attrIntFilter Functions to process bounding boxes ST_MakeBox ST_MakeBox{Z|T|2D|2DT|3D|3DT} ST_BoxndfToGeom ST_Has{xy|z|t}
ST_{X|Y|Z|T}Min ST_{X|Y|Z|T}Max ST_ExpandSpatial Operators to process bounding boxes Basic concepts INTERSECT operators INCLUDE operators INCLUDED operators Spatial relationship judgment
ST_intersects ST_equals ST_distanceWithin Spatial processing ST_difference ST_intersection Spatial statistics ST_nearestApproachDistance ST_nearestApproachPoint Spatio-temporal relationship judgment
ST_intersects ST_equals ST_distanceWithin ST_durationWithin ST_{Z|T|2D|2DT|3D|3DT}Intersects ST_{2D|2DT|3D|3DT}Intersects_IndexLeft
ST_{2D|2DT|3D|3DT}DWithin ST_{2D|2DT|3D|3DT}DWithin_IndexLeft ST_{T|2D|2DT|3D|3DT}Contains ST_{T|2D|2DT|3D|3DT}Within
Spatio-temporal processing ST_intersection Spatio-temporal statistics ST_nearestApproachPoint ST_nearestApproachDistance Distance measurement ST_euclideanDistance ST_length ST_mdistance
Similarity analysis ST_lcsSimilarity ST_lcsDistance ST_lcsSubDistance ST_JaccardSimilarity Indexing GiST indexing TrajGiST indexing Variables
ganos.trajectory.attr_string_length GeomGrid SQL reference Usage notes Functions for output ST_AsText ST_AsBinary ST_AsGeometry ST_AsBox Functions for input ST_GridFromText
ST_GridFromBinary Functions to query spatial relationships ST_Intersects ST_Contains ST_Within Operators Functions to compute grids ST_AsGrid Geometry Pyramid SQL reference Usage notes
Functions to build pyramids ST_BuildPyramid Functions to delete pyramids ST_DeletePyramid Functions to view pyramids ST_Tile ST_AsPng Map services Publish geometry data Publish raster data
Overview Desktop applications Use OpenJump to access Ganos data Use QGIS to access Ganos data Use uDig to access Ganos data FAQ Load raster data Load vector data Trajectory FAQ
Best practice Trajectory best practices API Reference API overview Use RAM for resource authorization RAM role linked to Apsara PolarDB Call methods Common parameters Request structures Signatures Regions DescribeRegions
Cluster management CreateDBCluster DeleteDBCluster DescribeDBClusters DescribeDBClusterAttribute DescribeTasks ModifyDBClusterMaintainTime ModifyDBClusterDescription
Deployment architecture ModifyDBClusterPrimaryZone FailoverDBCluster Renewal management ModifyAutoRenewAttribute DescribeAutoRenewAttribute DescribeDBClusterAvailableResources
Data Security Whitelist management DescribeDBClusterAccessWhitelist ModifyDBClusterAccessWhitelist SSL encryption DescribeDBClusterSSL ModifyDBClusterSSL Node management
CreateDBNodes ModifyDBNodeClass RestartDBNode DeleteDBNodes Cluster parameters ModifyDBClusterParameters DescribeDBClusterParameters Connection points
CreateDBEndpointAddress CreateDBClusterEndpoint DescribeDBClusterEndpoints ModifyDBClusterEndpoint ModifyDBEndpointAddress DeleteDBEndpointAddress DeleteDBClusterEndpoint
Logs DescribeDBClusterAuditLogCollector ModifyDBClusterAuditLogCollector Account management CreateAccount DescribeAccounts ModifyAccountDescription
GrantAccountPrivilege RevokeAccountPrivilege DeleteAccount CheckAccountName ModifyAccountPassword Database management CreateDatabase DescribeDatabases DeleteDatabase
CheckDBName DescribeDBInitializeVariable DBLink CreateDBLink DescribeDBLinks DeleteDBLink Backup management CreateBackup DeleteBackup DescribeBackups
DescribeBackupTasks DescribeBackupLogs DescribeDetachedBackups DescribeDBClustersWithBackups Backup policy DescribeBackupPolicy DescribeLogBackupPolicy
ModifyBackupPolicy ModifyLogBackupPolicy Tag management TagResources ListTagResources UntagResources Pending events DescribePendingMaintenanceAction DescribePendingMaintenanceActions
ModifyPendingMaintenanceAction Monitoring management DescribeDBNodePerformance DescribeDBClusterMonitor DescribeDBClusterPerformance ModifyDBClusterMonitor Appendixes Client error codes Cluster status
Character set tables Performance metric monitoring SDK Reference Download the SDK FAQ All Products Search Document Center PolarDB-O Cloud Native Database Developer Guide SQL tutorial Optimizer hints
Parallel hints all-products-head This Product This Product All Products Parallel hints Document Center Parallel hints Last Updated: Jan 05, 2021 The PARALLEL optimizer hint is used to force parallel scanning.The NO_PARALLEL optimizer
hint prevents usage of a parallel scan. SynopsisPARALLEL (table [ parallel_degree | DEFAULT ]) NO_PARALLEL (table) Description Parallel scanning allows multiple background workers to simultaneously scan a table in a specified query. Compared with other methods such as a sequential scan, this
scan provides improved performance. Parameters Parameter Description table The table in which a parallel hint is used. parallel_degree | DEFAULT The value of the parallel_degree parameter is a positive integer that specifies the
desired number of workers to be used in a parallel scan. If this parameter is set, the smaller value between this parameter and the configuration parameter max_parallel_workers_per_gather is used as the planned number of workers. For more information about the max_parallel_workers_per_gather parameter, visit max_parallel_workers_per_gather.
If DEFAULT is set, the maximum possible parallel degree is used. If both parallel_degree and DEFAULT are omitted, the query optimizer determines the parallel degree. In this case, if the table parameter has been set with the parallel_workers storage parameter, the value of parallel_workers is used as the parallel degree. Otherwise,
the optimizer uses the maximum possible parallel degree specified by DEFAULT. For more information about the parallel_workers storage parameter, visit parallel_workers. Regardless of the circumstance, the parallel degree never exceeds the value of max_parallel_workers_per_gather. Examples The following configuration parameter settings are valid:SHOW max_worker_processes;
max_worker_processes ---------------------- (1 row) SHOW max_parallel_workers_per_gather; max_parallel_workers_per_gather
--------------------------------- (1 row)The following example shows the default scan on the pgbench_accounts table. A sequential scan is shown in the query plan. SET trace_hints TO on; EXPLAIN SELECT * FROM pgbench_accounts;
QUERY PLAN ---------------------------------------------------------------------------
Seq Scan on pgbench_accounts (cost=0.00..53746.15 rows=2014215 width=97) (1 row)The following example uses the PARALLEL hint. In the query plan, the Gather node that launches the background workers specifies that two workers are planned to be used.
Note If trace_hints is set to on, the INFO: [HINTS] lines are displayed to indicate that PARALLEL has been supported by pgbench_accounts and other hints. For the remaining examples, these lines are not displayed. These examples show the same output, where trace_hints is reset to off.
EXPLAIN SELECT /*+ PARALLEL(pgbench_accounts) */ * FROM pgbench_accounts; INFO: [HINTS] SeqScan of [pgbench_accounts] rejected due to PARALLEL hint. INFO: [HINTS] PARALLEL on [pgbench_accounts] accepted.
INFO: [HINTS] Index Scan of [pgbench_accounts].[pgbench_accounts_pkey] rejected due to PARALLEL hint. QUERY PLAN
----------------------------------------------------------------------------------------- Gather (cost=1000.00..244418.06 rows=2014215 width=97) Workers Planned: 2 Parallel Seq Scan on pgbench_accounts (cost=0.00..41996.56 rows=839256 width=97)
(3 rows)The following example shows an increased value of max_parallel_workers_per_gather:SET max_parallel_workers_per_gather TO 6; SHOW max_parallel_workers_per_gather; max_parallel_workers_per_gather ---------------------------------
(1 row)The same query on pgbench_accounts is used again with no specified parallel degree in the PARALLEL hint. The number of planned workers has been determined by the optimizer and increased to 4. EXPLAIN SELECT /*+ PARALLEL(pgbench_accounts) */ * FROM pgbench_accounts;
QUERY PLAN -----------------------------------------------------------------------------------------
Gather (cost=1000.00..241061.04 rows=2014215 width=97) Workers Planned: 4 Parallel Seq Scan on pgbench_accounts (cost=0.00..38639.54 rows=503554 width=97)
(3 rows)A value of 6 is specified for the parallel degree parameter of the PARALLEL hint. The value is returned as the planned number of workers in the following example: EXPLAIN SELECT /*+ PARALLEL(pgbench_accounts 6) */ * FROM pgbench_accounts; QUERY PLAN
----------------------------------------------------------------------------------------- Gather (cost=1000.00..239382.52 rows=2014215 width=97) Workers Planned: 6 Parallel Seq Scan on pgbench_accounts (cost=0.00..36961.03 rows=335702 width=97)
(3 rows)The same query is used with the DEFAULT setting for the parallel degree. The results indicate that the maximum allowable number of workers is planned. EXPLAIN SELECT /*+ PARALLEL(pgbench_accounts DEFAULT) */ * FROM pgbench_accounts; QUERY PLAN
----------------------------------------------------------------------------------------- Gather (cost=1000.00..239382.52 rows=2014215 width=97) Workers Planned: 6 Parallel Seq Scan on pgbench_accounts (cost=0.00..36961.03 rows=335702 width=97)
(3 rows)The pgbench_accounts table is modified. In this table, the parallel_workers storage parameter is set to 3. Note This format in which the ALTER TABLE statement sets the parallel_workers parameter is not compatible with Oracle databases. The parallel_workers parameter is set by the PSQL \d+ statement.ALTER TABLE pgbench_accounts SET (parallel_workers=3);
\d+ pgbench_accounts Table "public.pgbench_accounts" Column Type | Modifiers | Storage | Stats target | Description
----------+---------------+-----------+----------+--------------+------------- aid | integer | not null | plain bid | integer | plain abalance | integer | plain filler | character(84) | | extended | Indexes:
"pgbench_accounts_pkey" PRIMARY KEY, btree (aid) Options: fillfactor=100, parallel_workers=3If the PARALLEL hint is provided with no parallel degree, the returned number of planned workers is the value of the parallel_workers parameter.
EXPLAIN SELECT /*+ PARALLEL(pgbench_accounts) */ * FROM pgbench_accounts; QUERY PLAN -----------------------------------------------------------------------------------------
Gather (cost=1000.00..242522.97 rows=2014215 width=97) Workers Planned: 3 Parallel Seq Scan on pgbench_accounts (cost=0.00..40101.47 rows=649747 width=97)
(3 rows)The parallel degree value or DEFAULT in the PARALLEL hint overwrites the parallel_workers setting. The following example shows the NO_PARALLEL hint. If trace_hints is set to on, the INFO: [HINTS] message is displayed to indicate that the parallel scan has been rejected due to the NO_PARALLEL hint.
EXPLAIN SELECT /*+ NO_PARALLEL(pgbench_accounts) */ * FROM pgbench_accounts; INFO: [HINTS] Parallel SeqScan of [pgbench_accounts] rejected due to NO_PARALLEL hint. QUERY PLAN
--------------------------------------------------------------------------- Seq Scan on pgbench_accounts (cost=0.00..53746.15 rows=2014215 width=97) (1 row) Previous: Use the APPEND optimizer hint Next: Conflicting hints
