#FORMAT=WebAnno TSV 3.3


#Text=Some SQL Tricks of an Application DBA | Haki Benita Haki Benita About Subscribe 27 July 2020 SQL, Performance Some SQL Tricks of an Application DBA Non-trivial tips for database development
1-1	0-4	Some	
1-2	5-8	SQL	
1-3	9-15	Tricks	
1-4	16-18	of	
1-5	19-21	an	
1-6	22-33	Application	
1-7	34-37	DBA	
1-8	38-39	|	
1-9	40-44	Haki	
1-10	45-51	Benita	
1-11	52-56	Haki	
1-12	57-63	Benita	
1-13	64-69	About	
1-14	70-79	Subscribe	
1-15	80-82	27	
1-16	83-87	July	
1-17	88-92	2020	
1-18	93-96	SQL	
1-19	96-97	,	
1-20	98-109	Performance	
1-21	110-114	Some	
1-22	115-118	SQL	
1-23	119-125	Tricks	
1-24	126-128	of	
1-25	129-131	an	
1-26	132-143	Application	
1-27	144-147	DBA	
1-28	148-159	Non-trivial	
1-29	160-164	tips	
1-30	165-168	for	
1-31	169-177	database	
1-32	178-189	development	

#Text=When I started my career in development, my first job was a DBA. Back then, before AWS RDS, Azure, Google Cloud and the rest of them cloud services, there were two types of DBAs: The Infrastructure DBA was in charge of setting up the database, configuring the storage and taking care of backups and replication. After setting up the database, the infrastructure DBA would pop up from time to time and do some "instance tuning", things like sizing caches.
2-1	190-194	When	
2-2	195-196	I	
2-3	197-204	started	
2-4	205-207	my	
2-5	208-214	career	
2-6	215-217	in	
2-7	218-229	development	
2-8	229-230	,	
2-9	231-233	my	
2-10	234-239	first	
2-11	240-243	job	
2-12	244-247	was	
2-13	248-249	a	
2-14	250-253	DBA	
2-15	253-254	.	
2-16	255-259	Back	
2-17	260-264	then	
2-18	264-265	,	
2-19	266-272	before	
2-20	273-276	AWS	
2-21	277-280	RDS	
2-22	280-281	,	
2-23	282-287	Azure	
2-24	287-288	,	
2-25	289-295	Google	
2-26	296-301	Cloud	
2-27	302-305	and	
2-28	306-309	the	
2-29	310-314	rest	
2-30	315-317	of	
2-31	318-322	them	
2-32	323-328	cloud	
2-33	329-337	services	
2-34	337-338	,	
2-35	339-344	there	
2-36	345-349	were	
2-37	350-353	two	
2-38	354-359	types	
2-39	360-362	of	
2-40	363-367	DBAs	
2-41	367-368	:	
2-42	369-372	The	
2-43	373-387	Infrastructure	
2-44	388-391	DBA	
2-45	392-395	was	
2-46	396-398	in	
2-47	399-405	charge	
2-48	406-408	of	
2-49	409-416	setting	
2-50	417-419	up	
2-51	420-423	the	
2-52	424-432	database	
2-53	432-433	,	
2-54	434-445	configuring	
2-55	446-449	the	
2-56	450-457	storage	
2-57	458-461	and	
2-58	462-468	taking	
2-59	469-473	care	
2-60	474-476	of	
2-61	477-484	backups	
2-62	485-488	and	
2-63	489-500	replication	
2-64	500-501	.	
2-65	502-507	After	
2-66	508-515	setting	
2-67	516-518	up	
2-68	519-522	the	
2-69	523-531	database	
2-70	531-532	,	
2-71	533-536	the	
2-72	537-551	infrastructure	
2-73	552-555	DBA	
2-74	556-561	would	
2-75	562-565	pop	
2-76	566-568	up	
2-77	569-573	from	
2-78	574-578	time	
2-79	579-581	to	
2-80	582-586	time	
2-81	587-590	and	
2-82	591-593	do	
2-83	594-598	some	
2-84	599-600	"	
2-85	600-608	instance	
2-86	609-615	tuning	
2-87	615-616	"	
2-88	616-617	,	
2-89	618-624	things	
2-90	625-629	like	
2-91	630-636	sizing	
2-92	637-643	caches	
2-93	643-644	.	

#Text=The Application DBA got a clean database from the infrastructure DBA, and was in charge of schema design: creating tables, indexes, constraints, and tuning SQL. The application DBA was also the one who implemented ETL processes and data migrations. In teams that used stored procedures, the application DBA would maintain those as well. Application DBAs were usually part of the development team. They would possess deep domain knowledge so normally they would work on just one or two projects. Infrastructure DBAs would usually be part of some IT team, and would work on many projects simultaneously. I'm an Application DBA
3-1	645-648	The	
3-2	649-660	Application	
3-3	661-664	DBA	
3-4	665-668	got	
3-5	669-670	a	
3-6	671-676	clean	
3-7	677-685	database	
3-8	686-690	from	
3-9	691-694	the	
3-10	695-709	infrastructure	
3-11	710-713	DBA	
3-12	713-714	,	
3-13	715-718	and	
3-14	719-722	was	
3-15	723-725	in	
3-16	726-732	charge	
3-17	733-735	of	
3-18	736-742	schema	
3-19	743-749	design	
3-20	749-750	:	
3-21	751-759	creating	
3-22	760-766	tables	
3-23	766-767	,	
3-24	768-775	indexes	
3-25	775-776	,	
3-26	777-788	constraints	
3-27	788-789	,	
3-28	790-793	and	
3-29	794-800	tuning	
3-30	801-804	SQL	
3-31	804-805	.	
3-32	806-809	The	
3-33	810-821	application	
3-34	822-825	DBA	
3-35	826-829	was	
3-36	830-834	also	
3-37	835-838	the	
3-38	839-842	one	
3-39	843-846	who	
3-40	847-858	implemented	
3-41	859-862	ETL	
3-42	863-872	processes	
3-43	873-876	and	
3-44	877-881	data	
3-45	882-892	migrations	
3-46	892-893	.	
3-47	894-896	In	
3-48	897-902	teams	
3-49	903-907	that	
3-50	908-912	used	
3-51	913-919	stored	
3-52	920-930	procedures	
3-53	930-931	,	
3-54	932-935	the	
3-55	936-947	application	
3-56	948-951	DBA	
3-57	952-957	would	
3-58	958-966	maintain	
3-59	967-972	those	
3-60	973-975	as	
3-61	976-980	well	
3-62	980-981	.	
3-63	982-993	Application	
3-64	994-998	DBAs	
3-65	999-1003	were	
3-66	1004-1011	usually	
3-67	1012-1016	part	
3-68	1017-1019	of	
3-69	1020-1023	the	
3-70	1024-1035	development	
3-71	1036-1040	team	
3-72	1040-1041	.	
3-73	1042-1046	They	
3-74	1047-1052	would	
3-75	1053-1060	possess	
3-76	1061-1065	deep	
3-77	1066-1072	domain	
3-78	1073-1082	knowledge	
3-79	1083-1085	so	
3-80	1086-1094	normally	
3-81	1095-1099	they	
3-82	1100-1105	would	
3-83	1106-1110	work	
3-84	1111-1113	on	
3-85	1114-1118	just	
3-86	1119-1122	one	
3-87	1123-1125	or	
3-88	1126-1129	two	
3-89	1130-1138	projects	
3-90	1138-1139	.	
3-91	1140-1154	Infrastructure	
3-92	1155-1159	DBAs	
3-93	1160-1165	would	
3-94	1166-1173	usually	
3-95	1174-1176	be	
3-96	1177-1181	part	
3-97	1182-1184	of	
3-98	1185-1189	some	
3-99	1190-1192	IT	
3-100	1193-1197	team	
3-101	1197-1198	,	
3-102	1199-1202	and	
3-103	1203-1208	would	
3-104	1209-1213	work	
3-105	1214-1216	on	
3-106	1217-1221	many	
3-107	1222-1230	projects	
3-108	1231-1245	simultaneously	
3-109	1245-1246	.	
3-110	1247-1250	I'm	
3-111	1251-1253	an	
3-112	1254-1265	Application	
3-113	1266-1269	DBA	

#Text=I never had any desire to fiddle with backups or tune storage (I'm sure it's fascinating!). Until this day I like to say I'm a DBA that knows how to develop applications, and not a developer that knows his way around the database. In this article I share some non-trivial tips about database development I gathered along the way. Be that guy...Image by CommitStrip Table of Contents Update Only What Needs Updating Disable Constraints and Indexes During Bulk Loads
4-1	1270-1271	I	
4-2	1272-1277	never	
4-3	1278-1281	had	
4-4	1282-1285	any	
4-5	1286-1292	desire	
4-6	1293-1295	to	
4-7	1296-1302	fiddle	
4-8	1303-1307	with	
4-9	1308-1315	backups	
4-10	1316-1318	or	
4-11	1319-1323	tune	
4-12	1324-1331	storage	
4-13	1332-1333	(	
4-14	1333-1336	I'm	
4-15	1337-1341	sure	
4-16	1342-1346	it's	
4-17	1347-1358	fascinating	
4-18	1358-1359	!	
4-19	1359-1360	)	
4-20	1360-1361	.	
4-21	1362-1367	Until	
4-22	1368-1372	this	
4-23	1373-1376	day	
4-24	1377-1378	I	
4-25	1379-1383	like	
4-26	1384-1386	to	
4-27	1387-1390	say	
4-28	1391-1394	I'm	
4-29	1395-1396	a	
4-30	1397-1400	DBA	
4-31	1401-1405	that	
4-32	1406-1411	knows	
4-33	1412-1415	how	
4-34	1416-1418	to	
4-35	1419-1426	develop	
4-36	1427-1439	applications	
4-37	1439-1440	,	
4-38	1441-1444	and	
4-39	1445-1448	not	
4-40	1449-1450	a	
4-41	1451-1460	developer	
4-42	1461-1465	that	
4-43	1466-1471	knows	
4-44	1472-1475	his	
4-45	1476-1479	way	
4-46	1480-1486	around	
4-47	1487-1490	the	
4-48	1491-1499	database	
4-49	1499-1500	.	
4-50	1501-1503	In	
4-51	1504-1508	this	
4-52	1509-1516	article	
4-53	1517-1518	I	
4-54	1519-1524	share	
4-55	1525-1529	some	
4-56	1530-1541	non-trivial	
4-57	1542-1546	tips	
4-58	1547-1552	about	
4-59	1553-1561	database	
4-60	1562-1573	development	
4-61	1574-1575	I	
4-62	1576-1584	gathered	
4-63	1585-1590	along	
4-64	1591-1594	the	
4-65	1595-1598	way	
4-66	1598-1599	.	
4-67	1600-1602	Be	
4-68	1603-1607	that	
4-69	1608-1611	guy	
4-70	1611-1612	.	
4-71	1612-1613	.	
4-72	1613-1614	.	
4-73	1614-1619	Image	
4-74	1620-1622	by	
4-75	1623-1634	CommitStrip	
4-76	1635-1640	Table	
4-77	1641-1643	of	
4-78	1644-1652	Contents	
4-79	1653-1659	Update	
4-80	1660-1664	Only	
4-81	1665-1669	What	
4-82	1670-1675	Needs	
4-83	1676-1684	Updating	
4-84	1685-1692	Disable	
4-85	1693-1704	Constraints	
4-86	1705-1708	and	
4-87	1709-1716	Indexes	
4-88	1717-1723	During	
4-89	1724-1728	Bulk	
4-90	1729-1734	Loads	

#Text=Use UNLOGGED Tables for Intermediate Data Implement Complete Processes Using WITH and RETURNING Avoid Indexes on Columns With Low Selectivity Use Partial Indexes Always Load Sorted Data Index Columns With High Correlation Using BRIN
5-1	1735-1738	Use	
5-2	1739-1747	UNLOGGED	
5-3	1748-1754	Tables	
5-4	1755-1758	for	
5-5	1759-1771	Intermediate	
5-6	1772-1776	Data	
5-7	1777-1786	Implement	
5-8	1787-1795	Complete	
5-9	1796-1805	Processes	
5-10	1806-1811	Using	
5-11	1812-1816	WITH	
5-12	1817-1820	and	
5-13	1821-1830	RETURNING	
5-14	1831-1836	Avoid	
5-15	1837-1844	Indexes	
5-16	1845-1847	on	
5-17	1848-1855	Columns	
5-18	1856-1860	With	
5-19	1861-1864	Low	
5-20	1865-1876	Selectivity	
5-21	1877-1880	Use	
5-22	1881-1888	Partial	
5-23	1889-1896	Indexes	
5-24	1897-1903	Always	
5-25	1904-1908	Load	
5-26	1909-1915	Sorted	
5-27	1916-1920	Data	
5-28	1921-1926	Index	
5-29	1927-1934	Columns	
5-30	1935-1939	With	
5-31	1940-1944	High	
5-32	1945-1956	Correlation	
5-33	1957-1962	Using	
5-34	1963-1967	BRIN	

#Text=Make Indexes "Invisible" Don't Schedule Long Running Processes at Round Hours Conclusion Update Only What Needs Updating UPDATE is a relatively expensive operation. To speed up an UPDATE command it's best to make sure you only update what needs updating.
6-1	1968-1972	Make	
6-2	1973-1980	Indexes	
6-3	1981-1982	"	
6-4	1982-1991	Invisible	
6-5	1991-1992	"	
6-6	1993-1998	Don't	
6-7	1999-2007	Schedule	
6-8	2008-2012	Long	
6-9	2013-2020	Running	
6-10	2021-2030	Processes	
6-11	2031-2033	at	
6-12	2034-2039	Round	
6-13	2040-2045	Hours	
6-14	2046-2056	Conclusion	
6-15	2057-2063	Update	
6-16	2064-2068	Only	
6-17	2069-2073	What	
6-18	2074-2079	Needs	
6-19	2080-2088	Updating	
6-20	2089-2095	UPDATE	
6-21	2096-2098	is	
6-22	2099-2100	a	
6-23	2101-2111	relatively	
6-24	2112-2121	expensive	
6-25	2122-2131	operation	
6-26	2131-2132	.	
6-27	2133-2135	To	
6-28	2136-2141	speed	
6-29	2142-2144	up	
6-30	2145-2147	an	
6-31	2148-2154	UPDATE	
6-32	2155-2162	command	
6-33	2163-2167	it's	
6-34	2168-2172	best	
6-35	2173-2175	to	
6-36	2176-2180	make	
6-37	2181-2185	sure	
6-38	2186-2189	you	
6-39	2190-2194	only	
6-40	2195-2201	update	
6-41	2202-2206	what	
6-42	2207-2212	needs	
6-43	2213-2221	updating	
6-44	2221-2222	.	

#Text=Take this query for example that normalizes an email column: db=# UPDATE users SET email = lower(email); UPDATE 1010000 Time: 1583.935 ms (00:01.584) Looks innocent, right? the query updated emails of 1,010,000 users. But, did all rows really needed to update?
7-1	2223-2227	Take	
7-2	2228-2232	this	
7-3	2233-2238	query	
7-4	2239-2242	for	
7-5	2243-2250	example	
7-6	2251-2255	that	
7-7	2256-2266	normalizes	
7-8	2267-2269	an	
7-9	2270-2275	email	
7-10	2276-2282	column	
7-11	2282-2283	:	
7-12	2284-2286	db	
7-13	2286-2287	=	
7-14	2287-2288	#	
7-15	2289-2295	UPDATE	
7-16	2296-2301	users	
7-17	2302-2305	SET	
7-18	2306-2311	email	
7-19	2312-2313	=	
7-20	2314-2319	lower	
7-21	2319-2320	(	
7-22	2320-2325	email	
7-23	2325-2326	)	
7-24	2326-2327	;	
7-25	2328-2334	UPDATE	
7-26	2335-2342	1010000	
7-27	2343-2347	Time	
7-28	2347-2348	:	
7-29	2349-2357	1583.935	
7-30	2358-2360	ms	
7-31	2361-2362	(	
7-32	2362-2364	00	
7-33	2364-2365	:	
7-34	2365-2371	01.584	
7-35	2371-2372	)	
7-36	2373-2378	Looks	
7-37	2379-2387	innocent	
7-38	2387-2388	,	
7-39	2389-2394	right	
7-40	2394-2395	?	
7-41	2396-2399	the	
7-42	2400-2405	query	
7-43	2406-2413	updated	
7-44	2414-2420	emails	
7-45	2421-2423	of	
7-46	2424-2433	1,010,000	
7-47	2434-2439	users	
7-48	2439-2440	.	
7-49	2441-2444	But	
7-50	2444-2445	,	
7-51	2446-2449	did	
7-52	2450-2453	all	
7-53	2454-2458	rows	
7-54	2459-2465	really	
7-55	2466-2472	needed	
7-56	2473-2475	to	
7-57	2476-2482	update	
7-58	2482-2483	?	

#Text=db=# UPDATE users SET email = lower(email) db-# WHERE email != lower(email); UPDATE 10000 Time: 299.470 ms Only 10,000 rows needed to update. By reducing the amount of affected rows, the execution time went down from 1.5 seconds to just less than 300ms. Updating fewer rows also saves the database maintenance later on.
8-1	2484-2486	db	
8-2	2486-2487	=	
8-3	2487-2488	#	
8-4	2489-2495	UPDATE	
8-5	2496-2501	users	
8-6	2502-2505	SET	
8-7	2506-2511	email	
8-8	2512-2513	=	
8-9	2514-2519	lower	
8-10	2519-2520	(	
8-11	2520-2525	email	
8-12	2525-2526	)	
8-13	2527-2529	db	
8-14	2529-2530	-	
8-15	2530-2531	#	
8-16	2532-2537	WHERE	
8-17	2538-2543	email	
8-18	2544-2545	!	
8-19	2545-2546	=	
8-20	2547-2552	lower	
8-21	2552-2553	(	
8-22	2553-2558	email	
8-23	2558-2559	)	
8-24	2559-2560	;	
8-25	2561-2567	UPDATE	
8-26	2568-2573	10000	
8-27	2574-2578	Time	
8-28	2578-2579	:	
8-29	2580-2587	299.470	
8-30	2588-2590	ms	
8-31	2591-2595	Only	
8-32	2596-2602	10,000	
8-33	2603-2607	rows	
8-34	2608-2614	needed	
8-35	2615-2617	to	
8-36	2618-2624	update	
8-37	2624-2625	.	
8-38	2626-2628	By	
8-39	2629-2637	reducing	
8-40	2638-2641	the	
8-41	2642-2648	amount	
8-42	2649-2651	of	
8-43	2652-2660	affected	
8-44	2661-2665	rows	
8-45	2665-2666	,	
8-46	2667-2670	the	
8-47	2671-2680	execution	
8-48	2681-2685	time	
8-49	2686-2690	went	
8-50	2691-2695	down	
8-51	2696-2700	from	
8-52	2701-2704	1.5	
8-53	2705-2712	seconds	
8-54	2713-2715	to	
8-55	2716-2720	just	
8-56	2721-2725	less	
8-57	2726-2730	than	
8-58	2731-2736	300ms	
8-59	2736-2737	.	
8-60	2738-2746	Updating	
8-61	2747-2752	fewer	
8-62	2753-2757	rows	
8-63	2758-2762	also	
8-64	2763-2768	saves	
8-65	2769-2772	the	
8-66	2773-2781	database	
8-67	2782-2793	maintenance	
8-68	2794-2799	later	
8-69	2800-2802	on	
8-70	2802-2803	.	

#Text=Update Only What Needs Updating This type of large updates are very common in data migration scripts. So the next time you write a migration script, make sure to only update what needs updating. Disable Constraints and Indexes During Bulk Loads
9-1	2804-2810	Update	
9-2	2811-2815	Only	
9-3	2816-2820	What	
9-4	2821-2826	Needs	
9-5	2827-2835	Updating	
9-6	2836-2840	This	
9-7	2841-2845	type	
9-8	2846-2848	of	
9-9	2849-2854	large	
9-10	2855-2862	updates	
9-11	2863-2866	are	
9-12	2867-2871	very	
9-13	2872-2878	common	
9-14	2879-2881	in	
9-15	2882-2886	data	
9-16	2887-2896	migration	
9-17	2897-2904	scripts	
9-18	2904-2905	.	
9-19	2906-2908	So	
9-20	2909-2912	the	
9-21	2913-2917	next	
9-22	2918-2922	time	
9-23	2923-2926	you	
9-24	2927-2932	write	
9-25	2933-2934	a	
9-26	2935-2944	migration	
9-27	2945-2951	script	
9-28	2951-2952	,	
9-29	2953-2957	make	
9-30	2958-2962	sure	
9-31	2963-2965	to	
9-32	2966-2970	only	
9-33	2971-2977	update	
9-34	2978-2982	what	
9-35	2983-2988	needs	
9-36	2989-2997	updating	
9-37	2997-2998	.	
9-38	2999-3006	Disable	
9-39	3007-3018	Constraints	
9-40	3019-3022	and	
9-41	3023-3030	Indexes	
9-42	3031-3037	During	
9-43	3038-3042	Bulk	
9-44	3043-3048	Loads	

#Text=Constraints are an important part of relational databases: they keep the data consistent and reliable. Their benefits come at a cost though, and it's most noticeable when loading or updating a lot of rows. To demonstrate, set up a small schema for a store: DROP TABLE IF EXISTS product CASCADE; CREATE TABLE product ( id serial PRIMARY KEY, name TEXT NOT NULL,
10-1	3049-3060	Constraints	
10-2	3061-3064	are	
10-3	3065-3067	an	
10-4	3068-3077	important	
10-5	3078-3082	part	
10-6	3083-3085	of	
10-7	3086-3096	relational	
10-8	3097-3106	databases	
10-9	3106-3107	:	
10-10	3108-3112	they	
10-11	3113-3117	keep	
10-12	3118-3121	the	
10-13	3122-3126	data	
10-14	3127-3137	consistent	
10-15	3138-3141	and	
10-16	3142-3150	reliable	
10-17	3150-3151	.	
10-18	3152-3157	Their	
10-19	3158-3166	benefits	
10-20	3167-3171	come	
10-21	3172-3174	at	
10-22	3175-3176	a	
10-23	3177-3181	cost	
10-24	3182-3188	though	
10-25	3188-3189	,	
10-26	3190-3193	and	
10-27	3194-3198	it's	
10-28	3199-3203	most	
10-29	3204-3214	noticeable	
10-30	3215-3219	when	
10-31	3220-3227	loading	
10-32	3228-3230	or	
10-33	3231-3239	updating	
10-34	3240-3241	a	
10-35	3242-3245	lot	
10-36	3246-3248	of	
10-37	3249-3253	rows	
10-38	3253-3254	.	
10-39	3255-3257	To	
10-40	3258-3269	demonstrate	
10-41	3269-3270	,	
10-42	3271-3274	set	
10-43	3275-3277	up	
10-44	3278-3279	a	
10-45	3280-3285	small	
10-46	3286-3292	schema	
10-47	3293-3296	for	
10-48	3297-3298	a	
10-49	3299-3304	store	
10-50	3304-3305	:	
10-51	3306-3310	DROP	
10-52	3311-3316	TABLE	
10-53	3317-3319	IF	
10-54	3320-3326	EXISTS	
10-55	3327-3334	product	
10-56	3335-3342	CASCADE	
10-57	3342-3343	;	
10-58	3344-3350	CREATE	
10-59	3351-3356	TABLE	
10-60	3357-3364	product	
10-61	3365-3366	(	
10-62	3367-3369	id	
10-63	3370-3376	serial	
10-64	3377-3384	PRIMARY	
10-65	3385-3388	KEY	
10-66	3388-3389	,	
10-67	3390-3394	name	
10-68	3395-3399	TEXT	
10-69	3400-3403	NOT	
10-70	3404-3408	NULL	
10-71	3408-3409	,	

#Text=price INT NOT NULL INSERT INTO product (name, price) SELECT random()::text, (random() * 1000)::int FROM generate_series(0, 10000); DROP TABLE IF EXISTS customer CASCADE;
11-1	3410-3415	price	
11-2	3416-3419	INT	
11-3	3420-3423	NOT	
11-4	3424-3428	NULL	
11-5	3429-3435	INSERT	
11-6	3436-3440	INTO	
11-7	3441-3448	product	
11-8	3449-3450	(	
11-9	3450-3454	name	
11-10	3454-3455	,	
11-11	3456-3461	price	
11-12	3461-3462	)	
11-13	3463-3469	SELECT	
11-14	3470-3476	random	
11-15	3476-3477	(	
11-16	3477-3478	)	
11-17	3478-3479	:	
11-18	3479-3480	:	
11-19	3480-3484	text	
11-20	3484-3485	,	
11-21	3486-3487	(	
11-22	3487-3493	random	
11-23	3493-3494	(	
11-24	3494-3495	)	
11-25	3496-3497	*	
11-26	3498-3502	1000	
11-27	3502-3503	)	
11-28	3503-3504	:	
11-29	3504-3505	:	
11-30	3505-3508	int	
11-31	3509-3513	FROM	
11-32	3514-3529	generate_series	
11-33	3529-3530	(	
11-34	3530-3531	0	
11-35	3531-3532	,	
11-36	3533-3538	10000	
11-37	3538-3539	)	
11-38	3539-3540	;	
11-39	3541-3545	DROP	
11-40	3546-3551	TABLE	
11-41	3552-3554	IF	
11-42	3555-3561	EXISTS	
11-43	3562-3570	customer	
11-44	3571-3578	CASCADE	
11-45	3578-3579	;	

#Text=CREATE TABLE customer ( id serial PRIMARY KEY, name TEXT NOT NULL INSERT INTO customer (name) SELECT random()::text FROM generate_series(0, 100000);
12-1	3580-3586	CREATE	
12-2	3587-3592	TABLE	
12-3	3593-3601	customer	
12-4	3602-3603	(	
12-5	3604-3606	id	
12-6	3607-3613	serial	
12-7	3614-3621	PRIMARY	
12-8	3622-3625	KEY	
12-9	3625-3626	,	
12-10	3627-3631	name	
12-11	3632-3636	TEXT	
12-12	3637-3640	NOT	
12-13	3641-3645	NULL	
12-14	3646-3652	INSERT	
12-15	3653-3657	INTO	
12-16	3658-3666	customer	
12-17	3667-3668	(	
12-18	3668-3672	name	
12-19	3672-3673	)	
12-20	3674-3680	SELECT	
12-21	3681-3687	random	
12-22	3687-3688	(	
12-23	3688-3689	)	
12-24	3689-3690	:	
12-25	3690-3691	:	
12-26	3691-3695	text	
12-27	3696-3700	FROM	
12-28	3701-3716	generate_series	
12-29	3716-3717	(	
12-30	3717-3718	0	
12-31	3718-3719	,	
12-32	3720-3726	100000	
12-33	3726-3727	)	
12-34	3727-3728	;	

#Text=DROP TABLE IF EXISTS sale; CREATE TABLE sale ( id serial PRIMARY KEY, created timestamptz NOT NULL, product_id int NOT NULL, customer_id int NOT NULL
13-1	3729-3733	DROP	
13-2	3734-3739	TABLE	
13-3	3740-3742	IF	
13-4	3743-3749	EXISTS	
13-5	3750-3754	sale	
13-6	3754-3755	;	
13-7	3756-3762	CREATE	
13-8	3763-3768	TABLE	
13-9	3769-3773	sale	
13-10	3774-3775	(	
13-11	3776-3778	id	
13-12	3779-3785	serial	
13-13	3786-3793	PRIMARY	
13-14	3794-3797	KEY	
13-15	3797-3798	,	
13-16	3799-3806	created	
13-17	3807-3818	timestamptz	
13-18	3819-3822	NOT	
13-19	3823-3827	NULL	
13-20	3827-3828	,	
13-21	3829-3839	product_id	
13-22	3840-3843	int	
13-23	3844-3847	NOT	
13-24	3848-3852	NULL	
13-25	3852-3853	,	
13-26	3854-3865	customer_id	
13-27	3866-3869	int	
13-28	3870-3873	NOT	
13-29	3874-3878	NULL	

#Text=The schema defines different types of constraints such as "not null" and unique constraints. To set a baseline, start by adding foreign keys to the sale table, and then load some data into it: db=# ALTER TABLE sale ADD CONSTRAINT sale_product_fk
14-1	3879-3882	The	
14-2	3883-3889	schema	
14-3	3890-3897	defines	
14-4	3898-3907	different	
14-5	3908-3913	types	
14-6	3914-3916	of	
14-7	3917-3928	constraints	
14-8	3929-3933	such	
14-9	3934-3936	as	
14-10	3937-3938	"	
14-11	3938-3941	not	
14-12	3942-3946	null	
14-13	3946-3947	"	
14-14	3948-3951	and	
14-15	3952-3958	unique	
14-16	3959-3970	constraints	
14-17	3970-3971	.	
14-18	3972-3974	To	
14-19	3975-3978	set	
14-20	3979-3980	a	
14-21	3981-3989	baseline	
14-22	3989-3990	,	
14-23	3991-3996	start	
14-24	3997-3999	by	
14-25	4000-4006	adding	
14-26	4007-4014	foreign	
14-27	4015-4019	keys	
14-28	4020-4022	to	
14-29	4023-4026	the	
14-30	4027-4031	sale	
14-31	4032-4037	table	
14-32	4037-4038	,	
14-33	4039-4042	and	
14-34	4043-4047	then	
14-35	4048-4052	load	
14-36	4053-4057	some	
14-37	4058-4062	data	
14-38	4063-4067	into	
14-39	4068-4070	it	
14-40	4070-4071	:	
14-41	4072-4074	db	
14-42	4074-4075	=	
14-43	4075-4076	#	
14-44	4077-4082	ALTER	
14-45	4083-4088	TABLE	
14-46	4089-4093	sale	
14-47	4094-4097	ADD	
14-48	4098-4108	CONSTRAINT	
14-49	4109-4124	sale_product_fk	

#Text=db-# FOREIGN KEY (product_id) REFERENCES product(id); ALTER TABLE Time: 18.413 ms db=# ALTER TABLE sale ADD CONSTRAINT sale_customer_fk db-# FOREIGN KEY (customer_id) REFERENCES customer(id);
15-1	4125-4127	db	
15-2	4127-4128	-	
15-3	4128-4129	#	
15-4	4130-4137	FOREIGN	
15-5	4138-4141	KEY	
15-6	4142-4143	(	
15-7	4143-4153	product_id	
15-8	4153-4154	)	
15-9	4155-4165	REFERENCES	
15-10	4166-4173	product	
15-11	4173-4174	(	
15-12	4174-4176	id	
15-13	4176-4177	)	
15-14	4177-4178	;	
15-15	4179-4184	ALTER	
15-16	4185-4190	TABLE	
15-17	4191-4195	Time	
15-18	4195-4196	:	
15-19	4197-4203	18.413	
15-20	4204-4206	ms	
15-21	4207-4209	db	
15-22	4209-4210	=	
15-23	4210-4211	#	
15-24	4212-4217	ALTER	
15-25	4218-4223	TABLE	
15-26	4224-4228	sale	
15-27	4229-4232	ADD	
15-28	4233-4243	CONSTRAINT	
15-29	4244-4260	sale_customer_fk	
15-30	4261-4263	db	
15-31	4263-4264	-	
15-32	4264-4265	#	
15-33	4266-4273	FOREIGN	
15-34	4274-4277	KEY	
15-35	4278-4279	(	
15-36	4279-4290	customer_id	
15-37	4290-4291	)	
15-38	4292-4302	REFERENCES	
15-39	4303-4311	customer	
15-40	4311-4312	(	
15-41	4312-4314	id	
15-42	4314-4315	)	
15-43	4315-4316	;	

#Text=ALTER TABLE Time: 5.464 ms db=# CREATE INDEX sale_created_ix ON sale(created); CREATE INDEX Time: 12.605 ms db=# INSERT INTO SALE (created, product_id, customer_id)
16-1	4317-4322	ALTER	
16-2	4323-4328	TABLE	
16-3	4329-4333	Time	
16-4	4333-4334	:	
16-5	4335-4340	5.464	
16-6	4341-4343	ms	
16-7	4344-4346	db	
16-8	4346-4347	=	
16-9	4347-4348	#	
16-10	4349-4355	CREATE	
16-11	4356-4361	INDEX	
16-12	4362-4377	sale_created_ix	
16-13	4378-4380	ON	
16-14	4381-4385	sale	
16-15	4385-4386	(	
16-16	4386-4393	created	
16-17	4393-4394	)	
16-18	4394-4395	;	
16-19	4396-4402	CREATE	
16-20	4403-4408	INDEX	
16-21	4409-4413	Time	
16-22	4413-4414	:	
16-23	4415-4421	12.605	
16-24	4422-4424	ms	
16-25	4425-4427	db	
16-26	4427-4428	=	
16-27	4428-4429	#	
16-28	4430-4436	INSERT	
16-29	4437-4441	INTO	
16-30	4442-4446	SALE	
16-31	4447-4448	(	
16-32	4448-4455	created	
16-33	4455-4456	,	
16-34	4457-4467	product_id	
16-35	4467-4468	,	
16-36	4469-4480	customer_id	
16-37	4480-4481	)	

#Text=db-# SELECT db-# now() - interval '1 hour' * random() * 1000, db-# (random() * 10000)::int + 1, db-# (random() * 100000)::int + 1
17-1	4482-4484	db	
17-2	4484-4485	-	
17-3	4485-4486	#	
17-4	4487-4493	SELECT	
17-5	4494-4496	db	
17-6	4496-4497	-	
17-7	4497-4498	#	
17-8	4499-4502	now	
17-9	4502-4503	(	
17-10	4503-4504	)	
17-11	4505-4506	-	
17-12	4507-4515	interval	
17-13	4516-4517	'	
17-14	4517-4518	1	
17-15	4519-4523	hour	
17-16	4523-4524	'	
17-17	4525-4526	*	
17-18	4527-4533	random	
17-19	4533-4534	(	
17-20	4534-4535	)	
17-21	4536-4537	*	
17-22	4538-4542	1000	
17-23	4542-4543	,	
17-24	4544-4546	db	
17-25	4546-4547	-	
17-26	4547-4548	#	
17-27	4549-4550	(	
17-28	4550-4556	random	
17-29	4556-4557	(	
17-30	4557-4558	)	
17-31	4559-4560	*	
17-32	4561-4566	10000	
17-33	4566-4567	)	
17-34	4567-4568	:	
17-35	4568-4569	:	
17-36	4569-4572	int	
17-37	4573-4574	+	
17-38	4575-4576	1	
17-39	4576-4577	,	
17-40	4578-4580	db	
17-41	4580-4581	-	
17-42	4581-4582	#	
17-43	4583-4584	(	
17-44	4584-4590	random	
17-45	4590-4591	(	
17-46	4591-4592	)	
17-47	4593-4594	*	
17-48	4595-4601	100000	
17-49	4601-4602	)	
17-50	4602-4603	:	
17-51	4603-4604	:	
17-52	4604-4607	int	
17-53	4608-4609	+	
17-54	4610-4611	1	

#Text=db-# FROM generate_series(1, 1000000); INSERT 0 1000000 Time: 15410.234 ms (00:15.410) After defining constraints and indexes, loading a million rows to the table took ~15.4s. Next, try to load the data into the table first, and only then add constraints and indexes:
18-1	4612-4614	db	
18-2	4614-4615	-	
18-3	4615-4616	#	
18-4	4617-4621	FROM	
18-5	4622-4637	generate_series	
18-6	4637-4638	(	
18-7	4638-4639	1	
18-8	4639-4640	,	
18-9	4641-4648	1000000	
18-10	4648-4649	)	
18-11	4649-4650	;	
18-12	4651-4657	INSERT	
18-13	4658-4659	0	
18-14	4660-4667	1000000	
18-15	4668-4672	Time	
18-16	4672-4673	:	
18-17	4674-4683	15410.234	
18-18	4684-4686	ms	
18-19	4687-4688	(	
18-20	4688-4690	00	
18-21	4690-4691	:	
18-22	4691-4697	15.410	
18-23	4697-4698	)	
18-24	4699-4704	After	
18-25	4705-4713	defining	
18-26	4714-4725	constraints	
18-27	4726-4729	and	
18-28	4730-4737	indexes	
18-29	4737-4738	,	
18-30	4739-4746	loading	
18-31	4747-4748	a	
18-32	4749-4756	million	
18-33	4757-4761	rows	
18-34	4762-4764	to	
18-35	4765-4768	the	
18-36	4769-4774	table	
18-37	4775-4779	took	
18-38	4780-4781	~	
18-39	4781-4786	15.4s	
18-40	4786-4787	.	
18-41	4788-4792	Next	
18-42	4792-4793	,	
18-43	4794-4797	try	
18-44	4798-4800	to	
18-45	4801-4805	load	
18-46	4806-4809	the	
18-47	4810-4814	data	
18-48	4815-4819	into	
18-49	4820-4823	the	
18-50	4824-4829	table	
18-51	4830-4835	first	
18-52	4835-4836	,	
18-53	4837-4840	and	
18-54	4841-4845	only	
18-55	4846-4850	then	
18-56	4851-4854	add	
18-57	4855-4866	constraints	
18-58	4867-4870	and	
18-59	4871-4878	indexes	
18-60	4878-4879	:	

#Text=db=# INSERT INTO SALE (created, product_id, customer_id) db-# SELECT db-# now() - interval '1 hour' * random() * 1000, db-# (random() * 10000)::int + 1, db-#
19-1	4880-4882	db	
19-2	4882-4883	=	
19-3	4883-4884	#	
19-4	4885-4891	INSERT	
19-5	4892-4896	INTO	
19-6	4897-4901	SALE	
19-7	4902-4903	(	
19-8	4903-4910	created	
19-9	4910-4911	,	
19-10	4912-4922	product_id	
19-11	4922-4923	,	
19-12	4924-4935	customer_id	
19-13	4935-4936	)	
19-14	4937-4939	db	
19-15	4939-4940	-	
19-16	4940-4941	#	
19-17	4942-4948	SELECT	
19-18	4949-4951	db	
19-19	4951-4952	-	
19-20	4952-4953	#	
19-21	4954-4957	now	
19-22	4957-4958	(	
19-23	4958-4959	)	
19-24	4960-4961	-	
19-25	4962-4970	interval	
19-26	4971-4972	'	
19-27	4972-4973	1	
19-28	4974-4978	hour	
19-29	4978-4979	'	
19-30	4980-4981	*	
19-31	4982-4988	random	
19-32	4988-4989	(	
19-33	4989-4990	)	
19-34	4991-4992	*	
19-35	4993-4997	1000	
19-36	4997-4998	,	
19-37	4999-5001	db	
19-38	5001-5002	-	
19-39	5002-5003	#	
19-40	5004-5005	(	
19-41	5005-5011	random	
19-42	5011-5012	(	
19-43	5012-5013	)	
19-44	5014-5015	*	
19-45	5016-5021	10000	
19-46	5021-5022	)	
19-47	5022-5023	:	
19-48	5023-5024	:	
19-49	5024-5027	int	
19-50	5028-5029	+	
19-51	5030-5031	1	
19-52	5031-5032	,	
19-53	5033-5035	db	
19-54	5035-5036	-	
19-55	5036-5037	#	

#Text=(random() * 100000)::int + 1 db-# FROM generate_series(1, 1000000); INSERT 0 1000000 Time: 2277.824 ms (00:02.278) db=# ALTER TABLE sale ADD CONSTRAINT sale_product_fk
20-1	5038-5039	(	
20-2	5039-5045	random	
20-3	5045-5046	(	
20-4	5046-5047	)	
20-5	5048-5049	*	
20-6	5050-5056	100000	
20-7	5056-5057	)	
20-8	5057-5058	:	
20-9	5058-5059	:	
20-10	5059-5062	int	
20-11	5063-5064	+	
20-12	5065-5066	1	
20-13	5067-5069	db	
20-14	5069-5070	-	
20-15	5070-5071	#	
20-16	5072-5076	FROM	
20-17	5077-5092	generate_series	
20-18	5092-5093	(	
20-19	5093-5094	1	
20-20	5094-5095	,	
20-21	5096-5103	1000000	
20-22	5103-5104	)	
20-23	5104-5105	;	
20-24	5106-5112	INSERT	
20-25	5113-5114	0	
20-26	5115-5122	1000000	
20-27	5123-5127	Time	
20-28	5127-5128	:	
20-29	5129-5137	2277.824	
20-30	5138-5140	ms	
20-31	5141-5142	(	
20-32	5142-5144	00	
20-33	5144-5145	:	
20-34	5145-5151	02.278	
20-35	5151-5152	)	
20-36	5153-5155	db	
20-37	5155-5156	=	
20-38	5156-5157	#	
20-39	5158-5163	ALTER	
20-40	5164-5169	TABLE	
20-41	5170-5174	sale	
20-42	5175-5178	ADD	
20-43	5179-5189	CONSTRAINT	
20-44	5190-5205	sale_product_fk	

#Text=db-# FOREIGN KEY (product_id) REFERENCES product(id); ALTER TABLE Time: 169.193 ms db=# ALTER TABLE sale ADD CONSTRAINT sale_customer_fk db-# FOREIGN KEY (customer_id) REFERENCES customer(id);
21-1	5206-5208	db	
21-2	5208-5209	-	
21-3	5209-5210	#	
21-4	5211-5218	FOREIGN	
21-5	5219-5222	KEY	
21-6	5223-5224	(	
21-7	5224-5234	product_id	
21-8	5234-5235	)	
21-9	5236-5246	REFERENCES	
21-10	5247-5254	product	
21-11	5254-5255	(	
21-12	5255-5257	id	
21-13	5257-5258	)	
21-14	5258-5259	;	
21-15	5260-5265	ALTER	
21-16	5266-5271	TABLE	
21-17	5272-5276	Time	
21-18	5276-5277	:	
21-19	5278-5285	169.193	
21-20	5286-5288	ms	
21-21	5289-5291	db	
21-22	5291-5292	=	
21-23	5292-5293	#	
21-24	5294-5299	ALTER	
21-25	5300-5305	TABLE	
21-26	5306-5310	sale	
21-27	5311-5314	ADD	
21-28	5315-5325	CONSTRAINT	
21-29	5326-5342	sale_customer_fk	
21-30	5343-5345	db	
21-31	5345-5346	-	
21-32	5346-5347	#	
21-33	5348-5355	FOREIGN	
21-34	5356-5359	KEY	
21-35	5360-5361	(	
21-36	5361-5372	customer_id	
21-37	5372-5373	)	
21-38	5374-5384	REFERENCES	
21-39	5385-5393	customer	
21-40	5393-5394	(	
21-41	5394-5396	id	
21-42	5396-5397	)	
21-43	5397-5398	;	

#Text=ALTER TABLE Time: 185.633 ms db=# CREATE INDEX sale_created_ix ON sale(created); CREATE INDEX Time: 484.244 ms
22-1	5399-5404	ALTER	
22-2	5405-5410	TABLE	
22-3	5411-5415	Time	
22-4	5415-5416	:	
22-5	5417-5424	185.633	
22-6	5425-5427	ms	
22-7	5428-5430	db	
22-8	5430-5431	=	
22-9	5431-5432	#	
22-10	5433-5439	CREATE	
22-11	5440-5445	INDEX	
22-12	5446-5461	sale_created_ix	
22-13	5462-5464	ON	
22-14	5465-5469	sale	
22-15	5469-5470	(	
22-16	5470-5477	created	
22-17	5477-5478	)	
22-18	5478-5479	;	
22-19	5480-5486	CREATE	
22-20	5487-5492	INDEX	
22-21	5493-5497	Time	
22-22	5497-5498	:	
22-23	5499-5506	484.244	
22-24	5507-5509	ms	

#Text=Loading data into a table without indexes and constraints was much faster, 2.27s compared to 15.4s before. Creating the indexes and constraints after the data was loaded into the table took a bit longer, but overall the entire process was much faster, 3.1s compared to 15.4s. Unfortunately, for indexes PostgreSQL does not provide an easy way of doing this other than dropping and re-creating the indexes. In other databases such as Oracle, you can disable and enable indexes without having to re-create them. Use UNLOGGED Tables for Intermediate Data
23-1	5510-5517	Loading	
23-2	5518-5522	data	
23-3	5523-5527	into	
23-4	5528-5529	a	
23-5	5530-5535	table	
23-6	5536-5543	without	
23-7	5544-5551	indexes	
23-8	5552-5555	and	
23-9	5556-5567	constraints	
23-10	5568-5571	was	
23-11	5572-5576	much	
23-12	5577-5583	faster	
23-13	5583-5584	,	
23-14	5585-5590	2.27s	
23-15	5591-5599	compared	
23-16	5600-5602	to	
23-17	5603-5608	15.4s	
23-18	5609-5615	before	
23-19	5615-5616	.	
23-20	5617-5625	Creating	
23-21	5626-5629	the	
23-22	5630-5637	indexes	
23-23	5638-5641	and	
23-24	5642-5653	constraints	
23-25	5654-5659	after	
23-26	5660-5663	the	
23-27	5664-5668	data	
23-28	5669-5672	was	
23-29	5673-5679	loaded	
23-30	5680-5684	into	
23-31	5685-5688	the	
23-32	5689-5694	table	
23-33	5695-5699	took	
23-34	5700-5701	a	
23-35	5702-5705	bit	
23-36	5706-5712	longer	
23-37	5712-5713	,	
23-38	5714-5717	but	
23-39	5718-5725	overall	
23-40	5726-5729	the	
23-41	5730-5736	entire	
23-42	5737-5744	process	
23-43	5745-5748	was	
23-44	5749-5753	much	
23-45	5754-5760	faster	
23-46	5760-5761	,	
23-47	5762-5766	3.1s	
23-48	5767-5775	compared	
23-49	5776-5778	to	
23-50	5779-5784	15.4s	
23-51	5784-5785	.	
23-52	5786-5799	Unfortunately	
23-53	5799-5800	,	
23-54	5801-5804	for	
23-55	5805-5812	indexes	
23-56	5813-5823	PostgreSQL	
23-57	5824-5828	does	
23-58	5829-5832	not	
23-59	5833-5840	provide	
23-60	5841-5843	an	
23-61	5844-5848	easy	
23-62	5849-5852	way	
23-63	5853-5855	of	
23-64	5856-5861	doing	
23-65	5862-5866	this	
23-66	5867-5872	other	
23-67	5873-5877	than	
23-68	5878-5886	dropping	
23-69	5887-5890	and	
23-70	5891-5902	re-creating	
23-71	5903-5906	the	
23-72	5907-5914	indexes	
23-73	5914-5915	.	
23-74	5916-5918	In	
23-75	5919-5924	other	
23-76	5925-5934	databases	
23-77	5935-5939	such	
23-78	5940-5942	as	
23-79	5943-5949	Oracle	
23-80	5949-5950	,	
23-81	5951-5954	you	
23-82	5955-5958	can	
23-83	5959-5966	disable	
23-84	5967-5970	and	
23-85	5971-5977	enable	
23-86	5978-5985	indexes	
23-87	5986-5993	without	
23-88	5994-6000	having	
23-89	6001-6003	to	
23-90	6004-6013	re-create	
23-91	6014-6018	them	
23-92	6018-6019	.	
23-93	6020-6023	Use	
23-94	6024-6032	UNLOGGED	
23-95	6033-6039	Tables	
23-96	6040-6043	for	
23-97	6044-6056	Intermediate	
23-98	6057-6061	Data	

#Text=When you modify data in PostgreSQL, the changes are written to the write ahead log (WAL). The WAL is used to maintain integrity, to fast forward the database during recovery and to maintain replication. Writing to the WAL is often needed, but there are some circumstances where you might be willing to give up some of its uses to make things a bit faster. One example is intermediate tables.
24-1	6062-6066	When	
24-2	6067-6070	you	
24-3	6071-6077	modify	
24-4	6078-6082	data	
24-5	6083-6085	in	
24-6	6086-6096	PostgreSQL	
24-7	6096-6097	,	
24-8	6098-6101	the	
24-9	6102-6109	changes	
24-10	6110-6113	are	
24-11	6114-6121	written	
24-12	6122-6124	to	
24-13	6125-6128	the	
24-14	6129-6134	write	
24-15	6135-6140	ahead	
24-16	6141-6144	log	
24-17	6145-6146	(	
24-18	6146-6149	WAL	
24-19	6149-6150	)	
24-20	6150-6151	.	
24-21	6152-6155	The	
24-22	6156-6159	WAL	
24-23	6160-6162	is	
24-24	6163-6167	used	
24-25	6168-6170	to	
24-26	6171-6179	maintain	
24-27	6180-6189	integrity	
24-28	6189-6190	,	
24-29	6191-6193	to	
24-30	6194-6198	fast	
24-31	6199-6206	forward	
24-32	6207-6210	the	
24-33	6211-6219	database	
24-34	6220-6226	during	
24-35	6227-6235	recovery	
24-36	6236-6239	and	
24-37	6240-6242	to	
24-38	6243-6251	maintain	
24-39	6252-6263	replication	
24-40	6263-6264	.	
24-41	6265-6272	Writing	
24-42	6273-6275	to	
24-43	6276-6279	the	
24-44	6280-6283	WAL	
24-45	6284-6286	is	
24-46	6287-6292	often	
24-47	6293-6299	needed	
24-48	6299-6300	,	
24-49	6301-6304	but	
24-50	6305-6310	there	
24-51	6311-6314	are	
24-52	6315-6319	some	
24-53	6320-6333	circumstances	
24-54	6334-6339	where	
24-55	6340-6343	you	
24-56	6344-6349	might	
24-57	6350-6352	be	
24-58	6353-6360	willing	
24-59	6361-6363	to	
24-60	6364-6368	give	
24-61	6369-6371	up	
24-62	6372-6376	some	
24-63	6377-6379	of	
24-64	6380-6383	its	
24-65	6384-6388	uses	
24-66	6389-6391	to	
24-67	6392-6396	make	
24-68	6397-6403	things	
24-69	6404-6405	a	
24-70	6406-6409	bit	
24-71	6410-6416	faster	
24-72	6416-6417	.	
24-73	6418-6421	One	
24-74	6422-6429	example	
24-75	6430-6432	is	
24-76	6433-6445	intermediate	
24-77	6446-6452	tables	
24-78	6452-6453	.	

#Text=Intermediate tables are disposable tables that stores temporary data used to implement some process. For example, a very common pattern in ETL processes is to load data from a CSV file to an intermediate table, clean the data, and then load it to the target table. In this use-case, the intermediate table is disposable and there is no use for it in backups or replicas. UNLOGGED table Intermediate tables that don't need to be restored in case of disaster, and are not needed in replicas, can be set as UNLOGGED: CREATE UNLOGGED TABLE staging_table ( /* table definition */ );
25-1	6454-6466	Intermediate	
25-2	6467-6473	tables	
25-3	6474-6477	are	
25-4	6478-6488	disposable	
25-5	6489-6495	tables	
25-6	6496-6500	that	
25-7	6501-6507	stores	
25-8	6508-6517	temporary	
25-9	6518-6522	data	
25-10	6523-6527	used	
25-11	6528-6530	to	
25-12	6531-6540	implement	
25-13	6541-6545	some	
25-14	6546-6553	process	
25-15	6553-6554	.	
25-16	6555-6558	For	
25-17	6559-6566	example	
25-18	6566-6567	,	
25-19	6568-6569	a	
25-20	6570-6574	very	
25-21	6575-6581	common	
25-22	6582-6589	pattern	
25-23	6590-6592	in	
25-24	6593-6596	ETL	
25-25	6597-6606	processes	
25-26	6607-6609	is	
25-27	6610-6612	to	
25-28	6613-6617	load	
25-29	6618-6622	data	
25-30	6623-6627	from	
25-31	6628-6629	a	
25-32	6630-6633	CSV	
25-33	6634-6638	file	
25-34	6639-6641	to	
25-35	6642-6644	an	
25-36	6645-6657	intermediate	
25-37	6658-6663	table	
25-38	6663-6664	,	
25-39	6665-6670	clean	
25-40	6671-6674	the	
25-41	6675-6679	data	
25-42	6679-6680	,	
25-43	6681-6684	and	
25-44	6685-6689	then	
25-45	6690-6694	load	
25-46	6695-6697	it	
25-47	6698-6700	to	
25-48	6701-6704	the	
25-49	6705-6711	target	
25-50	6712-6717	table	
25-51	6717-6718	.	
25-52	6719-6721	In	
25-53	6722-6726	this	
25-54	6727-6735	use-case	
25-55	6735-6736	,	
25-56	6737-6740	the	
25-57	6741-6753	intermediate	
25-58	6754-6759	table	
25-59	6760-6762	is	
25-60	6763-6773	disposable	
25-61	6774-6777	and	
25-62	6778-6783	there	
25-63	6784-6786	is	
25-64	6787-6789	no	
25-65	6790-6793	use	
25-66	6794-6797	for	
25-67	6798-6800	it	
25-68	6801-6803	in	
25-69	6804-6811	backups	
25-70	6812-6814	or	
25-71	6815-6823	replicas	
25-72	6823-6824	.	
25-73	6825-6833	UNLOGGED	
25-74	6834-6839	table	
25-75	6840-6852	Intermediate	
25-76	6853-6859	tables	
25-77	6860-6864	that	
25-78	6865-6870	don't	
25-79	6871-6875	need	
25-80	6876-6878	to	
25-81	6879-6881	be	
25-82	6882-6890	restored	
25-83	6891-6893	in	
25-84	6894-6898	case	
25-85	6899-6901	of	
25-86	6902-6910	disaster	
25-87	6910-6911	,	
25-88	6912-6915	and	
25-89	6916-6919	are	
25-90	6920-6923	not	
25-91	6924-6930	needed	
25-92	6931-6933	in	
25-93	6934-6942	replicas	
25-94	6942-6943	,	
25-95	6944-6947	can	
25-96	6948-6950	be	
25-97	6951-6954	set	
25-98	6955-6957	as	
25-99	6958-6966	UNLOGGED	
25-100	6966-6967	:	
25-101	6968-6974	CREATE	
25-102	6975-6983	UNLOGGED	
25-103	6984-6989	TABLE	
25-104	6990-7003	staging_table	
25-105	7004-7005	(	
25-106	7006-7007	/	
25-107	7007-7008	*	
25-108	7009-7014	table	
25-109	7015-7025	definition	
25-110	7026-7027	*	
25-111	7027-7028	/	
25-112	7029-7030	)	
25-113	7030-7031	;	

#Text=BEWARE: Before using UNLOGGED make sure you understand its full implications. Implement Complete Processes Using WITH and RETURNING Say you have a users table, and you find that you have some duplicates in the table: Table setup CREATE TABLE users ( id SERIAL PRIMARY KEY,
26-1	7032-7038	BEWARE	
26-2	7038-7039	:	
26-3	7040-7046	Before	
26-4	7047-7052	using	
26-5	7053-7061	UNLOGGED	
26-6	7062-7066	make	
26-7	7067-7071	sure	
26-8	7072-7075	you	
26-9	7076-7086	understand	
26-10	7087-7090	its	
26-11	7091-7095	full	
26-12	7096-7108	implications	
26-13	7108-7109	.	
26-14	7110-7119	Implement	
26-15	7120-7128	Complete	
26-16	7129-7138	Processes	
26-17	7139-7144	Using	
26-18	7145-7149	WITH	
26-19	7150-7153	and	
26-20	7154-7163	RETURNING	
26-21	7164-7167	Say	
26-22	7168-7171	you	
26-23	7172-7176	have	
26-24	7177-7178	a	
26-25	7179-7184	users	
26-26	7185-7190	table	
26-27	7190-7191	,	
26-28	7192-7195	and	
26-29	7196-7199	you	
26-30	7200-7204	find	
26-31	7205-7209	that	
26-32	7210-7213	you	
26-33	7214-7218	have	
26-34	7219-7223	some	
26-35	7224-7234	duplicates	
26-36	7235-7237	in	
26-37	7238-7241	the	
26-38	7242-7247	table	
26-39	7247-7248	:	
26-40	7249-7254	Table	
26-41	7255-7260	setup	
26-42	7261-7267	CREATE	
26-43	7268-7273	TABLE	
26-44	7274-7279	users	
26-45	7280-7281	(	
26-46	7282-7284	id	
26-47	7285-7291	SERIAL	
26-48	7292-7299	PRIMARY	
26-49	7300-7303	KEY	
26-50	7303-7304	,	

#Text=email TEXT UNIQUE CREATE TABLE orders ( id SERIAL PRIMARY KEY, user_id INT, CONSTRAINT orders_user_fk FOREIGN KEY (user_id)
27-1	7305-7310	email	
27-2	7311-7315	TEXT	
27-3	7316-7322	UNIQUE	
27-4	7323-7329	CREATE	
27-5	7330-7335	TABLE	
27-6	7336-7342	orders	
27-7	7343-7344	(	
27-8	7345-7347	id	
27-9	7348-7354	SERIAL	
27-10	7355-7362	PRIMARY	
27-11	7363-7366	KEY	
27-12	7366-7367	,	
27-13	7368-7375	user_id	
27-14	7376-7379	INT	
27-15	7379-7380	,	
27-16	7381-7391	CONSTRAINT	
27-17	7392-7406	orders_user_fk	
27-18	7407-7414	FOREIGN	
27-19	7415-7418	KEY	
27-20	7419-7420	(	
27-21	7420-7427	user_id	
27-22	7427-7428	)	

#Text=REFERENCES USERS(id) INSERT INTO users (email) VALUES ('foo@bar.baz'), ('me@hakibenita.com'), ('ME@hakibenita.com');
28-1	7429-7439	REFERENCES	
28-2	7440-7445	USERS	
28-3	7445-7446	(	
28-4	7446-7448	id	
28-5	7448-7449	)	
28-6	7450-7456	INSERT	
28-7	7457-7461	INTO	
28-8	7462-7467	users	
28-9	7468-7469	(	
28-10	7469-7474	email	
28-11	7474-7475	)	
28-12	7476-7482	VALUES	
28-13	7483-7484	(	
28-14	7484-7485	'	
28-15	7485-7488	foo	
28-16	7488-7489	@	
28-17	7489-7496	bar.baz	
28-18	7496-7497	'	
28-19	7497-7498	)	
28-20	7498-7499	,	
28-21	7500-7501	(	
28-22	7501-7502	'	
28-23	7502-7504	me	
28-24	7504-7505	@	
28-25	7505-7519	hakibenita.com	
28-26	7519-7520	'	
28-27	7520-7521	)	
28-28	7521-7522	,	
28-29	7523-7524	(	
28-30	7524-7525	'	
28-31	7525-7527	ME	
28-32	7527-7528	@	
28-33	7528-7542	hakibenita.com	
28-34	7542-7543	'	
28-35	7543-7544	)	
28-36	7544-7545	;	

#Text=INSERT INTO orders (user_id) VALUES (1), (1), (2), (3), (3); db=# SELECT u.id, u.email, o.id as order_id
29-1	7546-7552	INSERT	
29-2	7553-7557	INTO	
29-3	7558-7564	orders	
29-4	7565-7566	(	
29-5	7566-7573	user_id	
29-6	7573-7574	)	
29-7	7575-7581	VALUES	
29-8	7582-7583	(	
29-9	7583-7584	1	
29-10	7584-7585	)	
29-11	7585-7586	,	
29-12	7587-7588	(	
29-13	7588-7589	1	
29-14	7589-7590	)	
29-15	7590-7591	,	
29-16	7592-7593	(	
29-17	7593-7594	2	
29-18	7594-7595	)	
29-19	7595-7596	,	
29-20	7597-7598	(	
29-21	7598-7599	3	
29-22	7599-7600	)	
29-23	7600-7601	,	
29-24	7602-7603	(	
29-25	7603-7604	3	
29-26	7604-7605	)	
29-27	7605-7606	;	
29-28	7607-7609	db	
29-29	7609-7610	=	
29-30	7610-7611	#	
29-31	7612-7618	SELECT	
29-32	7619-7623	u.id	
29-33	7623-7624	,	
29-34	7625-7632	u.email	
29-35	7632-7633	,	
29-36	7634-7638	o.id	
29-37	7639-7641	as	
29-38	7642-7650	order_id	

#Text=FROM orders o JOIN users u ON o.user_id = u.id; id | email | order_id ----+-------------------+---------- 1 | foo@bar.baz
30-1	7651-7655	FROM	
30-2	7656-7662	orders	
30-3	7663-7664	o	
30-4	7665-7669	JOIN	
30-5	7670-7675	users	
30-6	7676-7677	u	
30-7	7678-7680	ON	
30-8	7681-7690	o.user_id	
30-9	7691-7692	=	
30-10	7693-7697	u.id	
30-11	7697-7698	;	
30-12	7699-7701	id	
30-13	7702-7703	|	
30-14	7704-7709	email	
30-15	7710-7711	|	
30-16	7712-7720	order_id	
30-17	7721-7722	-	
30-18	7722-7723	-	
30-19	7723-7724	-	
30-20	7724-7725	-	
30-21	7725-7726	+	
30-22	7726-7727	-	
30-23	7727-7728	-	
30-24	7728-7729	-	
30-25	7729-7730	-	
30-26	7730-7731	-	
30-27	7731-7732	-	
30-28	7732-7733	-	
30-29	7733-7734	-	
30-30	7734-7735	-	
30-31	7735-7736	-	
30-32	7736-7737	-	
30-33	7737-7738	-	
30-34	7738-7739	-	
30-35	7739-7740	-	
30-36	7740-7741	-	
30-37	7741-7742	-	
30-38	7742-7743	-	
30-39	7743-7744	-	
30-40	7744-7745	-	
30-41	7745-7746	+	
30-42	7746-7747	-	
30-43	7747-7748	-	
30-44	7748-7749	-	
30-45	7749-7750	-	
30-46	7750-7751	-	
30-47	7751-7752	-	
30-48	7752-7753	-	
30-49	7753-7754	-	
30-50	7754-7755	-	
30-51	7755-7756	-	
30-52	7757-7758	1	
30-53	7759-7760	|	
30-54	7761-7764	foo	
30-55	7764-7765	@	
30-56	7765-7772	bar.baz	

#Text=1 | foo@bar.baz 2 | me@hakibenita.com | 3 | ME@hakibenita.com | 3 | ME@hakibenita.com |
31-1	7773-7774	1	
31-2	7775-7776	|	
31-3	7777-7780	foo	
31-4	7780-7781	@	
31-5	7781-7788	bar.baz	
31-6	7789-7790	2	
31-7	7791-7792	|	
31-8	7793-7795	me	
31-9	7795-7796	@	
31-10	7796-7810	hakibenita.com	
31-11	7811-7812	|	
31-12	7813-7814	3	
31-13	7815-7816	|	
31-14	7817-7819	ME	
31-15	7819-7820	@	
31-16	7820-7834	hakibenita.com	
31-17	7835-7836	|	
31-18	7837-7838	3	
31-19	7839-7840	|	
31-20	7841-7843	ME	
31-21	7843-7844	@	
31-22	7844-7858	hakibenita.com	
31-23	7859-7860	|	

#Text=The user haki benita registered twice, once with the email ME@hakibenita.com and again with me@hakibenita.com. Because we didn't normalize the emails when we inserted them into the table, we now have to deal with duplication. To consolidate the duplicate users, we want to: Identify duplicate users by lower case email Update orders to reference one of the duplicate users Remove the duplicate users from the users table One way to consolidate duplicate users is to use an intermediate table:
32-1	7861-7864	The	
32-2	7865-7869	user	
32-3	7870-7874	haki	
32-4	7875-7881	benita	
32-5	7882-7892	registered	
32-6	7893-7898	twice	
32-7	7898-7899	,	
32-8	7900-7904	once	
32-9	7905-7909	with	
32-10	7910-7913	the	
32-11	7914-7919	email	
32-12	7920-7922	ME	
32-13	7922-7923	@	
32-14	7923-7937	hakibenita.com	
32-15	7938-7941	and	
32-16	7942-7947	again	
32-17	7948-7952	with	
32-18	7953-7955	me	
32-19	7955-7956	@	
32-20	7956-7970	hakibenita.com	
32-21	7970-7971	.	
32-22	7972-7979	Because	
32-23	7980-7982	we	
32-24	7983-7989	didn't	
32-25	7990-7999	normalize	
32-26	8000-8003	the	
32-27	8004-8010	emails	
32-28	8011-8015	when	
32-29	8016-8018	we	
32-30	8019-8027	inserted	
32-31	8028-8032	them	
32-32	8033-8037	into	
32-33	8038-8041	the	
32-34	8042-8047	table	
32-35	8047-8048	,	
32-36	8049-8051	we	
32-37	8052-8055	now	
32-38	8056-8060	have	
32-39	8061-8063	to	
32-40	8064-8068	deal	
32-41	8069-8073	with	
32-42	8074-8085	duplication	
32-43	8085-8086	.	
32-44	8087-8089	To	
32-45	8090-8101	consolidate	
32-46	8102-8105	the	
32-47	8106-8115	duplicate	
32-48	8116-8121	users	
32-49	8121-8122	,	
32-50	8123-8125	we	
32-51	8126-8130	want	
32-52	8131-8133	to	
32-53	8133-8134	:	
32-54	8135-8143	Identify	
32-55	8144-8153	duplicate	
32-56	8154-8159	users	
32-57	8160-8162	by	
32-58	8163-8168	lower	
32-59	8169-8173	case	
32-60	8174-8179	email	
32-61	8180-8186	Update	
32-62	8187-8193	orders	
32-63	8194-8196	to	
32-64	8197-8206	reference	
32-65	8207-8210	one	
32-66	8211-8213	of	
32-67	8214-8217	the	
32-68	8218-8227	duplicate	
32-69	8228-8233	users	
32-70	8234-8240	Remove	
32-71	8241-8244	the	
32-72	8245-8254	duplicate	
32-73	8255-8260	users	
32-74	8261-8265	from	
32-75	8266-8269	the	
32-76	8270-8275	users	
32-77	8276-8281	table	
32-78	8282-8285	One	
32-79	8286-8289	way	
32-80	8290-8292	to	
32-81	8293-8304	consolidate	
32-82	8305-8314	duplicate	
32-83	8315-8320	users	
32-84	8321-8323	is	
32-85	8324-8326	to	
32-86	8327-8330	use	
32-87	8331-8333	an	
32-88	8334-8346	intermediate	
32-89	8347-8352	table	
32-90	8352-8353	:	

#Text=db=# CREATE UNLOGGED TABLE duplicate_users AS db-# SELECT db-# lower(email) AS normalized_email, db-# min(id) AS convert_to_user, db-#
33-1	8354-8356	db	
33-2	8356-8357	=	
33-3	8357-8358	#	
33-4	8359-8365	CREATE	
33-5	8366-8374	UNLOGGED	
33-6	8375-8380	TABLE	
33-7	8381-8396	duplicate_users	
33-8	8397-8399	AS	
33-9	8400-8402	db	
33-10	8402-8403	-	
33-11	8403-8404	#	
33-12	8405-8411	SELECT	
33-13	8412-8414	db	
33-14	8414-8415	-	
33-15	8415-8416	#	
33-16	8417-8422	lower	
33-17	8422-8423	(	
33-18	8423-8428	email	
33-19	8428-8429	)	
33-20	8430-8432	AS	
33-21	8433-8449	normalized_email	
33-22	8449-8450	,	
33-23	8451-8453	db	
33-24	8453-8454	-	
33-25	8454-8455	#	
33-26	8456-8459	min	
33-27	8459-8460	(	
33-28	8460-8462	id	
33-29	8462-8463	)	
33-30	8464-8466	AS	
33-31	8467-8482	convert_to_user	
33-32	8482-8483	,	
33-33	8484-8486	db	
33-34	8486-8487	-	
33-35	8487-8488	#	

#Text=array_remove(ARRAY_AGG(id), min(id)) as convert_from_users db-# FROM db-# users db-# GROUP BY db-# normalized_email db-# HAVING db-#
34-1	8489-8501	array_remove	
34-2	8501-8502	(	
34-3	8502-8511	ARRAY_AGG	
34-4	8511-8512	(	
34-5	8512-8514	id	
34-6	8514-8515	)	
34-7	8515-8516	,	
34-8	8517-8520	min	
34-9	8520-8521	(	
34-10	8521-8523	id	
34-11	8523-8524	)	
34-12	8524-8525	)	
34-13	8526-8528	as	
34-14	8529-8547	convert_from_users	
34-15	8548-8550	db	
34-16	8550-8551	-	
34-17	8551-8552	#	
34-18	8553-8557	FROM	
34-19	8558-8560	db	
34-20	8560-8561	-	
34-21	8561-8562	#	
34-22	8563-8568	users	
34-23	8569-8571	db	
34-24	8571-8572	-	
34-25	8572-8573	#	
34-26	8574-8579	GROUP	
34-27	8580-8582	BY	
34-28	8583-8585	db	
34-29	8585-8586	-	
34-30	8586-8587	#	
34-31	8588-8604	normalized_email	
34-32	8605-8607	db	
34-33	8607-8608	-	
34-34	8608-8609	#	
34-35	8610-8616	HAVING	
34-36	8617-8619	db	
34-37	8619-8620	-	
34-38	8620-8621	#	

#Text=count(*) > 1; CREATE TABLE db=# SELECT * FROM duplicate_users; normalized_email | convert_to_user | convert_from_users
35-1	8622-8627	count	
35-2	8627-8628	(	
35-3	8628-8629	*	
35-4	8629-8630	)	
35-5	8631-8632	>	
35-6	8633-8634	1	
35-7	8634-8635	;	
35-8	8636-8642	CREATE	
35-9	8643-8648	TABLE	
35-10	8649-8651	db	
35-11	8651-8652	=	
35-12	8652-8653	#	
35-13	8654-8660	SELECT	
35-14	8661-8662	*	
35-15	8663-8667	FROM	
35-16	8668-8683	duplicate_users	
35-17	8683-8684	;	
35-18	8685-8701	normalized_email	
35-19	8702-8703	|	
35-20	8704-8719	convert_to_user	
35-21	8720-8721	|	
35-22	8722-8740	convert_from_users	

#Text=-------------------+-----------------+-------------------- me@hakibenita.com | 2 | {3} The intermediate table holds a mapping of duplicate users. For each user that appears more than once with the same normalized email address, we define the user with the min ID as the user we convert all duplicates to. The other users are kept in an array column, and all the references to these users will be updated.
36-1	8741-8742	-	
36-2	8742-8743	-	
36-3	8743-8744	-	
36-4	8744-8745	-	
36-5	8745-8746	-	
36-6	8746-8747	-	
36-7	8747-8748	-	
36-8	8748-8749	-	
36-9	8749-8750	-	
36-10	8750-8751	-	
36-11	8751-8752	-	
36-12	8752-8753	-	
36-13	8753-8754	-	
36-14	8754-8755	-	
36-15	8755-8756	-	
36-16	8756-8757	-	
36-17	8757-8758	-	
36-18	8758-8759	-	
36-19	8759-8760	-	
36-20	8760-8761	+	
36-21	8761-8762	-	
36-22	8762-8763	-	
36-23	8763-8764	-	
36-24	8764-8765	-	
36-25	8765-8766	-	
36-26	8766-8767	-	
36-27	8767-8768	-	
36-28	8768-8769	-	
36-29	8769-8770	-	
36-30	8770-8771	-	
36-31	8771-8772	-	
36-32	8772-8773	-	
36-33	8773-8774	-	
36-34	8774-8775	-	
36-35	8775-8776	-	
36-36	8776-8777	-	
36-37	8777-8778	-	
36-38	8778-8779	+	
36-39	8779-8780	-	
36-40	8780-8781	-	
36-41	8781-8782	-	
36-42	8782-8783	-	
36-43	8783-8784	-	
36-44	8784-8785	-	
36-45	8785-8786	-	
36-46	8786-8787	-	
36-47	8787-8788	-	
36-48	8788-8789	-	
36-49	8789-8790	-	
36-50	8790-8791	-	
36-51	8791-8792	-	
36-52	8792-8793	-	
36-53	8793-8794	-	
36-54	8794-8795	-	
36-55	8795-8796	-	
36-56	8796-8797	-	
36-57	8797-8798	-	
36-58	8798-8799	-	
36-59	8800-8802	me	
36-60	8802-8803	@	
36-61	8803-8817	hakibenita.com	
36-62	8818-8819	|	
36-63	8820-8821	2	
36-64	8822-8823	|	
36-65	8824-8825	{	
36-66	8825-8826	3	
36-67	8826-8827	}	
36-68	8828-8831	The	
36-69	8832-8844	intermediate	
36-70	8845-8850	table	
36-71	8851-8856	holds	
36-72	8857-8858	a	
36-73	8859-8866	mapping	
36-74	8867-8869	of	
36-75	8870-8879	duplicate	
36-76	8880-8885	users	
36-77	8885-8886	.	
36-78	8887-8890	For	
36-79	8891-8895	each	
36-80	8896-8900	user	
36-81	8901-8905	that	
36-82	8906-8913	appears	
36-83	8914-8918	more	
36-84	8919-8923	than	
36-85	8924-8928	once	
36-86	8929-8933	with	
36-87	8934-8937	the	
36-88	8938-8942	same	
36-89	8943-8953	normalized	
36-90	8954-8959	email	
36-91	8960-8967	address	
36-92	8967-8968	,	
36-93	8969-8971	we	
36-94	8972-8978	define	
36-95	8979-8982	the	
36-96	8983-8987	user	
36-97	8988-8992	with	
36-98	8993-8996	the	
36-99	8997-9000	min	
36-100	9001-9003	ID	
36-101	9004-9006	as	
36-102	9007-9010	the	
36-103	9011-9015	user	
36-104	9016-9018	we	
36-105	9019-9026	convert	
36-106	9027-9030	all	
36-107	9031-9041	duplicates	
36-108	9042-9044	to	
36-109	9044-9045	.	
36-110	9046-9049	The	
36-111	9050-9055	other	
36-112	9056-9061	users	
36-113	9062-9065	are	
36-114	9066-9070	kept	
36-115	9071-9073	in	
36-116	9074-9076	an	
36-117	9077-9082	array	
36-118	9083-9089	column	
36-119	9089-9090	,	
36-120	9091-9094	and	
36-121	9095-9098	all	
36-122	9099-9102	the	
36-123	9103-9113	references	
36-124	9114-9116	to	
36-125	9117-9122	these	
36-126	9123-9128	users	
36-127	9129-9133	will	
36-128	9134-9136	be	
36-129	9137-9144	updated	
36-130	9144-9145	.	

#Text=Using the intermediate table, we update references of duplicate users in the orders table: db=# UPDATE db-# orders o db-# SET db-# user_id = du.convert_to_user db-# FROM db-#
37-1	9146-9151	Using	
37-2	9152-9155	the	
37-3	9156-9168	intermediate	
37-4	9169-9174	table	
37-5	9174-9175	,	
37-6	9176-9178	we	
37-7	9179-9185	update	
37-8	9186-9196	references	
37-9	9197-9199	of	
37-10	9200-9209	duplicate	
37-11	9210-9215	users	
37-12	9216-9218	in	
37-13	9219-9222	the	
37-14	9223-9229	orders	
37-15	9230-9235	table	
37-16	9235-9236	:	
37-17	9237-9239	db	
37-18	9239-9240	=	
37-19	9240-9241	#	
37-20	9242-9248	UPDATE	
37-21	9249-9251	db	
37-22	9251-9252	-	
37-23	9252-9253	#	
37-24	9254-9260	orders	
37-25	9261-9262	o	
37-26	9263-9265	db	
37-27	9265-9266	-	
37-28	9266-9267	#	
37-29	9268-9271	SET	
37-30	9272-9274	db	
37-31	9274-9275	-	
37-32	9275-9276	#	
37-33	9277-9284	user_id	
37-34	9285-9286	=	
37-35	9287-9305	du.convert_to_user	
37-36	9306-9308	db	
37-37	9308-9309	-	
37-38	9309-9310	#	
37-39	9311-9315	FROM	
37-40	9316-9318	db	
37-41	9318-9319	-	
37-42	9319-9320	#	

#Text=duplicate_users du db-# WHERE db-# o.user_id = ANY(du.convert_from_users); UPDATE 2 Now that there are no more references, we can safely delete the duplicate users from the users table:
38-1	9321-9336	duplicate_users	
38-2	9337-9339	du	
38-3	9340-9342	db	
38-4	9342-9343	-	
38-5	9343-9344	#	
38-6	9345-9350	WHERE	
38-7	9351-9353	db	
38-8	9353-9354	-	
38-9	9354-9355	#	
38-10	9356-9365	o.user_id	
38-11	9366-9367	=	
38-12	9368-9371	ANY	
38-13	9371-9372	(	
38-14	9372-9393	du.convert_from_users	
38-15	9393-9394	)	
38-16	9394-9395	;	
38-17	9396-9402	UPDATE	
38-18	9403-9404	2	
38-19	9405-9408	Now	
38-20	9409-9413	that	
38-21	9414-9419	there	
38-22	9420-9423	are	
38-23	9424-9426	no	
38-24	9427-9431	more	
38-25	9432-9442	references	
38-26	9442-9443	,	
38-27	9444-9446	we	
38-28	9447-9450	can	
38-29	9451-9457	safely	
38-30	9458-9464	delete	
38-31	9465-9468	the	
38-32	9469-9478	duplicate	
38-33	9479-9484	users	
38-34	9485-9489	from	
38-35	9490-9493	the	
38-36	9494-9499	users	
38-37	9500-9505	table	
38-38	9505-9506	:	

#Text=db=# DELETE FROM db-# users db-# WHERE db-# id IN ( db(# SELECT unnest(convert_from_users) db(# FROM duplicate_users
39-1	9507-9509	db	
39-2	9509-9510	=	
39-3	9510-9511	#	
39-4	9512-9518	DELETE	
39-5	9519-9523	FROM	
39-6	9524-9526	db	
39-7	9526-9527	-	
39-8	9527-9528	#	
39-9	9529-9534	users	
39-10	9535-9537	db	
39-11	9537-9538	-	
39-12	9538-9539	#	
39-13	9540-9545	WHERE	
39-14	9546-9548	db	
39-15	9548-9549	-	
39-16	9549-9550	#	
39-17	9551-9553	id	
39-18	9554-9556	IN	
39-19	9557-9558	(	
39-20	9559-9561	db	
39-21	9561-9562	(	
39-22	9562-9563	#	
39-23	9564-9570	SELECT	
39-24	9571-9577	unnest	
39-25	9577-9578	(	
39-26	9578-9596	convert_from_users	
39-27	9596-9597	)	
39-28	9598-9600	db	
39-29	9600-9601	(	
39-30	9601-9602	#	
39-31	9603-9607	FROM	
39-32	9608-9623	duplicate_users	

#Text=db(# DELETE 1 Notice that we used the function unnest to "transpose" the array, that is, turn each array element into a row. This is the result: db=# SELECT u.id, u.email, o.id as order_id
40-1	9624-9626	db	
40-2	9626-9627	(	
40-3	9627-9628	#	
40-4	9629-9635	DELETE	
40-5	9636-9637	1	
40-6	9638-9644	Notice	
40-7	9645-9649	that	
40-8	9650-9652	we	
40-9	9653-9657	used	
40-10	9658-9661	the	
40-11	9662-9670	function	
40-12	9671-9677	unnest	
40-13	9678-9680	to	
40-14	9681-9682	"	
40-15	9682-9691	transpose	
40-16	9691-9692	"	
40-17	9693-9696	the	
40-18	9697-9702	array	
40-19	9702-9703	,	
40-20	9704-9708	that	
40-21	9709-9711	is	
40-22	9711-9712	,	
40-23	9713-9717	turn	
40-24	9718-9722	each	
40-25	9723-9728	array	
40-26	9729-9736	element	
40-27	9737-9741	into	
40-28	9742-9743	a	
40-29	9744-9747	row	
40-30	9747-9748	.	
40-31	9749-9753	This	
40-32	9754-9756	is	
40-33	9757-9760	the	
40-34	9761-9767	result	
40-35	9767-9768	:	
40-36	9769-9771	db	
40-37	9771-9772	=	
40-38	9772-9773	#	
40-39	9774-9780	SELECT	
40-40	9781-9785	u.id	
40-41	9785-9786	,	
40-42	9787-9794	u.email	
40-43	9794-9795	,	
40-44	9796-9800	o.id	
40-45	9801-9803	as	
40-46	9804-9812	order_id	

#Text=db-# FROM orders o JOIN users u ON o.user_id = u.id; id | email | order_id ----+-------------------+---------- 1 | foo@bar.baz
41-1	9813-9815	db	
41-2	9815-9816	-	
41-3	9816-9817	#	
41-4	9818-9822	FROM	
41-5	9823-9829	orders	
41-6	9830-9831	o	
41-7	9832-9836	JOIN	
41-8	9837-9842	users	
41-9	9843-9844	u	
41-10	9845-9847	ON	
41-11	9848-9857	o.user_id	
41-12	9858-9859	=	
41-13	9860-9864	u.id	
41-14	9864-9865	;	
41-15	9866-9868	id	
41-16	9869-9870	|	
41-17	9871-9876	email	
41-18	9877-9878	|	
41-19	9879-9887	order_id	
41-20	9888-9889	-	
41-21	9889-9890	-	
41-22	9890-9891	-	
41-23	9891-9892	-	
41-24	9892-9893	+	
41-25	9893-9894	-	
41-26	9894-9895	-	
41-27	9895-9896	-	
41-28	9896-9897	-	
41-29	9897-9898	-	
41-30	9898-9899	-	
41-31	9899-9900	-	
41-32	9900-9901	-	
41-33	9901-9902	-	
41-34	9902-9903	-	
41-35	9903-9904	-	
41-36	9904-9905	-	
41-37	9905-9906	-	
41-38	9906-9907	-	
41-39	9907-9908	-	
41-40	9908-9909	-	
41-41	9909-9910	-	
41-42	9910-9911	-	
41-43	9911-9912	-	
41-44	9912-9913	+	
41-45	9913-9914	-	
41-46	9914-9915	-	
41-47	9915-9916	-	
41-48	9916-9917	-	
41-49	9917-9918	-	
41-50	9918-9919	-	
41-51	9919-9920	-	
41-52	9920-9921	-	
41-53	9921-9922	-	
41-54	9922-9923	-	
41-55	9924-9925	1	
41-56	9926-9927	|	
41-57	9928-9931	foo	
41-58	9931-9932	@	
41-59	9932-9939	bar.baz	

#Text=1 | foo@bar.baz 2 | me@hakibenita.com | 2 | me@hakibenita.com | 2 | me@hakibenita.com | Nice, all occurrences of user 3 (ME@hakibenita.com) are converted to user 2 (me@hakibenita.com).
42-1	9940-9941	1	
42-2	9942-9943	|	
42-3	9944-9947	foo	
42-4	9947-9948	@	
42-5	9948-9955	bar.baz	
42-6	9956-9957	2	
42-7	9958-9959	|	
42-8	9960-9962	me	
42-9	9962-9963	@	
42-10	9963-9977	hakibenita.com	
42-11	9978-9979	|	
42-12	9980-9981	2	
42-13	9982-9983	|	
42-14	9984-9986	me	
42-15	9986-9987	@	
42-16	9987-10001	hakibenita.com	
42-17	10002-10003	|	
42-18	10004-10005	2	
42-19	10006-10007	|	
42-20	10008-10010	me	
42-21	10010-10011	@	
42-22	10011-10025	hakibenita.com	
42-23	10026-10027	|	
42-24	10028-10032	Nice	
42-25	10032-10033	,	
42-26	10034-10037	all	
42-27	10038-10049	occurrences	
42-28	10050-10052	of	
42-29	10053-10057	user	
42-30	10058-10059	3	
42-31	10060-10061	(	
42-32	10061-10063	ME	
42-33	10063-10064	@	
42-34	10064-10078	hakibenita.com	
42-35	10078-10079	)	
42-36	10080-10083	are	
42-37	10084-10093	converted	
42-38	10094-10096	to	
42-39	10097-10101	user	
42-40	10102-10103	2	
42-41	10104-10105	(	
42-42	10105-10107	me	
42-43	10107-10108	@	
42-44	10108-10122	hakibenita.com	
42-45	10122-10123	)	
42-46	10123-10124	.	

#Text=We can also verify that the duplicate users were deleted from the users table: db=# SELECT * FROM users; id | email ----+------------------- 1 | foo@bar.baz
43-1	10125-10127	We	
43-2	10128-10131	can	
43-3	10132-10136	also	
43-4	10137-10143	verify	
43-5	10144-10148	that	
43-6	10149-10152	the	
43-7	10153-10162	duplicate	
43-8	10163-10168	users	
43-9	10169-10173	were	
43-10	10174-10181	deleted	
43-11	10182-10186	from	
43-12	10187-10190	the	
43-13	10191-10196	users	
43-14	10197-10202	table	
43-15	10202-10203	:	
43-16	10204-10206	db	
43-17	10206-10207	=	
43-18	10207-10208	#	
43-19	10209-10215	SELECT	
43-20	10216-10217	*	
43-21	10218-10222	FROM	
43-22	10223-10228	users	
43-23	10228-10229	;	
43-24	10230-10232	id	
43-25	10233-10234	|	
43-26	10235-10240	email	
43-27	10241-10242	-	
43-28	10242-10243	-	
43-29	10243-10244	-	
43-30	10244-10245	-	
43-31	10245-10246	+	
43-32	10246-10247	-	
43-33	10247-10248	-	
43-34	10248-10249	-	
43-35	10249-10250	-	
43-36	10250-10251	-	
43-37	10251-10252	-	
43-38	10252-10253	-	
43-39	10253-10254	-	
43-40	10254-10255	-	
43-41	10255-10256	-	
43-42	10256-10257	-	
43-43	10257-10258	-	
43-44	10258-10259	-	
43-45	10259-10260	-	
43-46	10260-10261	-	
43-47	10261-10262	-	
43-48	10262-10263	-	
43-49	10263-10264	-	
43-50	10264-10265	-	
43-51	10266-10267	1	
43-52	10268-10269	|	
43-53	10270-10273	foo	
43-54	10273-10274	@	
43-55	10274-10281	bar.baz	

#Text=2 | me@hakibenita.com Now we can get rid of the intermediate table: db=# DROP TABLE duplicate_users; DROP TABLE This is fine, but very long and needs cleaning up! Is there a better way? Using Common Table Expressions (CTE)
44-1	10282-10283	2	
44-2	10284-10285	|	
44-3	10286-10288	me	
44-4	10288-10289	@	
44-5	10289-10303	hakibenita.com	
44-6	10304-10307	Now	
44-7	10308-10310	we	
44-8	10311-10314	can	
44-9	10315-10318	get	
44-10	10319-10322	rid	
44-11	10323-10325	of	
44-12	10326-10329	the	
44-13	10330-10342	intermediate	
44-14	10343-10348	table	
44-15	10348-10349	:	
44-16	10350-10352	db	
44-17	10352-10353	=	
44-18	10353-10354	#	
44-19	10355-10359	DROP	
44-20	10360-10365	TABLE	
44-21	10366-10381	duplicate_users	
44-22	10381-10382	;	
44-23	10383-10387	DROP	
44-24	10388-10393	TABLE	
44-25	10394-10398	This	
44-26	10399-10401	is	
44-27	10402-10406	fine	
44-28	10406-10407	,	
44-29	10408-10411	but	
44-30	10412-10416	very	
44-31	10417-10421	long	
44-32	10422-10425	and	
44-33	10426-10431	needs	
44-34	10432-10440	cleaning	
44-35	10441-10443	up	
44-36	10443-10444	!	
44-37	10445-10447	Is	
44-38	10448-10453	there	
44-39	10454-10455	a	
44-40	10456-10462	better	
44-41	10463-10466	way	
44-42	10466-10467	?	
44-43	10468-10473	Using	
44-44	10474-10480	Common	
44-45	10481-10486	Table	
44-46	10487-10498	Expressions	
44-47	10499-10500	(	
44-48	10500-10503	CTE	
44-49	10503-10504	)	

#Text=Using Common Table Expressions, also known as the WITH clause, we can perform the entire process with just one SQL statement: WITH duplicate_users AS ( SELECT min(id) AS convert_to_user, array_remove(ARRAY_AGG(id), min(id)) as convert_from_users FROM users
45-1	10505-10510	Using	
45-2	10511-10517	Common	
45-3	10518-10523	Table	
45-4	10524-10535	Expressions	
45-5	10535-10536	,	
45-6	10537-10541	also	
45-7	10542-10547	known	
45-8	10548-10550	as	
45-9	10551-10554	the	
45-10	10555-10559	WITH	
45-11	10560-10566	clause	
45-12	10566-10567	,	
45-13	10568-10570	we	
45-14	10571-10574	can	
45-15	10575-10582	perform	
45-16	10583-10586	the	
45-17	10587-10593	entire	
45-18	10594-10601	process	
45-19	10602-10606	with	
45-20	10607-10611	just	
45-21	10612-10615	one	
45-22	10616-10619	SQL	
45-23	10620-10629	statement	
45-24	10629-10630	:	
45-25	10631-10635	WITH	
45-26	10636-10651	duplicate_users	
45-27	10652-10654	AS	
45-28	10655-10656	(	
45-29	10657-10663	SELECT	
45-30	10664-10667	min	
45-31	10667-10668	(	
45-32	10668-10670	id	
45-33	10670-10671	)	
45-34	10672-10674	AS	
45-35	10675-10690	convert_to_user	
45-36	10690-10691	,	
45-37	10692-10704	array_remove	
45-38	10704-10705	(	
45-39	10705-10714	ARRAY_AGG	
45-40	10714-10715	(	
45-41	10715-10717	id	
45-42	10717-10718	)	
45-43	10718-10719	,	
45-44	10720-10723	min	
45-45	10723-10724	(	
45-46	10724-10726	id	
45-47	10726-10727	)	
45-48	10727-10728	)	
45-49	10729-10731	as	
45-50	10732-10750	convert_from_users	
45-51	10751-10755	FROM	
45-52	10756-10761	users	

#Text=GROUP BY lower(email) HAVING count(*) > 1 update_orders_of_duplicate_users AS ( UPDATE orders o SET user_id = du.convert_to_user FROM
46-1	10762-10767	GROUP	
46-2	10768-10770	BY	
46-3	10771-10776	lower	
46-4	10776-10777	(	
46-5	10777-10782	email	
46-6	10782-10783	)	
46-7	10784-10790	HAVING	
46-8	10791-10796	count	
46-9	10796-10797	(	
46-10	10797-10798	*	
46-11	10798-10799	)	
46-12	10800-10801	>	
46-13	10802-10803	1	
46-14	10804-10836	update_orders_of_duplicate_users	
46-15	10837-10839	AS	
46-16	10840-10841	(	
46-17	10842-10848	UPDATE	
46-18	10849-10855	orders	
46-19	10856-10857	o	
46-20	10858-10861	SET	
46-21	10862-10869	user_id	
46-22	10870-10871	=	
46-23	10872-10890	du.convert_to_user	
46-24	10891-10895	FROM	

#Text=duplicate_users du WHERE o.user_id = ANY(du.convert_from_users) DELETE FROM users WHERE id IN ( SELECT unnest(convert_from_users)
47-1	10896-10911	duplicate_users	
47-2	10912-10914	du	
47-3	10915-10920	WHERE	
47-4	10921-10930	o.user_id	
47-5	10931-10932	=	
47-6	10933-10936	ANY	
47-7	10936-10937	(	
47-8	10937-10958	du.convert_from_users	
47-9	10958-10959	)	
47-10	10960-10966	DELETE	
47-11	10967-10971	FROM	
47-12	10972-10977	users	
47-13	10978-10983	WHERE	
47-14	10984-10986	id	
47-15	10987-10989	IN	
47-16	10990-10991	(	
47-17	10992-10998	SELECT	
47-18	10999-11005	unnest	
47-19	11005-11006	(	
47-20	11006-11024	convert_from_users	
47-21	11024-11025	)	

#Text=FROM duplicate_users Instead of creating the intermediate table, we create a common table expression and reuse it multiple times. Returning Results From CTE A nice feature of executing DML inside a WITH clause, is that you can return data from it using the RETURNING keyword. For example, let's report the number of updated and deleted rows:
48-1	11026-11030	FROM	
48-2	11031-11046	duplicate_users	
48-3	11047-11054	Instead	
48-4	11055-11057	of	
48-5	11058-11066	creating	
48-6	11067-11070	the	
48-7	11071-11083	intermediate	
48-8	11084-11089	table	
48-9	11089-11090	,	
48-10	11091-11093	we	
48-11	11094-11100	create	
48-12	11101-11102	a	
48-13	11103-11109	common	
48-14	11110-11115	table	
48-15	11116-11126	expression	
48-16	11127-11130	and	
48-17	11131-11136	reuse	
48-18	11137-11139	it	
48-19	11140-11148	multiple	
48-20	11149-11154	times	
48-21	11154-11155	.	
48-22	11156-11165	Returning	
48-23	11166-11173	Results	
48-24	11174-11178	From	
48-25	11179-11182	CTE	
48-26	11183-11184	A	
48-27	11185-11189	nice	
48-28	11190-11197	feature	
48-29	11198-11200	of	
48-30	11201-11210	executing	
48-31	11211-11214	DML	
48-32	11215-11221	inside	
48-33	11222-11223	a	
48-34	11224-11228	WITH	
48-35	11229-11235	clause	
48-36	11235-11236	,	
48-37	11237-11239	is	
48-38	11240-11244	that	
48-39	11245-11248	you	
48-40	11249-11252	can	
48-41	11253-11259	return	
48-42	11260-11264	data	
48-43	11265-11269	from	
48-44	11270-11272	it	
48-45	11273-11278	using	
48-46	11279-11282	the	
48-47	11283-11292	RETURNING	
48-48	11293-11300	keyword	
48-49	11300-11301	.	
48-50	11302-11305	For	
48-51	11306-11313	example	
48-52	11313-11314	,	
48-53	11315-11320	let's	
48-54	11321-11327	report	
48-55	11328-11331	the	
48-56	11332-11338	number	
48-57	11339-11341	of	
48-58	11342-11349	updated	
48-59	11350-11353	and	
48-60	11354-11361	deleted	
48-61	11362-11366	rows	
48-62	11366-11367	:	

#Text=WITH duplicate_users AS ( SELECT min(id) AS convert_to_user, array_remove(ARRAY_AGG(id), min(id)) as convert_from_users FROM users GROUP BY lower(email)
49-1	11368-11372	WITH	
49-2	11373-11388	duplicate_users	
49-3	11389-11391	AS	
49-4	11392-11393	(	
49-5	11394-11400	SELECT	
49-6	11401-11404	min	
49-7	11404-11405	(	
49-8	11405-11407	id	
49-9	11407-11408	)	
49-10	11409-11411	AS	
49-11	11412-11427	convert_to_user	
49-12	11427-11428	,	
49-13	11429-11441	array_remove	
49-14	11441-11442	(	
49-15	11442-11451	ARRAY_AGG	
49-16	11451-11452	(	
49-17	11452-11454	id	
49-18	11454-11455	)	
49-19	11455-11456	,	
49-20	11457-11460	min	
49-21	11460-11461	(	
49-22	11461-11463	id	
49-23	11463-11464	)	
49-24	11464-11465	)	
49-25	11466-11468	as	
49-26	11469-11487	convert_from_users	
49-27	11488-11492	FROM	
49-28	11493-11498	users	
49-29	11499-11504	GROUP	
49-30	11505-11507	BY	
49-31	11508-11513	lower	
49-32	11513-11514	(	
49-33	11514-11519	email	
49-34	11519-11520	)	

#Text=HAVING count(*) > 1 update_orders_of_duplicate_users AS ( UPDATE orders o SET user_id = du.convert_to_user FROM duplicate_users du WHERE
50-1	11521-11527	HAVING	
50-2	11528-11533	count	
50-3	11533-11534	(	
50-4	11534-11535	*	
50-5	11535-11536	)	
50-6	11537-11538	>	
50-7	11539-11540	1	
50-8	11541-11573	update_orders_of_duplicate_users	
50-9	11574-11576	AS	
50-10	11577-11578	(	
50-11	11579-11585	UPDATE	
50-12	11586-11592	orders	
50-13	11593-11594	o	
50-14	11595-11598	SET	
50-15	11599-11606	user_id	
50-16	11607-11608	=	
50-17	11609-11627	du.convert_to_user	
50-18	11628-11632	FROM	
50-19	11633-11648	duplicate_users	
50-20	11649-11651	du	
50-21	11652-11657	WHERE	

#Text=o.user_id = ANY(du.convert_from_users) RETURNING o.id delete_duplicate_user AS ( DELETE FROM users WHERE id IN ( SELECT unnest(convert_from_users) FROM duplicate_users
51-1	11658-11667	o.user_id	
51-2	11668-11669	=	
51-3	11670-11673	ANY	
51-4	11673-11674	(	
51-5	11674-11695	du.convert_from_users	
51-6	11695-11696	)	
51-7	11697-11706	RETURNING	
51-8	11707-11711	o.id	
51-9	11712-11733	delete_duplicate_user	
51-10	11734-11736	AS	
51-11	11737-11738	(	
51-12	11739-11745	DELETE	
51-13	11746-11750	FROM	
51-14	11751-11756	users	
51-15	11757-11762	WHERE	
51-16	11763-11765	id	
51-17	11766-11768	IN	
51-18	11769-11770	(	
51-19	11771-11777	SELECT	
51-20	11778-11784	unnest	
51-21	11784-11785	(	
51-22	11785-11803	convert_from_users	
51-23	11803-11804	)	
51-24	11805-11809	FROM	
51-25	11810-11825	duplicate_users	

#Text=RETURNING id SELECT (SELECT count(*) FROM update_orders_of_duplicate_users) AS orders_updated, (SELECT count(*) FROM delete_duplicate_user) AS users_deleted This is the result:
52-1	11826-11835	RETURNING	
52-2	11836-11838	id	
52-3	11839-11845	SELECT	
52-4	11846-11847	(	
52-5	11847-11853	SELECT	
52-6	11854-11859	count	
52-7	11859-11860	(	
52-8	11860-11861	*	
52-9	11861-11862	)	
52-10	11863-11867	FROM	
52-11	11868-11900	update_orders_of_duplicate_users	
52-12	11900-11901	)	
52-13	11902-11904	AS	
52-14	11905-11919	orders_updated	
52-15	11919-11920	,	
52-16	11921-11922	(	
52-17	11922-11928	SELECT	
52-18	11929-11934	count	
52-19	11934-11935	(	
52-20	11935-11936	*	
52-21	11936-11937	)	
52-22	11938-11942	FROM	
52-23	11943-11964	delete_duplicate_user	
52-24	11964-11965	)	
52-25	11966-11968	AS	
52-26	11969-11982	users_deleted	
52-27	11983-11987	This	
52-28	11988-11990	is	
52-29	11991-11994	the	
52-30	11995-12001	result	
52-31	12001-12002	:	

#Text=orders_updated | users_deleted ----------------+--------------- 2 | The main appeal of this approach is that the entire process is executed in a single command, so no need to manage a transaction or worry about cleaning up the intermediate table if the process fails.
53-1	12003-12017	orders_updated	
53-2	12018-12019	|	
53-3	12020-12033	users_deleted	
53-4	12034-12035	-	
53-5	12035-12036	-	
53-6	12036-12037	-	
53-7	12037-12038	-	
53-8	12038-12039	-	
53-9	12039-12040	-	
53-10	12040-12041	-	
53-11	12041-12042	-	
53-12	12042-12043	-	
53-13	12043-12044	-	
53-14	12044-12045	-	
53-15	12045-12046	-	
53-16	12046-12047	-	
53-17	12047-12048	-	
53-18	12048-12049	-	
53-19	12049-12050	-	
53-20	12050-12051	+	
53-21	12051-12052	-	
53-22	12052-12053	-	
53-23	12053-12054	-	
53-24	12054-12055	-	
53-25	12055-12056	-	
53-26	12056-12057	-	
53-27	12057-12058	-	
53-28	12058-12059	-	
53-29	12059-12060	-	
53-30	12060-12061	-	
53-31	12061-12062	-	
53-32	12062-12063	-	
53-33	12063-12064	-	
53-34	12064-12065	-	
53-35	12065-12066	-	
53-36	12067-12068	2	
53-37	12069-12070	|	
53-38	12071-12074	The	
53-39	12075-12079	main	
53-40	12080-12086	appeal	
53-41	12087-12089	of	
53-42	12090-12094	this	
53-43	12095-12103	approach	
53-44	12104-12106	is	
53-45	12107-12111	that	
53-46	12112-12115	the	
53-47	12116-12122	entire	
53-48	12123-12130	process	
53-49	12131-12133	is	
53-50	12134-12142	executed	
53-51	12143-12145	in	
53-52	12146-12147	a	
53-53	12148-12154	single	
53-54	12155-12162	command	
53-55	12162-12163	,	
53-56	12164-12166	so	
53-57	12167-12169	no	
53-58	12170-12174	need	
53-59	12175-12177	to	
53-60	12178-12184	manage	
53-61	12185-12186	a	
53-62	12187-12198	transaction	
53-63	12199-12201	or	
53-64	12202-12207	worry	
53-65	12208-12213	about	
53-66	12214-12222	cleaning	
53-67	12223-12225	up	
53-68	12226-12229	the	
53-69	12230-12242	intermediate	
53-70	12243-12248	table	
53-71	12249-12251	if	
53-72	12252-12255	the	
53-73	12256-12263	process	
53-74	12264-12269	fails	
53-75	12269-12270	.	

#Text=CAUTION: A reader on Reddit pointed me to a possibly unpredictable behavior of executing DML in common table expressions: The sub-statements in WITH are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in WITH, the order in which the specified updates actually happen is unpredictable
54-1	12271-12278	CAUTION	
54-2	12278-12279	:	
54-3	12280-12281	A	
54-4	12282-12288	reader	
54-5	12289-12291	on	
54-6	12292-12298	Reddit	
54-7	12299-12306	pointed	
54-8	12307-12309	me	
54-9	12310-12312	to	
54-10	12313-12314	a	
54-11	12315-12323	possibly	
54-12	12324-12337	unpredictable	
54-13	12338-12346	behavior	
54-14	12347-12349	of	
54-15	12350-12359	executing	
54-16	12360-12363	DML	
54-17	12364-12366	in	
54-18	12367-12373	common	
54-19	12374-12379	table	
54-20	12380-12391	expressions	
54-21	12391-12392	:	
54-22	12393-12396	The	
54-23	12397-12411	sub-statements	
54-24	12412-12414	in	
54-25	12415-12419	WITH	
54-26	12420-12423	are	
54-27	12424-12432	executed	
54-28	12433-12445	concurrently	
54-29	12446-12450	with	
54-30	12451-12455	each	
54-31	12456-12461	other	
54-32	12462-12465	and	
54-33	12466-12470	with	
54-34	12471-12474	the	
54-35	12475-12479	main	
54-36	12480-12485	query	
54-37	12485-12486	.	
54-38	12487-12496	Therefore	
54-39	12496-12497	,	
54-40	12498-12502	when	
54-41	12503-12508	using	
54-42	12509-12523	data-modifying	
54-43	12524-12534	statements	
54-44	12535-12537	in	
54-45	12538-12542	WITH	
54-46	12542-12543	,	
54-47	12544-12547	the	
54-48	12548-12553	order	
54-49	12554-12556	in	
54-50	12557-12562	which	
54-51	12563-12566	the	
54-52	12567-12576	specified	
54-53	12577-12584	updates	
54-54	12585-12593	actually	
54-55	12594-12600	happen	
54-56	12601-12603	is	
54-57	12604-12617	unpredictable	

#Text=This means you cannot rely on the order in which independent sub-statements are executed. It seems that when there is a dependency between sub-statements, like in the example above, you can rely on a dependent sub-statement to execute before it is being used. Avoid Indexes on Columns With Low Selectivity Say you have a registration process where users sign up with an email address. To activate the account, they have to verify their email. Your table can look like this: db=# CREATE TABLE users (
55-1	12618-12622	This	
55-2	12623-12628	means	
55-3	12629-12632	you	
55-4	12633-12639	cannot	
55-5	12640-12644	rely	
55-6	12645-12647	on	
55-7	12648-12651	the	
55-8	12652-12657	order	
55-9	12658-12660	in	
55-10	12661-12666	which	
55-11	12667-12678	independent	
55-12	12679-12693	sub-statements	
55-13	12694-12697	are	
55-14	12698-12706	executed	
55-15	12706-12707	.	
55-16	12708-12710	It	
55-17	12711-12716	seems	
55-18	12717-12721	that	
55-19	12722-12726	when	
55-20	12727-12732	there	
55-21	12733-12735	is	
55-22	12736-12737	a	
55-23	12738-12748	dependency	
55-24	12749-12756	between	
55-25	12757-12771	sub-statements	
55-26	12771-12772	,	
55-27	12773-12777	like	
55-28	12778-12780	in	
55-29	12781-12784	the	
55-30	12785-12792	example	
55-31	12793-12798	above	
55-32	12798-12799	,	
55-33	12800-12803	you	
55-34	12804-12807	can	
55-35	12808-12812	rely	
55-36	12813-12815	on	
55-37	12816-12817	a	
55-38	12818-12827	dependent	
55-39	12828-12841	sub-statement	
55-40	12842-12844	to	
55-41	12845-12852	execute	
55-42	12853-12859	before	
55-43	12860-12862	it	
55-44	12863-12865	is	
55-45	12866-12871	being	
55-46	12872-12876	used	
55-47	12876-12877	.	
55-48	12878-12883	Avoid	
55-49	12884-12891	Indexes	
55-50	12892-12894	on	
55-51	12895-12902	Columns	
55-52	12903-12907	With	
55-53	12908-12911	Low	
55-54	12912-12923	Selectivity	
55-55	12924-12927	Say	
55-56	12928-12931	you	
55-57	12932-12936	have	
55-58	12937-12938	a	
55-59	12939-12951	registration	
55-60	12952-12959	process	
55-61	12960-12965	where	
55-62	12966-12971	users	
55-63	12972-12976	sign	
55-64	12977-12979	up	
55-65	12980-12984	with	
55-66	12985-12987	an	
55-67	12988-12993	email	
55-68	12994-13001	address	
55-69	13001-13002	.	
55-70	13003-13005	To	
55-71	13006-13014	activate	
55-72	13015-13018	the	
55-73	13019-13026	account	
55-74	13026-13027	,	
55-75	13028-13032	they	
55-76	13033-13037	have	
55-77	13038-13040	to	
55-78	13041-13047	verify	
55-79	13048-13053	their	
55-80	13054-13059	email	
55-81	13059-13060	.	
55-82	13061-13065	Your	
55-83	13066-13071	table	
55-84	13072-13075	can	
55-85	13076-13080	look	
55-86	13081-13085	like	
55-87	13086-13090	this	
55-88	13090-13091	:	
55-89	13092-13094	db	
55-90	13094-13095	=	
55-91	13095-13096	#	
55-92	13097-13103	CREATE	
55-93	13104-13109	TABLE	
55-94	13110-13115	users	
55-95	13116-13117	(	

#Text=db-# id serial, db-# username text, db-# activated boolean db-#); CREATE TABLE
56-1	13118-13120	db	
56-2	13120-13121	-	
56-3	13121-13122	#	
56-4	13123-13125	id	
56-5	13126-13132	serial	
56-6	13132-13133	,	
56-7	13134-13136	db	
56-8	13136-13137	-	
56-9	13137-13138	#	
56-10	13139-13147	username	
56-11	13148-13152	text	
56-12	13152-13153	,	
56-13	13154-13156	db	
56-14	13156-13157	-	
56-15	13157-13158	#	
56-16	13159-13168	activated	
56-17	13169-13176	boolean	
56-18	13177-13179	db	
56-19	13179-13180	-	
56-20	13180-13181	#	
56-21	13181-13182	)	
56-22	13182-13183	;	
56-23	13184-13190	CREATE	
56-24	13191-13196	TABLE	

#Text=Most of your users are good citizens, they sign up with a valid email and immediately activate the account. Let's populate the table with user data, where roughly 90% of the users are activated: db=# INSERT INTO users (username, activated) db-# SELECT db-# md5(random()::text) AS username, db-# random() < 0.9 AS activated
57-1	13197-13201	Most	
57-2	13202-13204	of	
57-3	13205-13209	your	
57-4	13210-13215	users	
57-5	13216-13219	are	
57-6	13220-13224	good	
57-7	13225-13233	citizens	
57-8	13233-13234	,	
57-9	13235-13239	they	
57-10	13240-13244	sign	
57-11	13245-13247	up	
57-12	13248-13252	with	
57-13	13253-13254	a	
57-14	13255-13260	valid	
57-15	13261-13266	email	
57-16	13267-13270	and	
57-17	13271-13282	immediately	
57-18	13283-13291	activate	
57-19	13292-13295	the	
57-20	13296-13303	account	
57-21	13303-13304	.	
57-22	13305-13310	Let's	
57-23	13311-13319	populate	
57-24	13320-13323	the	
57-25	13324-13329	table	
57-26	13330-13334	with	
57-27	13335-13339	user	
57-28	13340-13344	data	
57-29	13344-13345	,	
57-30	13346-13351	where	
57-31	13352-13359	roughly	
57-32	13360-13363	90%	
57-33	13364-13366	of	
57-34	13367-13370	the	
57-35	13371-13376	users	
57-36	13377-13380	are	
57-37	13381-13390	activated	
57-38	13390-13391	:	
57-39	13392-13394	db	
57-40	13394-13395	=	
57-41	13395-13396	#	
57-42	13397-13403	INSERT	
57-43	13404-13408	INTO	
57-44	13409-13414	users	
57-45	13415-13416	(	
57-46	13416-13424	username	
57-47	13424-13425	,	
57-48	13426-13435	activated	
57-49	13435-13436	)	
57-50	13437-13439	db	
57-51	13439-13440	-	
57-52	13440-13441	#	
57-53	13442-13448	SELECT	
57-54	13449-13451	db	
57-55	13451-13452	-	
57-56	13452-13453	#	
57-57	13454-13457	md5	
57-58	13457-13458	(	
57-59	13458-13464	random	
57-60	13464-13465	(	
57-61	13465-13466	)	
57-62	13466-13467	:	
57-63	13467-13468	:	
57-64	13468-13472	text	
57-65	13472-13473	)	
57-66	13474-13476	AS	
57-67	13477-13485	username	
57-68	13485-13486	,	
57-69	13487-13489	db	
57-70	13489-13490	-	
57-71	13490-13491	#	
57-72	13492-13498	random	
57-73	13498-13499	(	
57-74	13499-13500	)	
57-75	13501-13502	<	
57-76	13503-13506	0.9	
57-77	13507-13509	AS	
57-78	13510-13519	activated	

#Text=db-# FROM db-# generate_series(1, 1000000); INSERT 0 1000000 db=# SELECT activated, count(*) FROM users GROUP BY activated; activated | count
58-1	13520-13522	db	
58-2	13522-13523	-	
58-3	13523-13524	#	
58-4	13525-13529	FROM	
58-5	13530-13532	db	
58-6	13532-13533	-	
58-7	13533-13534	#	
58-8	13535-13550	generate_series	
58-9	13550-13551	(	
58-10	13551-13552	1	
58-11	13552-13553	,	
58-12	13554-13561	1000000	
58-13	13561-13562	)	
58-14	13562-13563	;	
58-15	13564-13570	INSERT	
58-16	13571-13572	0	
58-17	13573-13580	1000000	
58-18	13581-13583	db	
58-19	13583-13584	=	
58-20	13584-13585	#	
58-21	13586-13592	SELECT	
58-22	13593-13602	activated	
58-23	13602-13603	,	
58-24	13604-13609	count	
58-25	13609-13610	(	
58-26	13610-13611	*	
58-27	13611-13612	)	
58-28	13613-13617	FROM	
58-29	13618-13623	users	
58-30	13624-13629	GROUP	
58-31	13630-13632	BY	
58-32	13633-13642	activated	
58-33	13642-13643	;	
58-34	13644-13653	activated	
58-35	13654-13655	|	
58-36	13656-13661	count	

#Text=-----------+-------- | 102567 | 897433 db=# VACUUM ANALYZE users; VACUUM To query for activated and unactivated users, you might be tempted to create an index on the column activated:
59-1	13662-13663	-	
59-2	13663-13664	-	
59-3	13664-13665	-	
59-4	13665-13666	-	
59-5	13666-13667	-	
59-6	13667-13668	-	
59-7	13668-13669	-	
59-8	13669-13670	-	
59-9	13670-13671	-	
59-10	13671-13672	-	
59-11	13672-13673	-	
59-12	13673-13674	+	
59-13	13674-13675	-	
59-14	13675-13676	-	
59-15	13676-13677	-	
59-16	13677-13678	-	
59-17	13678-13679	-	
59-18	13679-13680	-	
59-19	13680-13681	-	
59-20	13681-13682	-	
59-21	13683-13684	|	
59-22	13685-13691	102567	
59-23	13692-13693	|	
59-24	13694-13700	897433	
59-25	13701-13703	db	
59-26	13703-13704	=	
59-27	13704-13705	#	
59-28	13706-13712	VACUUM	
59-29	13713-13720	ANALYZE	
59-30	13721-13726	users	
59-31	13726-13727	;	
59-32	13728-13734	VACUUM	
59-33	13735-13737	To	
59-34	13738-13743	query	
59-35	13744-13747	for	
59-36	13748-13757	activated	
59-37	13758-13761	and	
59-38	13762-13773	unactivated	
59-39	13774-13779	users	
59-40	13779-13780	,	
59-41	13781-13784	you	
59-42	13785-13790	might	
59-43	13791-13793	be	
59-44	13794-13801	tempted	
59-45	13802-13804	to	
59-46	13805-13811	create	
59-47	13812-13814	an	
59-48	13815-13820	index	
59-49	13821-13823	on	
59-50	13824-13827	the	
59-51	13828-13834	column	
59-52	13835-13844	activated	
59-53	13844-13845	:	

#Text=db=# CREATE INDEX users_activated_ix ON users(activated); CREATE INDEX When you try to query unactivated users, the database is using the index: db=# EXPLAIN SELECT * FROM users WHERE NOT activated; QUERY PLAN
60-1	13846-13848	db	
60-2	13848-13849	=	
60-3	13849-13850	#	
60-4	13851-13857	CREATE	
60-5	13858-13863	INDEX	
60-6	13864-13882	users_activated_ix	
60-7	13883-13885	ON	
60-8	13886-13891	users	
60-9	13891-13892	(	
60-10	13892-13901	activated	
60-11	13901-13902	)	
60-12	13902-13903	;	
60-13	13904-13910	CREATE	
60-14	13911-13916	INDEX	
60-15	13917-13921	When	
60-16	13922-13925	you	
60-17	13926-13929	try	
60-18	13930-13932	to	
60-19	13933-13938	query	
60-20	13939-13950	unactivated	
60-21	13951-13956	users	
60-22	13956-13957	,	
60-23	13958-13961	the	
60-24	13962-13970	database	
60-25	13971-13973	is	
60-26	13974-13979	using	
60-27	13980-13983	the	
60-28	13984-13989	index	
60-29	13989-13990	:	
60-30	13991-13993	db	
60-31	13993-13994	=	
60-32	13994-13995	#	
60-33	13996-14003	EXPLAIN	
60-34	14004-14010	SELECT	
60-35	14011-14012	*	
60-36	14013-14017	FROM	
60-37	14018-14023	users	
60-38	14024-14029	WHERE	
60-39	14030-14033	NOT	
60-40	14034-14043	activated	
60-41	14043-14044	;	
60-42	14045-14050	QUERY	
60-43	14051-14055	PLAN	

#Text=-------------------------------------------------------------------------------------- Bitmap Heap Scan on users (cost=1923.32..11282.99 rows=102567 width=38) Filter: (NOT activated) Bitmap Index Scan on users_activated_ix
61-1	14056-14057	-	
61-2	14057-14058	-	
61-3	14058-14059	-	
61-4	14059-14060	-	
61-5	14060-14061	-	
61-6	14061-14062	-	
61-7	14062-14063	-	
61-8	14063-14064	-	
61-9	14064-14065	-	
61-10	14065-14066	-	
61-11	14066-14067	-	
61-12	14067-14068	-	
61-13	14068-14069	-	
61-14	14069-14070	-	
61-15	14070-14071	-	
61-16	14071-14072	-	
61-17	14072-14073	-	
61-18	14073-14074	-	
61-19	14074-14075	-	
61-20	14075-14076	-	
61-21	14076-14077	-	
61-22	14077-14078	-	
61-23	14078-14079	-	
61-24	14079-14080	-	
61-25	14080-14081	-	
61-26	14081-14082	-	
61-27	14082-14083	-	
61-28	14083-14084	-	
61-29	14084-14085	-	
61-30	14085-14086	-	
61-31	14086-14087	-	
61-32	14087-14088	-	
61-33	14088-14089	-	
61-34	14089-14090	-	
61-35	14090-14091	-	
61-36	14091-14092	-	
61-37	14092-14093	-	
61-38	14093-14094	-	
61-39	14094-14095	-	
61-40	14095-14096	-	
61-41	14096-14097	-	
61-42	14097-14098	-	
61-43	14098-14099	-	
61-44	14099-14100	-	
61-45	14100-14101	-	
61-46	14101-14102	-	
61-47	14102-14103	-	
61-48	14103-14104	-	
61-49	14104-14105	-	
61-50	14105-14106	-	
61-51	14106-14107	-	
61-52	14107-14108	-	
61-53	14108-14109	-	
61-54	14109-14110	-	
61-55	14110-14111	-	
61-56	14111-14112	-	
61-57	14112-14113	-	
61-58	14113-14114	-	
61-59	14114-14115	-	
61-60	14115-14116	-	
61-61	14116-14117	-	
61-62	14117-14118	-	
61-63	14118-14119	-	
61-64	14119-14120	-	
61-65	14120-14121	-	
61-66	14121-14122	-	
61-67	14122-14123	-	
61-68	14123-14124	-	
61-69	14124-14125	-	
61-70	14125-14126	-	
61-71	14126-14127	-	
61-72	14127-14128	-	
61-73	14128-14129	-	
61-74	14129-14130	-	
61-75	14130-14131	-	
61-76	14131-14132	-	
61-77	14132-14133	-	
61-78	14133-14134	-	
61-79	14134-14135	-	
61-80	14135-14136	-	
61-81	14136-14137	-	
61-82	14137-14138	-	
61-83	14138-14139	-	
61-84	14139-14140	-	
61-85	14140-14141	-	
61-86	14141-14142	-	
61-87	14143-14149	Bitmap	
61-88	14150-14154	Heap	
61-89	14155-14159	Scan	
61-90	14160-14162	on	
61-91	14163-14168	users	
61-92	14169-14170	(	
61-93	14170-14174	cost	
61-94	14174-14175	=	
61-95	14175-14182	1923.32	
61-96	14182-14183	.	
61-97	14183-14192	.11282.99	
61-98	14193-14197	rows	
61-99	14197-14198	=	
61-100	14198-14204	102567	
61-101	14205-14210	width	
61-102	14210-14211	=	
61-103	14211-14213	38	
61-104	14213-14214	)	
61-105	14215-14221	Filter	
61-106	14221-14222	:	
61-107	14223-14224	(	
61-108	14224-14227	NOT	
61-109	14228-14237	activated	
61-110	14237-14238	)	
61-111	14239-14245	Bitmap	
61-112	14246-14251	Index	
61-113	14252-14256	Scan	
61-114	14257-14259	on	
61-115	14260-14278	users_activated_ix	

#Text=(cost=0.00..1897.68 rows=102567 width=0) Index Cond: (activated = false) The database estimated that the filter will result in 102,567 which are roughly 10% of the table. This is consistent with the data we populated, so the database has a good sense of the data.
62-1	14279-14280	(	
62-2	14280-14284	cost	
62-3	14284-14285	=	
62-4	14285-14289	0.00	
62-5	14289-14290	.	
62-6	14290-14298	.1897.68	
62-7	14299-14303	rows	
62-8	14303-14304	=	
62-9	14304-14310	102567	
62-10	14311-14316	width	
62-11	14316-14317	=	
62-12	14317-14318	0	
62-13	14318-14319	)	
62-14	14320-14325	Index	
62-15	14326-14330	Cond	
62-16	14330-14331	:	
62-17	14332-14333	(	
62-18	14333-14342	activated	
62-19	14343-14344	=	
62-20	14345-14350	false	
62-21	14350-14351	)	
62-22	14352-14355	The	
62-23	14356-14364	database	
62-24	14365-14374	estimated	
62-25	14375-14379	that	
62-26	14380-14383	the	
62-27	14384-14390	filter	
62-28	14391-14395	will	
62-29	14396-14402	result	
62-30	14403-14405	in	
62-31	14406-14413	102,567	
62-32	14414-14419	which	
62-33	14420-14423	are	
62-34	14424-14431	roughly	
62-35	14432-14435	10%	
62-36	14436-14438	of	
62-37	14439-14442	the	
62-38	14443-14448	table	
62-39	14448-14449	.	
62-40	14450-14454	This	
62-41	14455-14457	is	
62-42	14458-14468	consistent	
62-43	14469-14473	with	
62-44	14474-14477	the	
62-45	14478-14482	data	
62-46	14483-14485	we	
62-47	14486-14495	populated	
62-48	14495-14496	,	
62-49	14497-14499	so	
62-50	14500-14503	the	
62-51	14504-14512	database	
62-52	14513-14516	has	
62-53	14517-14518	a	
62-54	14519-14523	good	
62-55	14524-14529	sense	
62-56	14530-14532	of	
62-57	14533-14536	the	
62-58	14537-14541	data	
62-59	14541-14542	.	

#Text=However, when you try to query for activated users you find that the database decided not to use the index: db=# EXPLAIN SELECT * FROM users WHERE activated; QUERY PLAN
63-1	14543-14550	However	
63-2	14550-14551	,	
63-3	14552-14556	when	
63-4	14557-14560	you	
63-5	14561-14564	try	
63-6	14565-14567	to	
63-7	14568-14573	query	
63-8	14574-14577	for	
63-9	14578-14587	activated	
63-10	14588-14593	users	
63-11	14594-14597	you	
63-12	14598-14602	find	
63-13	14603-14607	that	
63-14	14608-14611	the	
63-15	14612-14620	database	
63-16	14621-14628	decided	
63-17	14629-14632	not	
63-18	14633-14635	to	
63-19	14636-14639	use	
63-20	14640-14643	the	
63-21	14644-14649	index	
63-22	14649-14650	:	
63-23	14651-14653	db	
63-24	14653-14654	=	
63-25	14654-14655	#	
63-26	14656-14663	EXPLAIN	
63-27	14664-14670	SELECT	
63-28	14671-14672	*	
63-29	14673-14677	FROM	
63-30	14678-14683	users	
63-31	14684-14689	WHERE	
63-32	14690-14699	activated	
63-33	14699-14700	;	
63-34	14701-14706	QUERY	
63-35	14707-14711	PLAN	

#Text=--------------------------------------------------------------- Seq Scan on users (cost=0.00..18334.00 rows=897433 width=38) Filter: activated Many developers are often baffled when they the database is not using an index. One way of explaining why an index is not always the best choice is this: if you had to read the entire table, would you use the index?
64-1	14712-14713	-	
64-2	14713-14714	-	
64-3	14714-14715	-	
64-4	14715-14716	-	
64-5	14716-14717	-	
64-6	14717-14718	-	
64-7	14718-14719	-	
64-8	14719-14720	-	
64-9	14720-14721	-	
64-10	14721-14722	-	
64-11	14722-14723	-	
64-12	14723-14724	-	
64-13	14724-14725	-	
64-14	14725-14726	-	
64-15	14726-14727	-	
64-16	14727-14728	-	
64-17	14728-14729	-	
64-18	14729-14730	-	
64-19	14730-14731	-	
64-20	14731-14732	-	
64-21	14732-14733	-	
64-22	14733-14734	-	
64-23	14734-14735	-	
64-24	14735-14736	-	
64-25	14736-14737	-	
64-26	14737-14738	-	
64-27	14738-14739	-	
64-28	14739-14740	-	
64-29	14740-14741	-	
64-30	14741-14742	-	
64-31	14742-14743	-	
64-32	14743-14744	-	
64-33	14744-14745	-	
64-34	14745-14746	-	
64-35	14746-14747	-	
64-36	14747-14748	-	
64-37	14748-14749	-	
64-38	14749-14750	-	
64-39	14750-14751	-	
64-40	14751-14752	-	
64-41	14752-14753	-	
64-42	14753-14754	-	
64-43	14754-14755	-	
64-44	14755-14756	-	
64-45	14756-14757	-	
64-46	14757-14758	-	
64-47	14758-14759	-	
64-48	14759-14760	-	
64-49	14760-14761	-	
64-50	14761-14762	-	
64-51	14762-14763	-	
64-52	14763-14764	-	
64-53	14764-14765	-	
64-54	14765-14766	-	
64-55	14766-14767	-	
64-56	14767-14768	-	
64-57	14768-14769	-	
64-58	14769-14770	-	
64-59	14770-14771	-	
64-60	14771-14772	-	
64-61	14772-14773	-	
64-62	14773-14774	-	
64-63	14774-14775	-	
64-64	14776-14779	Seq	
64-65	14780-14784	Scan	
64-66	14785-14787	on	
64-67	14788-14793	users	
64-68	14794-14795	(	
64-69	14795-14799	cost	
64-70	14799-14800	=	
64-71	14800-14804	0.00	
64-72	14804-14805	.	
64-73	14805-14814	.18334.00	
64-74	14815-14819	rows	
64-75	14819-14820	=	
64-76	14820-14826	897433	
64-77	14827-14832	width	
64-78	14832-14833	=	
64-79	14833-14835	38	
64-80	14835-14836	)	
64-81	14837-14843	Filter	
64-82	14843-14844	:	
64-83	14845-14854	activated	
64-84	14855-14859	Many	
64-85	14860-14870	developers	
64-86	14871-14874	are	
64-87	14875-14880	often	
64-88	14881-14888	baffled	
64-89	14889-14893	when	
64-90	14894-14898	they	
64-91	14899-14902	the	
64-92	14903-14911	database	
64-93	14912-14914	is	
64-94	14915-14918	not	
64-95	14919-14924	using	
64-96	14925-14927	an	
64-97	14928-14933	index	
64-98	14933-14934	.	
64-99	14935-14938	One	
64-100	14939-14942	way	
64-101	14943-14945	of	
64-102	14946-14956	explaining	
64-103	14957-14960	why	
64-104	14961-14963	an	
64-105	14964-14969	index	
64-106	14970-14972	is	
64-107	14973-14976	not	
64-108	14977-14983	always	
64-109	14984-14987	the	
64-110	14988-14992	best	
64-111	14993-14999	choice	
64-112	15000-15002	is	
64-113	15003-15007	this	
64-114	15007-15008	:	
64-115	15009-15011	if	
64-116	15012-15015	you	
64-117	15016-15019	had	
64-118	15020-15022	to	
64-119	15023-15027	read	
64-120	15028-15031	the	
64-121	15032-15038	entire	
64-122	15039-15044	table	
64-123	15044-15045	,	
64-124	15046-15051	would	
64-125	15052-15055	you	
64-126	15056-15059	use	
64-127	15060-15063	the	
64-128	15064-15069	index	
64-129	15069-15070	?	

#Text=The answer is probably no, because why would you? Reading from disk is expensive and you want to read as little as possible. If for example, a table is 10MB and the index is 1MB, to read the entire table you would have to read 10MB from disk. To read the table using the index you would have to read 11MB from disk. This is wasteful. With this understanding, let's have a look at the statistics PostgreSQL gather on the table: db=# SELECT attname, n_distinct, most_common_vals, most_common_freqs
65-1	15071-15074	The	
65-2	15075-15081	answer	
65-3	15082-15084	is	
65-4	15085-15093	probably	
65-5	15094-15096	no	
65-6	15096-15097	,	
65-7	15098-15105	because	
65-8	15106-15109	why	
65-9	15110-15115	would	
65-10	15116-15119	you	
65-11	15119-15120	?	
65-12	15121-15128	Reading	
65-13	15129-15133	from	
65-14	15134-15138	disk	
65-15	15139-15141	is	
65-16	15142-15151	expensive	
65-17	15152-15155	and	
65-18	15156-15159	you	
65-19	15160-15164	want	
65-20	15165-15167	to	
65-21	15168-15172	read	
65-22	15173-15175	as	
65-23	15176-15182	little	
65-24	15183-15185	as	
65-25	15186-15194	possible	
65-26	15194-15195	.	
65-27	15196-15198	If	
65-28	15199-15202	for	
65-29	15203-15210	example	
65-30	15210-15211	,	
65-31	15212-15213	a	
65-32	15214-15219	table	
65-33	15220-15222	is	
65-34	15223-15227	10MB	
65-35	15228-15231	and	
65-36	15232-15235	the	
65-37	15236-15241	index	
65-38	15242-15244	is	
65-39	15245-15248	1MB	
65-40	15248-15249	,	
65-41	15250-15252	to	
65-42	15253-15257	read	
65-43	15258-15261	the	
65-44	15262-15268	entire	
65-45	15269-15274	table	
65-46	15275-15278	you	
65-47	15279-15284	would	
65-48	15285-15289	have	
65-49	15290-15292	to	
65-50	15293-15297	read	
65-51	15298-15302	10MB	
65-52	15303-15307	from	
65-53	15308-15312	disk	
65-54	15312-15313	.	
65-55	15314-15316	To	
65-56	15317-15321	read	
65-57	15322-15325	the	
65-58	15326-15331	table	
65-59	15332-15337	using	
65-60	15338-15341	the	
65-61	15342-15347	index	
65-62	15348-15351	you	
65-63	15352-15357	would	
65-64	15358-15362	have	
65-65	15363-15365	to	
65-66	15366-15370	read	
65-67	15371-15375	11MB	
65-68	15376-15380	from	
65-69	15381-15385	disk	
65-70	15385-15386	.	
65-71	15387-15391	This	
65-72	15392-15394	is	
65-73	15395-15403	wasteful	
65-74	15403-15404	.	
65-75	15405-15409	With	
65-76	15410-15414	this	
65-77	15415-15428	understanding	
65-78	15428-15429	,	
65-79	15430-15435	let's	
65-80	15436-15440	have	
65-81	15441-15442	a	
65-82	15443-15447	look	
65-83	15448-15450	at	
65-84	15451-15454	the	
65-85	15455-15465	statistics	
65-86	15466-15476	PostgreSQL	
65-87	15477-15483	gather	
65-88	15484-15486	on	
65-89	15487-15490	the	
65-90	15491-15496	table	
65-91	15496-15497	:	
65-92	15498-15500	db	
65-93	15500-15501	=	
65-94	15501-15502	#	
65-95	15503-15509	SELECT	
65-96	15510-15517	attname	
65-97	15517-15518	,	
65-98	15519-15529	n_distinct	
65-99	15529-15530	,	
65-100	15531-15547	most_common_vals	
65-101	15547-15548	,	
65-102	15549-15566	most_common_freqs	

#Text=db-# FROM pg_stats db-# WHERE tablename = 'users' AND attname='activated'; ------------------+------------------------
66-1	15567-15569	db	
66-2	15569-15570	-	
66-3	15570-15571	#	
66-4	15572-15576	FROM	
66-5	15577-15585	pg_stats	
66-6	15586-15588	db	
66-7	15588-15589	-	
66-8	15589-15590	#	
66-9	15591-15596	WHERE	
66-10	15597-15606	tablename	
66-11	15607-15608	=	
66-12	15609-15610	'	
66-13	15610-15615	users	
66-14	15615-15616	'	
66-15	15617-15620	AND	
66-16	15621-15628	attname	
66-17	15628-15629	=	
66-18	15629-15630	'	
66-19	15630-15639	activated	
66-20	15639-15640	'	
66-21	15640-15641	;	
66-22	15642-15643	-	
66-23	15643-15644	-	
66-24	15644-15645	-	
66-25	15645-15646	-	
66-26	15646-15647	-	
66-27	15647-15648	-	
66-28	15648-15649	-	
66-29	15649-15650	-	
66-30	15650-15651	-	
66-31	15651-15652	-	
66-32	15652-15653	-	
66-33	15653-15654	-	
66-34	15654-15655	-	
66-35	15655-15656	-	
66-36	15656-15657	-	
66-37	15657-15658	-	
66-38	15658-15659	-	
66-39	15659-15660	-	
66-40	15660-15661	+	
66-41	15661-15662	-	
66-42	15662-15663	-	
66-43	15663-15664	-	
66-44	15664-15665	-	
66-45	15665-15666	-	
66-46	15666-15667	-	
66-47	15667-15668	-	
66-48	15668-15669	-	
66-49	15669-15670	-	
66-50	15670-15671	-	
66-51	15671-15672	-	
66-52	15672-15673	-	
66-53	15673-15674	-	
66-54	15674-15675	-	
66-55	15675-15676	-	
66-56	15676-15677	-	
66-57	15677-15678	-	
66-58	15678-15679	-	
66-59	15679-15680	-	
66-60	15680-15681	-	
66-61	15681-15682	-	
66-62	15682-15683	-	
66-63	15683-15684	-	
66-64	15684-15685	-	

#Text=attname | activated n_distinct | 2 most_common_vals | {t,f} most_common_freqs | {0.89743334,0.10256667}
67-1	15686-15693	attname	
67-2	15694-15695	|	
67-3	15696-15705	activated	
67-4	15706-15716	n_distinct	
67-5	15717-15718	|	
67-6	15719-15720	2	
67-7	15721-15737	most_common_vals	
67-8	15738-15739	|	
67-9	15740-15741	{	
67-10	15741-15742	t	
67-11	15742-15743	,	
67-12	15743-15744	f	
67-13	15744-15745	}	
67-14	15746-15763	most_common_freqs	
67-15	15764-15765	|	
67-16	15766-15767	{	
67-17	15767-15788	0.89743334,0.10256667	
67-18	15788-15789	}	

#Text=When PostgreSQL analyzed the table it found that the column activated has two distinct values. The value t in the most_common_vals column corresponds to the frequency 0.89743334 in the column most_common_freqs, and the value f corresponds to the frequency 0.10256667. This means that after analyzing the table, the database estimates that 89.74% of the table are activated users, and the rest 10.26% are unactivated users. With these stats, PostgreSQL decided it's best to scan the entire table if it expects 90% of the rows to satisfy the condition. The threshold after which the database may decide to use or not to use the index depends on many factors, and there is no rule of thumb you can use.
68-1	15790-15794	When	
68-2	15795-15805	PostgreSQL	
68-3	15806-15814	analyzed	
68-4	15815-15818	the	
68-5	15819-15824	table	
68-6	15825-15827	it	
68-7	15828-15833	found	
68-8	15834-15838	that	
68-9	15839-15842	the	
68-10	15843-15849	column	
68-11	15850-15859	activated	
68-12	15860-15863	has	
68-13	15864-15867	two	
68-14	15868-15876	distinct	
68-15	15877-15883	values	
68-16	15883-15884	.	
68-17	15885-15888	The	
68-18	15889-15894	value	
68-19	15895-15896	t	
68-20	15897-15899	in	
68-21	15900-15903	the	
68-22	15904-15920	most_common_vals	
68-23	15921-15927	column	
68-24	15928-15939	corresponds	
68-25	15940-15942	to	
68-26	15943-15946	the	
68-27	15947-15956	frequency	
68-28	15957-15967	0.89743334	
68-29	15968-15970	in	
68-30	15971-15974	the	
68-31	15975-15981	column	
68-32	15982-15999	most_common_freqs	
68-33	15999-16000	,	
68-34	16001-16004	and	
68-35	16005-16008	the	
68-36	16009-16014	value	
68-37	16015-16016	f	
68-38	16017-16028	corresponds	
68-39	16029-16031	to	
68-40	16032-16035	the	
68-41	16036-16045	frequency	
68-42	16046-16056	0.10256667	
68-43	16056-16057	.	
68-44	16058-16062	This	
68-45	16063-16068	means	
68-46	16069-16073	that	
68-47	16074-16079	after	
68-48	16080-16089	analyzing	
68-49	16090-16093	the	
68-50	16094-16099	table	
68-51	16099-16100	,	
68-52	16101-16104	the	
68-53	16105-16113	database	
68-54	16114-16123	estimates	
68-55	16124-16128	that	
68-56	16129-16135	89.74%	
68-57	16136-16138	of	
68-58	16139-16142	the	
68-59	16143-16148	table	
68-60	16149-16152	are	
68-61	16153-16162	activated	
68-62	16163-16168	users	
68-63	16168-16169	,	
68-64	16170-16173	and	
68-65	16174-16177	the	
68-66	16178-16182	rest	
68-67	16183-16189	10.26%	
68-68	16190-16193	are	
68-69	16194-16205	unactivated	
68-70	16206-16211	users	
68-71	16211-16212	.	
68-72	16213-16217	With	
68-73	16218-16223	these	
68-74	16224-16229	stats	
68-75	16229-16230	,	
68-76	16231-16241	PostgreSQL	
68-77	16242-16249	decided	
68-78	16250-16254	it's	
68-79	16255-16259	best	
68-80	16260-16262	to	
68-81	16263-16267	scan	
68-82	16268-16271	the	
68-83	16272-16278	entire	
68-84	16279-16284	table	
68-85	16285-16287	if	
68-86	16288-16290	it	
68-87	16291-16298	expects	
68-88	16299-16302	90%	
68-89	16303-16305	of	
68-90	16306-16309	the	
68-91	16310-16314	rows	
68-92	16315-16317	to	
68-93	16318-16325	satisfy	
68-94	16326-16329	the	
68-95	16330-16339	condition	
68-96	16339-16340	.	
68-97	16341-16344	The	
68-98	16345-16354	threshold	
68-99	16355-16360	after	
68-100	16361-16366	which	
68-101	16367-16370	the	
68-102	16371-16379	database	
68-103	16380-16383	may	
68-104	16384-16390	decide	
68-105	16391-16393	to	
68-106	16394-16397	use	
68-107	16398-16400	or	
68-108	16401-16404	not	
68-109	16405-16407	to	
68-110	16408-16411	use	
68-111	16412-16415	the	
68-112	16416-16421	index	
68-113	16422-16429	depends	
68-114	16430-16432	on	
68-115	16433-16437	many	
68-116	16438-16445	factors	
68-117	16445-16446	,	
68-118	16447-16450	and	
68-119	16451-16456	there	
68-120	16457-16459	is	
68-121	16460-16462	no	
68-122	16463-16467	rule	
68-123	16468-16470	of	
68-124	16471-16476	thumb	
68-125	16477-16480	you	
68-126	16481-16484	can	
68-127	16485-16488	use	
68-128	16488-16489	.	

#Text=Index for a column with low selectivity vs. high selectivity Use Partial Indexes In the previous section we created an index on a boolean column where ~90% of the of the values were true (activated user). When we tried to query for active users, the database did not use the index. However, when we queried unactivated users the database did use the index.
69-1	16490-16495	Index	
69-2	16496-16499	for	
69-3	16500-16501	a	
69-4	16502-16508	column	
69-5	16509-16513	with	
69-6	16514-16517	low	
69-7	16518-16529	selectivity	
69-8	16530-16532	vs	
69-9	16532-16533	.	
69-10	16534-16538	high	
69-11	16539-16550	selectivity	
69-12	16551-16554	Use	
69-13	16555-16562	Partial	
69-14	16563-16570	Indexes	
69-15	16571-16573	In	
69-16	16574-16577	the	
69-17	16578-16586	previous	
69-18	16587-16594	section	
69-19	16595-16597	we	
69-20	16598-16605	created	
69-21	16606-16608	an	
69-22	16609-16614	index	
69-23	16615-16617	on	
69-24	16618-16619	a	
69-25	16620-16627	boolean	
69-26	16628-16634	column	
69-27	16635-16640	where	
69-28	16641-16642	~	
69-29	16642-16645	90%	
69-30	16646-16648	of	
69-31	16649-16652	the	
69-32	16653-16655	of	
69-33	16656-16659	the	
69-34	16660-16666	values	
69-35	16667-16671	were	
69-36	16672-16676	true	
69-37	16677-16678	(	
69-38	16678-16687	activated	
69-39	16688-16692	user	
69-40	16692-16693	)	
69-41	16693-16694	.	
69-42	16695-16699	When	
69-43	16700-16702	we	
69-44	16703-16708	tried	
69-45	16709-16711	to	
69-46	16712-16717	query	
69-47	16718-16721	for	
69-48	16722-16728	active	
69-49	16729-16734	users	
69-50	16734-16735	,	
69-51	16736-16739	the	
69-52	16740-16748	database	
69-53	16749-16752	did	
69-54	16753-16756	not	
69-55	16757-16760	use	
69-56	16761-16764	the	
69-57	16765-16770	index	
69-58	16770-16771	.	
69-59	16772-16779	However	
69-60	16779-16780	,	
69-61	16781-16785	when	
69-62	16786-16788	we	
69-63	16789-16796	queried	
69-64	16797-16808	unactivated	
69-65	16809-16814	users	
69-66	16815-16818	the	
69-67	16819-16827	database	
69-68	16828-16831	did	
69-69	16832-16835	use	
69-70	16836-16839	the	
69-71	16840-16845	index	
69-72	16845-16846	.	

#Text=This brings us to the next question.... if the database is not going to use the index to filter active users, why should we index them in the first place? Before we answer this question let's look at how much the full index on the activated column weighs: db=# \\di+ users_activated_ix Schema | Name | Type | Owner | Table | Size
70-1	16847-16851	This	
70-2	16852-16858	brings	
70-3	16859-16861	us	
70-4	16862-16864	to	
70-5	16865-16868	the	
70-6	16869-16873	next	
70-7	16874-16882	question	
70-8	16882-16883	.	
70-9	16883-16884	.	
70-10	16884-16885	.	
70-11	16885-16886	.	
70-12	16887-16889	if	
70-13	16890-16893	the	
70-14	16894-16902	database	
70-15	16903-16905	is	
70-16	16906-16909	not	
70-17	16910-16915	going	
70-18	16916-16918	to	
70-19	16919-16922	use	
70-20	16923-16926	the	
70-21	16927-16932	index	
70-22	16933-16935	to	
70-23	16936-16942	filter	
70-24	16943-16949	active	
70-25	16950-16955	users	
70-26	16955-16956	,	
70-27	16957-16960	why	
70-28	16961-16967	should	
70-29	16968-16970	we	
70-30	16971-16976	index	
70-31	16977-16981	them	
70-32	16982-16984	in	
70-33	16985-16988	the	
70-34	16989-16994	first	
70-35	16995-17000	place	
70-36	17000-17001	?	
70-37	17002-17008	Before	
70-38	17009-17011	we	
70-39	17012-17018	answer	
70-40	17019-17023	this	
70-41	17024-17032	question	
70-42	17033-17038	let's	
70-43	17039-17043	look	
70-44	17044-17046	at	
70-45	17047-17050	how	
70-46	17051-17055	much	
70-47	17056-17059	the	
70-48	17060-17064	full	
70-49	17065-17070	index	
70-50	17071-17073	on	
70-51	17074-17077	the	
70-52	17078-17087	activated	
70-53	17088-17094	column	
70-54	17095-17101	weighs	
70-55	17101-17102	:	
70-56	17103-17105	db	
70-57	17105-17106	=	
70-58	17106-17107	#	
70-59	17108-17109	\	
70-60	17109-17111	di	
70-61	17111-17112	+	
70-62	17113-17131	users_activated_ix	
70-63	17132-17138	Schema	
70-64	17139-17140	|	
70-65	17141-17145	Name	
70-66	17146-17147	|	
70-67	17148-17152	Type	
70-68	17153-17154	|	
70-69	17155-17160	Owner	
70-70	17161-17162	|	
70-71	17163-17168	Table	
70-72	17169-17170	|	
70-73	17171-17175	Size	

#Text=--------+--------------------+-------+-------+-------+------ public | users_activated_ix | index | haki | users | 21 MB The index is 21MB. Just for reference, the users table is 65MB. This means the index weighs ~32% the size of the table. We also know that ~90% of the index is likely not going to be used.
71-1	17176-17177	-	
71-2	17177-17178	-	
71-3	17178-17179	-	
71-4	17179-17180	-	
71-5	17180-17181	-	
71-6	17181-17182	-	
71-7	17182-17183	-	
71-8	17183-17184	-	
71-9	17184-17185	+	
71-10	17185-17186	-	
71-11	17186-17187	-	
71-12	17187-17188	-	
71-13	17188-17189	-	
71-14	17189-17190	-	
71-15	17190-17191	-	
71-16	17191-17192	-	
71-17	17192-17193	-	
71-18	17193-17194	-	
71-19	17194-17195	-	
71-20	17195-17196	-	
71-21	17196-17197	-	
71-22	17197-17198	-	
71-23	17198-17199	-	
71-24	17199-17200	-	
71-25	17200-17201	-	
71-26	17201-17202	-	
71-27	17202-17203	-	
71-28	17203-17204	-	
71-29	17204-17205	-	
71-30	17205-17206	+	
71-31	17206-17207	-	
71-32	17207-17208	-	
71-33	17208-17209	-	
71-34	17209-17210	-	
71-35	17210-17211	-	
71-36	17211-17212	-	
71-37	17212-17213	-	
71-38	17213-17214	+	
71-39	17214-17215	-	
71-40	17215-17216	-	
71-41	17216-17217	-	
71-42	17217-17218	-	
71-43	17218-17219	-	
71-44	17219-17220	-	
71-45	17220-17221	-	
71-46	17221-17222	+	
71-47	17222-17223	-	
71-48	17223-17224	-	
71-49	17224-17225	-	
71-50	17225-17226	-	
71-51	17226-17227	-	
71-52	17227-17228	-	
71-53	17228-17229	-	
71-54	17229-17230	+	
71-55	17230-17231	-	
71-56	17231-17232	-	
71-57	17232-17233	-	
71-58	17233-17234	-	
71-59	17234-17235	-	
71-60	17235-17236	-	
71-61	17237-17243	public	
71-62	17244-17245	|	
71-63	17246-17264	users_activated_ix	
71-64	17265-17266	|	
71-65	17267-17272	index	
71-66	17273-17274	|	
71-67	17275-17279	haki	
71-68	17280-17281	|	
71-69	17282-17287	users	
71-70	17288-17289	|	
71-71	17290-17292	21	
71-72	17293-17295	MB	
71-73	17296-17299	The	
71-74	17300-17305	index	
71-75	17306-17308	is	
71-76	17309-17313	21MB	
71-77	17313-17314	.	
71-78	17315-17319	Just	
71-79	17320-17323	for	
71-80	17324-17333	reference	
71-81	17333-17334	,	
71-82	17335-17338	the	
71-83	17339-17344	users	
71-84	17345-17350	table	
71-85	17351-17353	is	
71-86	17354-17358	65MB	
71-87	17358-17359	.	
71-88	17360-17364	This	
71-89	17365-17370	means	
71-90	17371-17374	the	
71-91	17375-17380	index	
71-92	17381-17387	weighs	
71-93	17388-17389	~	
71-94	17389-17392	32%	
71-95	17393-17396	the	
71-96	17397-17401	size	
71-97	17402-17404	of	
71-98	17405-17408	the	
71-99	17409-17414	table	
71-100	17414-17415	.	
71-101	17416-17418	We	
71-102	17419-17423	also	
71-103	17424-17428	know	
71-104	17429-17433	that	
71-105	17434-17435	~	
71-106	17435-17438	90%	
71-107	17439-17441	of	
71-108	17442-17445	the	
71-109	17446-17451	index	
71-110	17452-17454	is	
71-111	17455-17461	likely	
71-112	17462-17465	not	
71-113	17466-17471	going	
71-114	17472-17474	to	
71-115	17475-17477	be	
71-116	17478-17482	used	
71-117	17482-17483	.	

#Text=In PostgreSQL, there is a way to create an index on only a part of the table, using whats called a partial index: db=# CREATE INDEX users_unactivated_partial_ix ON users(id) db-# WHERE not activated; CREATE INDEX Using a WHERE clause, we restrict the rows indexed by the index. Let's first make sure it works:
72-1	17484-17486	In	
72-2	17487-17497	PostgreSQL	
72-3	17497-17498	,	
72-4	17499-17504	there	
72-5	17505-17507	is	
72-6	17508-17509	a	
72-7	17510-17513	way	
72-8	17514-17516	to	
72-9	17517-17523	create	
72-10	17524-17526	an	
72-11	17527-17532	index	
72-12	17533-17535	on	
72-13	17536-17540	only	
72-14	17541-17542	a	
72-15	17543-17547	part	
72-16	17548-17550	of	
72-17	17551-17554	the	
72-18	17555-17560	table	
72-19	17560-17561	,	
72-20	17562-17567	using	
72-21	17568-17573	whats	
72-22	17574-17580	called	
72-23	17581-17582	a	
72-24	17583-17590	partial	
72-25	17591-17596	index	
72-26	17596-17597	:	
72-27	17598-17600	db	
72-28	17600-17601	=	
72-29	17601-17602	#	
72-30	17603-17609	CREATE	
72-31	17610-17615	INDEX	
72-32	17616-17644	users_unactivated_partial_ix	
72-33	17645-17647	ON	
72-34	17648-17653	users	
72-35	17653-17654	(	
72-36	17654-17656	id	
72-37	17656-17657	)	
72-38	17658-17660	db	
72-39	17660-17661	-	
72-40	17661-17662	#	
72-41	17663-17668	WHERE	
72-42	17669-17672	not	
72-43	17673-17682	activated	
72-44	17682-17683	;	
72-45	17684-17690	CREATE	
72-46	17691-17696	INDEX	
72-47	17697-17702	Using	
72-48	17703-17704	a	
72-49	17705-17710	WHERE	
72-50	17711-17717	clause	
72-51	17717-17718	,	
72-52	17719-17721	we	
72-53	17722-17730	restrict	
72-54	17731-17734	the	
72-55	17735-17739	rows	
72-56	17740-17747	indexed	
72-57	17748-17750	by	
72-58	17751-17754	the	
72-59	17755-17760	index	
72-60	17760-17761	.	
72-61	17762-17767	Let's	
72-62	17768-17773	first	
72-63	17774-17778	make	
72-64	17779-17783	sure	
72-65	17784-17786	it	
72-66	17787-17792	works	
72-67	17792-17793	:	

#Text=db=# EXPLAIN SELECT * FROM users WHERE not activated; QUERY PLAN ------------------------------------------------------------------------------------------------
73-1	17794-17796	db	
73-2	17796-17797	=	
73-3	17797-17798	#	
73-4	17799-17806	EXPLAIN	
73-5	17807-17813	SELECT	
73-6	17814-17815	*	
73-7	17816-17820	FROM	
73-8	17821-17826	users	
73-9	17827-17832	WHERE	
73-10	17833-17836	not	
73-11	17837-17846	activated	
73-12	17846-17847	;	
73-13	17848-17853	QUERY	
73-14	17854-17858	PLAN	
73-15	17859-17860	-	
73-16	17860-17861	-	
73-17	17861-17862	-	
73-18	17862-17863	-	
73-19	17863-17864	-	
73-20	17864-17865	-	
73-21	17865-17866	-	
73-22	17866-17867	-	
73-23	17867-17868	-	
73-24	17868-17869	-	
73-25	17869-17870	-	
73-26	17870-17871	-	
73-27	17871-17872	-	
73-28	17872-17873	-	
73-29	17873-17874	-	
73-30	17874-17875	-	
73-31	17875-17876	-	
73-32	17876-17877	-	
73-33	17877-17878	-	
73-34	17878-17879	-	
73-35	17879-17880	-	
73-36	17880-17881	-	
73-37	17881-17882	-	
73-38	17882-17883	-	
73-39	17883-17884	-	
73-40	17884-17885	-	
73-41	17885-17886	-	
73-42	17886-17887	-	
73-43	17887-17888	-	
73-44	17888-17889	-	
73-45	17889-17890	-	
73-46	17890-17891	-	
73-47	17891-17892	-	
73-48	17892-17893	-	
73-49	17893-17894	-	
73-50	17894-17895	-	
73-51	17895-17896	-	
73-52	17896-17897	-	
73-53	17897-17898	-	
73-54	17898-17899	-	
73-55	17899-17900	-	
73-56	17900-17901	-	
73-57	17901-17902	-	
73-58	17902-17903	-	
73-59	17903-17904	-	
73-60	17904-17905	-	
73-61	17905-17906	-	
73-62	17906-17907	-	
73-63	17907-17908	-	
73-64	17908-17909	-	
73-65	17909-17910	-	
73-66	17910-17911	-	
73-67	17911-17912	-	
73-68	17912-17913	-	
73-69	17913-17914	-	
73-70	17914-17915	-	
73-71	17915-17916	-	
73-72	17916-17917	-	
73-73	17917-17918	-	
73-74	17918-17919	-	
73-75	17919-17920	-	
73-76	17920-17921	-	
73-77	17921-17922	-	
73-78	17922-17923	-	
73-79	17923-17924	-	
73-80	17924-17925	-	
73-81	17925-17926	-	
73-82	17926-17927	-	
73-83	17927-17928	-	
73-84	17928-17929	-	
73-85	17929-17930	-	
73-86	17930-17931	-	
73-87	17931-17932	-	
73-88	17932-17933	-	
73-89	17933-17934	-	
73-90	17934-17935	-	
73-91	17935-17936	-	
73-92	17936-17937	-	
73-93	17937-17938	-	
73-94	17938-17939	-	
73-95	17939-17940	-	
73-96	17940-17941	-	
73-97	17941-17942	-	
73-98	17942-17943	-	
73-99	17943-17944	-	
73-100	17944-17945	-	
73-101	17945-17946	-	
73-102	17946-17947	-	
73-103	17947-17948	-	
73-104	17948-17949	-	
73-105	17949-17950	-	
73-106	17950-17951	-	
73-107	17951-17952	-	
73-108	17952-17953	-	
73-109	17953-17954	-	
73-110	17954-17955	-	

#Text=Index Scan using users_unactivated_partial_ix on users (cost=0.29..3493.60 rows=102567 width=38) Amazing, the database was smart enough to understand that the predicate we used in the query can be satisfied by the partial index. There is another benefit to using partial indexes:
74-1	17956-17961	Index	
74-2	17962-17966	Scan	
74-3	17967-17972	using	
74-4	17973-18001	users_unactivated_partial_ix	
74-5	18002-18004	on	
74-6	18005-18010	users	
74-7	18011-18012	(	
74-8	18012-18016	cost	
74-9	18016-18017	=	
74-10	18017-18021	0.29	
74-11	18021-18022	.	
74-12	18022-18030	.3493.60	
74-13	18031-18035	rows	
74-14	18035-18036	=	
74-15	18036-18042	102567	
74-16	18043-18048	width	
74-17	18048-18049	=	
74-18	18049-18051	38	
74-19	18051-18052	)	
74-20	18053-18060	Amazing	
74-21	18060-18061	,	
74-22	18062-18065	the	
74-23	18066-18074	database	
74-24	18075-18078	was	
74-25	18079-18084	smart	
74-26	18085-18091	enough	
74-27	18092-18094	to	
74-28	18095-18105	understand	
74-29	18106-18110	that	
74-30	18111-18114	the	
74-31	18115-18124	predicate	
74-32	18125-18127	we	
74-33	18128-18132	used	
74-34	18133-18135	in	
74-35	18136-18139	the	
74-36	18140-18145	query	
74-37	18146-18149	can	
74-38	18150-18152	be	
74-39	18153-18162	satisfied	
74-40	18163-18165	by	
74-41	18166-18169	the	
74-42	18170-18177	partial	
74-43	18178-18183	index	
74-44	18183-18184	.	
74-45	18185-18190	There	
74-46	18191-18193	is	
74-47	18194-18201	another	
74-48	18202-18209	benefit	
74-49	18210-18212	to	
74-50	18213-18218	using	
74-51	18219-18226	partial	
74-52	18227-18234	indexes	
74-53	18234-18235	:	

#Text=db=# \\di+ users_unactivated_partial_ix List of relations Schema | Name | Type | Owner | Table | Size
75-1	18236-18238	db	
75-2	18238-18239	=	
75-3	18239-18240	#	
75-4	18241-18242	\	
75-5	18242-18244	di	
75-6	18244-18245	+	
75-7	18246-18274	users_unactivated_partial_ix	
75-8	18275-18279	List	
75-9	18280-18282	of	
75-10	18283-18292	relations	
75-11	18293-18299	Schema	
75-12	18300-18301	|	
75-13	18302-18306	Name	
75-14	18307-18308	|	
75-15	18309-18313	Type	
75-16	18314-18315	|	
75-17	18316-18321	Owner	
75-18	18322-18323	|	
75-19	18324-18329	Table	
75-20	18330-18331	|	
75-21	18332-18336	Size	

#Text=--------+------------------------------+-------+-------+-------+--------- public | users_unactivated_partial_ix | index | haki | users | 2216 kB The partial index weighs only 2.2MB. The full index on the column weighed 21MB. The partial index is exactly 10% the size of the full index, which matches the ratio of inactive users in the table.
76-1	18337-18338	-	
76-2	18338-18339	-	
76-3	18339-18340	-	
76-4	18340-18341	-	
76-5	18341-18342	-	
76-6	18342-18343	-	
76-7	18343-18344	-	
76-8	18344-18345	-	
76-9	18345-18346	+	
76-10	18346-18347	-	
76-11	18347-18348	-	
76-12	18348-18349	-	
76-13	18349-18350	-	
76-14	18350-18351	-	
76-15	18351-18352	-	
76-16	18352-18353	-	
76-17	18353-18354	-	
76-18	18354-18355	-	
76-19	18355-18356	-	
76-20	18356-18357	-	
76-21	18357-18358	-	
76-22	18358-18359	-	
76-23	18359-18360	-	
76-24	18360-18361	-	
76-25	18361-18362	-	
76-26	18362-18363	-	
76-27	18363-18364	-	
76-28	18364-18365	-	
76-29	18365-18366	-	
76-30	18366-18367	-	
76-31	18367-18368	-	
76-32	18368-18369	-	
76-33	18369-18370	-	
76-34	18370-18371	-	
76-35	18371-18372	-	
76-36	18372-18373	-	
76-37	18373-18374	-	
76-38	18374-18375	-	
76-39	18375-18376	-	
76-40	18376-18377	+	
76-41	18377-18378	-	
76-42	18378-18379	-	
76-43	18379-18380	-	
76-44	18380-18381	-	
76-45	18381-18382	-	
76-46	18382-18383	-	
76-47	18383-18384	-	
76-48	18384-18385	+	
76-49	18385-18386	-	
76-50	18386-18387	-	
76-51	18387-18388	-	
76-52	18388-18389	-	
76-53	18389-18390	-	
76-54	18390-18391	-	
76-55	18391-18392	-	
76-56	18392-18393	+	
76-57	18393-18394	-	
76-58	18394-18395	-	
76-59	18395-18396	-	
76-60	18396-18397	-	
76-61	18397-18398	-	
76-62	18398-18399	-	
76-63	18399-18400	-	
76-64	18400-18401	+	
76-65	18401-18402	-	
76-66	18402-18403	-	
76-67	18403-18404	-	
76-68	18404-18405	-	
76-69	18405-18406	-	
76-70	18406-18407	-	
76-71	18407-18408	-	
76-72	18408-18409	-	
76-73	18409-18410	-	
76-74	18411-18417	public	
76-75	18418-18419	|	
76-76	18420-18448	users_unactivated_partial_ix	
76-77	18449-18450	|	
76-78	18451-18456	index	
76-79	18457-18458	|	
76-80	18459-18463	haki	
76-81	18464-18465	|	
76-82	18466-18471	users	
76-83	18472-18473	|	
76-84	18474-18478	2216	
76-85	18479-18481	kB	
76-86	18482-18485	The	
76-87	18486-18493	partial	
76-88	18494-18499	index	
76-89	18500-18506	weighs	
76-90	18507-18511	only	
76-91	18512-18517	2.2MB	
76-92	18517-18518	.	
76-93	18519-18522	The	
76-94	18523-18527	full	
76-95	18528-18533	index	
76-96	18534-18536	on	
76-97	18537-18540	the	
76-98	18541-18547	column	
76-99	18548-18555	weighed	
76-100	18556-18560	21MB	
76-101	18560-18561	.	
76-102	18562-18565	The	
76-103	18566-18573	partial	
76-104	18574-18579	index	
76-105	18580-18582	is	
76-106	18583-18590	exactly	
76-107	18591-18594	10%	
76-108	18595-18598	the	
76-109	18599-18603	size	
76-110	18604-18606	of	
76-111	18607-18610	the	
76-112	18611-18615	full	
76-113	18616-18621	index	
76-114	18621-18622	,	
76-115	18623-18628	which	
76-116	18629-18636	matches	
76-117	18637-18640	the	
76-118	18641-18646	ratio	
76-119	18647-18649	of	
76-120	18650-18658	inactive	
76-121	18659-18664	users	
76-122	18665-18667	in	
76-123	18668-18671	the	
76-124	18672-18677	table	
76-125	18677-18678	.	

#Text=Always Load Sorted Data This is one of the things I comment most about in code reviews. It's not as intuitive as the other tips and it can have a huge impact on performance. Say you have a large sales fact table: db=# CREATE TABLE sale_fact (id serial, username text, sold_at date);
77-1	18679-18685	Always	
77-2	18686-18690	Load	
77-3	18691-18697	Sorted	
77-4	18698-18702	Data	
77-5	18703-18707	This	
77-6	18708-18710	is	
77-7	18711-18714	one	
77-8	18715-18717	of	
77-9	18718-18721	the	
77-10	18722-18728	things	
77-11	18729-18730	I	
77-12	18731-18738	comment	
77-13	18739-18743	most	
77-14	18744-18749	about	
77-15	18750-18752	in	
77-16	18753-18757	code	
77-17	18758-18765	reviews	
77-18	18765-18766	.	
77-19	18767-18771	It's	
77-20	18772-18775	not	
77-21	18776-18778	as	
77-22	18779-18788	intuitive	
77-23	18789-18791	as	
77-24	18792-18795	the	
77-25	18796-18801	other	
77-26	18802-18806	tips	
77-27	18807-18810	and	
77-28	18811-18813	it	
77-29	18814-18817	can	
77-30	18818-18822	have	
77-31	18823-18824	a	
77-32	18825-18829	huge	
77-33	18830-18836	impact	
77-34	18837-18839	on	
77-35	18840-18851	performance	
77-36	18851-18852	.	
77-37	18853-18856	Say	
77-38	18857-18860	you	
77-39	18861-18865	have	
77-40	18866-18867	a	
77-41	18868-18873	large	
77-42	18874-18879	sales	
77-43	18880-18884	fact	
77-44	18885-18890	table	
77-45	18890-18891	:	
77-46	18892-18894	db	
77-47	18894-18895	=	
77-48	18895-18896	#	
77-49	18897-18903	CREATE	
77-50	18904-18909	TABLE	
77-51	18910-18919	sale_fact	
77-52	18920-18921	(	
77-53	18921-18923	id	
77-54	18924-18930	serial	
77-55	18930-18931	,	
77-56	18932-18940	username	
77-57	18941-18945	text	
77-58	18945-18946	,	
77-59	18947-18954	sold_at	
77-60	18955-18959	date	
77-61	18959-18960	)	
77-62	18960-18961	;	

#Text=CREATE TABLE Every night, during some ETL process, you load data into the table: db=# INSERT INTO sale_fact (username, sold_at) db-# SELECT db-# md5(random()::text) AS username,
78-1	18962-18968	CREATE	
78-2	18969-18974	TABLE	
78-3	18975-18980	Every	
78-4	18981-18986	night	
78-5	18986-18987	,	
78-6	18988-18994	during	
78-7	18995-18999	some	
78-8	19000-19003	ETL	
78-9	19004-19011	process	
78-10	19011-19012	,	
78-11	19013-19016	you	
78-12	19017-19021	load	
78-13	19022-19026	data	
78-14	19027-19031	into	
78-15	19032-19035	the	
78-16	19036-19041	table	
78-17	19041-19042	:	
78-18	19043-19045	db	
78-19	19045-19046	=	
78-20	19046-19047	#	
78-21	19048-19054	INSERT	
78-22	19055-19059	INTO	
78-23	19060-19069	sale_fact	
78-24	19070-19071	(	
78-25	19071-19079	username	
78-26	19079-19080	,	
78-27	19081-19088	sold_at	
78-28	19088-19089	)	
78-29	19090-19092	db	
78-30	19092-19093	-	
78-31	19093-19094	#	
78-32	19095-19101	SELECT	
78-33	19102-19104	db	
78-34	19104-19105	-	
78-35	19105-19106	#	
78-36	19107-19110	md5	
78-37	19110-19111	(	
78-38	19111-19117	random	
78-39	19117-19118	(	
78-40	19118-19119	)	
78-41	19119-19120	:	
78-42	19120-19121	:	
78-43	19121-19125	text	
78-44	19125-19126	)	
78-45	19127-19129	AS	
78-46	19130-19138	username	
78-47	19138-19139	,	

#Text=db-# '2020-01-01'::date + (interval '1 day') * round(random() * 365 * 2) AS sold_at db-# FROM db-# generate_series(1, 100000);
79-1	19140-19142	db	
79-2	19142-19143	-	
79-3	19143-19144	#	
79-4	19145-19146	'	
79-5	19146-19150	2020	
79-6	19150-19151	-	
79-7	19151-19153	01	
79-8	19153-19154	-	
79-9	19154-19156	01	
79-10	19156-19157	'	
79-11	19157-19158	:	
79-12	19158-19159	:	
79-13	19159-19163	date	
79-14	19164-19165	+	
79-15	19166-19167	(	
79-16	19167-19175	interval	
79-17	19176-19177	'	
79-18	19177-19178	1	
79-19	19179-19182	day	
79-20	19182-19183	'	
79-21	19183-19184	)	
79-22	19185-19186	*	
79-23	19187-19192	round	
79-24	19192-19193	(	
79-25	19193-19199	random	
79-26	19199-19200	(	
79-27	19200-19201	)	
79-28	19202-19203	*	
79-29	19204-19207	365	
79-30	19208-19209	*	
79-31	19210-19211	2	
79-32	19211-19212	)	
79-33	19213-19215	AS	
79-34	19216-19223	sold_at	
79-35	19224-19226	db	
79-36	19226-19227	-	
79-37	19227-19228	#	
79-38	19229-19233	FROM	
79-39	19234-19236	db	
79-40	19236-19237	-	
79-41	19237-19238	#	
79-42	19239-19254	generate_series	
79-43	19254-19255	(	
79-44	19255-19256	1	
79-45	19256-19257	,	
79-46	19258-19264	100000	
79-47	19264-19265	)	
79-48	19265-19266	;	

#Text=INSERT 0 100000 db=# VACUUM ANALYZE sale_fact; VACUUM To fake a loading process we used random data. We inserted 100K rows with random username, and sale dates from 2020-01-01 to two years forward.
80-1	19267-19273	INSERT	
80-2	19274-19275	0	
80-3	19276-19282	100000	
80-4	19283-19285	db	
80-5	19285-19286	=	
80-6	19286-19287	#	
80-7	19288-19294	VACUUM	
80-8	19295-19302	ANALYZE	
80-9	19303-19312	sale_fact	
80-10	19312-19313	;	
80-11	19314-19320	VACUUM	
80-12	19321-19323	To	
80-13	19324-19328	fake	
80-14	19329-19330	a	
80-15	19331-19338	loading	
80-16	19339-19346	process	
80-17	19347-19349	we	
80-18	19350-19354	used	
80-19	19355-19361	random	
80-20	19362-19366	data	
80-21	19366-19367	.	
80-22	19368-19370	We	
80-23	19371-19379	inserted	
80-24	19380-19384	100K	
80-25	19385-19389	rows	
80-26	19390-19394	with	
80-27	19395-19401	random	
80-28	19402-19410	username	
80-29	19410-19411	,	
80-30	19412-19415	and	
80-31	19416-19420	sale	
80-32	19421-19426	dates	
80-33	19427-19431	from	
80-34	19432-19436	2020	
80-35	19436-19437	-	
80-36	19437-19439	01	
80-37	19439-19440	-	
80-38	19440-19442	01	
80-39	19443-19445	to	
80-40	19446-19449	two	
80-41	19450-19455	years	
80-42	19456-19463	forward	
80-43	19463-19464	.	

#Text=The table is used mostly to produce summary sales reports. Most reports filter by date to get the sales at a specific period. To speed up range scans you create an index on sold_at: db=# CREATE INDEX sale_fact_sold_at_ix ON sale_fact(sold_at); CREATE INDEX Let's look at the execution plan of a query to fetch all sales made in June 2020:
81-1	19465-19468	The	
81-2	19469-19474	table	
81-3	19475-19477	is	
81-4	19478-19482	used	
81-5	19483-19489	mostly	
81-6	19490-19492	to	
81-7	19493-19500	produce	
81-8	19501-19508	summary	
81-9	19509-19514	sales	
81-10	19515-19522	reports	
81-11	19522-19523	.	
81-12	19524-19528	Most	
81-13	19529-19536	reports	
81-14	19537-19543	filter	
81-15	19544-19546	by	
81-16	19547-19551	date	
81-17	19552-19554	to	
81-18	19555-19558	get	
81-19	19559-19562	the	
81-20	19563-19568	sales	
81-21	19569-19571	at	
81-22	19572-19573	a	
81-23	19574-19582	specific	
81-24	19583-19589	period	
81-25	19589-19590	.	
81-26	19591-19593	To	
81-27	19594-19599	speed	
81-28	19600-19602	up	
81-29	19603-19608	range	
81-30	19609-19614	scans	
81-31	19615-19618	you	
81-32	19619-19625	create	
81-33	19626-19628	an	
81-34	19629-19634	index	
81-35	19635-19637	on	
81-36	19638-19645	sold_at	
81-37	19645-19646	:	
81-38	19647-19649	db	
81-39	19649-19650	=	
81-40	19650-19651	#	
81-41	19652-19658	CREATE	
81-42	19659-19664	INDEX	
81-43	19665-19685	sale_fact_sold_at_ix	
81-44	19686-19688	ON	
81-45	19689-19698	sale_fact	
81-46	19698-19699	(	
81-47	19699-19706	sold_at	
81-48	19706-19707	)	
81-49	19707-19708	;	
81-50	19709-19715	CREATE	
81-51	19716-19721	INDEX	
81-52	19722-19727	Let's	
81-53	19728-19732	look	
81-54	19733-19735	at	
81-55	19736-19739	the	
81-56	19740-19749	execution	
81-57	19750-19754	plan	
81-58	19755-19757	of	
81-59	19758-19759	a	
81-60	19760-19765	query	
81-61	19766-19768	to	
81-62	19769-19774	fetch	
81-63	19775-19778	all	
81-64	19779-19784	sales	
81-65	19785-19789	made	
81-66	19790-19792	in	
81-67	19793-19797	June	
81-68	19798-19802	2020	
81-69	19802-19803	:	

#Text=db=# EXPLAIN (ANALYZE) db-# SELECT * db-# FROM sale_fact db-# WHERE sold_at BETWEEN '2020-07-01' AND '2020-07-31'; QUERY PLAN
82-1	19804-19806	db	
82-2	19806-19807	=	
82-3	19807-19808	#	
82-4	19809-19816	EXPLAIN	
82-5	19817-19818	(	
82-6	19818-19825	ANALYZE	
82-7	19825-19826	)	
82-8	19827-19829	db	
82-9	19829-19830	-	
82-10	19830-19831	#	
82-11	19832-19838	SELECT	
82-12	19839-19840	*	
82-13	19841-19843	db	
82-14	19843-19844	-	
82-15	19844-19845	#	
82-16	19846-19850	FROM	
82-17	19851-19860	sale_fact	
82-18	19861-19863	db	
82-19	19863-19864	-	
82-20	19864-19865	#	
82-21	19866-19871	WHERE	
82-22	19872-19879	sold_at	
82-23	19880-19887	BETWEEN	
82-24	19888-19889	'	
82-25	19889-19893	2020	
82-26	19893-19894	-	
82-27	19894-19896	07	
82-28	19896-19897	-	
82-29	19897-19899	01	
82-30	19899-19900	'	
82-31	19901-19904	AND	
82-32	19905-19906	'	
82-33	19906-19910	2020	
82-34	19910-19911	-	
82-35	19911-19913	07	
82-36	19913-19914	-	
82-37	19914-19916	31	
82-38	19916-19917	'	
82-39	19917-19918	;	
82-40	19919-19924	QUERY	
82-41	19925-19929	PLAN	

#Text=----------------------------------------------------------------------------------------------- Bitmap Heap Scan on sale_fact (cost=108.30..1107.69 rows=4293 width=41) Recheck Cond: ((sold_at >= '2020-07-01'::date) AND (sold_at <= '2020-07-31'::date))
83-1	19930-19931	-	
83-2	19931-19932	-	
83-3	19932-19933	-	
83-4	19933-19934	-	
83-5	19934-19935	-	
83-6	19935-19936	-	
83-7	19936-19937	-	
83-8	19937-19938	-	
83-9	19938-19939	-	
83-10	19939-19940	-	
83-11	19940-19941	-	
83-12	19941-19942	-	
83-13	19942-19943	-	
83-14	19943-19944	-	
83-15	19944-19945	-	
83-16	19945-19946	-	
83-17	19946-19947	-	
83-18	19947-19948	-	
83-19	19948-19949	-	
83-20	19949-19950	-	
83-21	19950-19951	-	
83-22	19951-19952	-	
83-23	19952-19953	-	
83-24	19953-19954	-	
83-25	19954-19955	-	
83-26	19955-19956	-	
83-27	19956-19957	-	
83-28	19957-19958	-	
83-29	19958-19959	-	
83-30	19959-19960	-	
83-31	19960-19961	-	
83-32	19961-19962	-	
83-33	19962-19963	-	
83-34	19963-19964	-	
83-35	19964-19965	-	
83-36	19965-19966	-	
83-37	19966-19967	-	
83-38	19967-19968	-	
83-39	19968-19969	-	
83-40	19969-19970	-	
83-41	19970-19971	-	
83-42	19971-19972	-	
83-43	19972-19973	-	
83-44	19973-19974	-	
83-45	19974-19975	-	
83-46	19975-19976	-	
83-47	19976-19977	-	
83-48	19977-19978	-	
83-49	19978-19979	-	
83-50	19979-19980	-	
83-51	19980-19981	-	
83-52	19981-19982	-	
83-53	19982-19983	-	
83-54	19983-19984	-	
83-55	19984-19985	-	
83-56	19985-19986	-	
83-57	19986-19987	-	
83-58	19987-19988	-	
83-59	19988-19989	-	
83-60	19989-19990	-	
83-61	19990-19991	-	
83-62	19991-19992	-	
83-63	19992-19993	-	
83-64	19993-19994	-	
83-65	19994-19995	-	
83-66	19995-19996	-	
83-67	19996-19997	-	
83-68	19997-19998	-	
83-69	19998-19999	-	
83-70	19999-20000	-	
83-71	20000-20001	-	
83-72	20001-20002	-	
83-73	20002-20003	-	
83-74	20003-20004	-	
83-75	20004-20005	-	
83-76	20005-20006	-	
83-77	20006-20007	-	
83-78	20007-20008	-	
83-79	20008-20009	-	
83-80	20009-20010	-	
83-81	20010-20011	-	
83-82	20011-20012	-	
83-83	20012-20013	-	
83-84	20013-20014	-	
83-85	20014-20015	-	
83-86	20015-20016	-	
83-87	20016-20017	-	
83-88	20017-20018	-	
83-89	20018-20019	-	
83-90	20019-20020	-	
83-91	20020-20021	-	
83-92	20021-20022	-	
83-93	20022-20023	-	
83-94	20023-20024	-	
83-95	20024-20025	-	
83-96	20026-20032	Bitmap	
83-97	20033-20037	Heap	
83-98	20038-20042	Scan	
83-99	20043-20045	on	
83-100	20046-20055	sale_fact	
83-101	20056-20057	(	
83-102	20057-20061	cost	
83-103	20061-20062	=	
83-104	20062-20068	108.30	
83-105	20068-20069	.	
83-106	20069-20077	.1107.69	
83-107	20078-20082	rows	
83-108	20082-20083	=	
83-109	20083-20087	4293	
83-110	20088-20093	width	
83-111	20093-20094	=	
83-112	20094-20096	41	
83-113	20096-20097	)	
83-114	20098-20105	Recheck	
83-115	20106-20110	Cond	
83-116	20110-20111	:	
83-117	20112-20113	(	
83-118	20113-20114	(	
83-119	20114-20121	sold_at	
83-120	20122-20123	>	
83-121	20123-20124	=	
83-122	20125-20126	'	
83-123	20126-20130	2020	
83-124	20130-20131	-	
83-125	20131-20133	07	
83-126	20133-20134	-	
83-127	20134-20136	01	
83-128	20136-20137	'	
83-129	20137-20138	:	
83-130	20138-20139	:	
83-131	20139-20143	date	
83-132	20143-20144	)	
83-133	20145-20148	AND	
83-134	20149-20150	(	
83-135	20150-20157	sold_at	
83-136	20158-20159	<	
83-137	20159-20160	=	
83-138	20161-20162	'	
83-139	20162-20166	2020	
83-140	20166-20167	-	
83-141	20167-20169	07	
83-142	20169-20170	-	
83-143	20170-20172	31	
83-144	20172-20173	'	
83-145	20173-20174	:	
83-146	20174-20175	:	
83-147	20175-20179	date	
83-148	20179-20180	)	
83-149	20180-20181	)	

#Text=Heap Blocks: exact=927 Bitmap Index Scan on sale_fact_sold_at_ix (cost=0.00..107.22 rows=4293 width=0) Index Cond: ((sold_at >= '2020-07-01'::date) AND (sold_at <= '2020-07-31'::date))
84-1	20182-20186	Heap	
84-2	20187-20193	Blocks	
84-3	20193-20194	:	
84-4	20195-20200	exact	
84-5	20200-20201	=	
84-6	20201-20204	927	
84-7	20205-20211	Bitmap	
84-8	20212-20217	Index	
84-9	20218-20222	Scan	
84-10	20223-20225	on	
84-11	20226-20246	sale_fact_sold_at_ix	
84-12	20247-20248	(	
84-13	20248-20252	cost	
84-14	20252-20253	=	
84-15	20253-20257	0.00	
84-16	20257-20258	.	
84-17	20258-20265	.107.22	
84-18	20266-20270	rows	
84-19	20270-20271	=	
84-20	20271-20275	4293	
84-21	20276-20281	width	
84-22	20281-20282	=	
84-23	20282-20283	0	
84-24	20283-20284	)	
84-25	20285-20290	Index	
84-26	20291-20295	Cond	
84-27	20295-20296	:	
84-28	20297-20298	(	
84-29	20298-20299	(	
84-30	20299-20306	sold_at	
84-31	20307-20308	>	
84-32	20308-20309	=	
84-33	20310-20311	'	
84-34	20311-20315	2020	
84-35	20315-20316	-	
84-36	20316-20318	07	
84-37	20318-20319	-	
84-38	20319-20321	01	
84-39	20321-20322	'	
84-40	20322-20323	:	
84-41	20323-20324	:	
84-42	20324-20328	date	
84-43	20328-20329	)	
84-44	20330-20333	AND	
84-45	20334-20335	(	
84-46	20335-20342	sold_at	
84-47	20343-20344	<	
84-48	20344-20345	=	
84-49	20346-20347	'	
84-50	20347-20351	2020	
84-51	20351-20352	-	
84-52	20352-20354	07	
84-53	20354-20355	-	
84-54	20355-20357	31	
84-55	20357-20358	'	
84-56	20358-20359	:	
84-57	20359-20360	:	
84-58	20360-20364	date	
84-59	20364-20365	)	
84-60	20365-20366	)	

#Text=Planning Time: 0.191 ms Execution Time: 5.906 ms After executing the query several times to warm up the cache, the timing settled at ~6ms. Bitmap Scan Looking at the execution plan, we can see that the database used a bitmap scan. A bitmap scan works in two stages:
85-1	20367-20375	Planning	
85-2	20376-20380	Time	
85-3	20380-20381	:	
85-4	20382-20387	0.191	
85-5	20388-20390	ms	
85-6	20391-20400	Execution	
85-7	20401-20405	Time	
85-8	20405-20406	:	
85-9	20407-20412	5.906	
85-10	20413-20415	ms	
85-11	20416-20421	After	
85-12	20422-20431	executing	
85-13	20432-20435	the	
85-14	20436-20441	query	
85-15	20442-20449	several	
85-16	20450-20455	times	
85-17	20456-20458	to	
85-18	20459-20463	warm	
85-19	20464-20466	up	
85-20	20467-20470	the	
85-21	20471-20476	cache	
85-22	20476-20477	,	
85-23	20478-20481	the	
85-24	20482-20488	timing	
85-25	20489-20496	settled	
85-26	20497-20499	at	
85-27	20500-20501	~	
85-28	20501-20504	6ms	
85-29	20504-20505	.	
85-30	20506-20512	Bitmap	
85-31	20513-20517	Scan	
85-32	20518-20525	Looking	
85-33	20526-20528	at	
85-34	20529-20532	the	
85-35	20533-20542	execution	
85-36	20543-20547	plan	
85-37	20547-20548	,	
85-38	20549-20551	we	
85-39	20552-20555	can	
85-40	20556-20559	see	
85-41	20560-20564	that	
85-42	20565-20568	the	
85-43	20569-20577	database	
85-44	20578-20582	used	
85-45	20583-20584	a	
85-46	20585-20591	bitmap	
85-47	20592-20596	scan	
85-48	20596-20597	.	
85-49	20598-20599	A	
85-50	20600-20606	bitmap	
85-51	20607-20611	scan	
85-52	20612-20617	works	
85-53	20618-20620	in	
85-54	20621-20624	two	
85-55	20625-20631	stages	
85-56	20631-20632	:	

#Text=Bitmap Index Scan: Go through the entire index sale_fact_sold_at_ix and map all the table pages that contain relevant rows. Bitmap Heap Scan: Read the pages that contain relevant rows, and find the rows inside these pages that satisfy the condition. Pages can contain multiple rows. The first step uses the index to find pages. The second step check for rows inside these pages, hence the "Recheck Cond" operation in the execution plan.
86-1	20633-20639	Bitmap	
86-2	20640-20645	Index	
86-3	20646-20650	Scan	
86-4	20650-20651	:	
86-5	20652-20654	Go	
86-6	20655-20662	through	
86-7	20663-20666	the	
86-8	20667-20673	entire	
86-9	20674-20679	index	
86-10	20680-20700	sale_fact_sold_at_ix	
86-11	20701-20704	and	
86-12	20705-20708	map	
86-13	20709-20712	all	
86-14	20713-20716	the	
86-15	20717-20722	table	
86-16	20723-20728	pages	
86-17	20729-20733	that	
86-18	20734-20741	contain	
86-19	20742-20750	relevant	
86-20	20751-20755	rows	
86-21	20755-20756	.	
86-22	20757-20763	Bitmap	
86-23	20764-20768	Heap	
86-24	20769-20773	Scan	
86-25	20773-20774	:	
86-26	20775-20779	Read	
86-27	20780-20783	the	
86-28	20784-20789	pages	
86-29	20790-20794	that	
86-30	20795-20802	contain	
86-31	20803-20811	relevant	
86-32	20812-20816	rows	
86-33	20816-20817	,	
86-34	20818-20821	and	
86-35	20822-20826	find	
86-36	20827-20830	the	
86-37	20831-20835	rows	
86-38	20836-20842	inside	
86-39	20843-20848	these	
86-40	20849-20854	pages	
86-41	20855-20859	that	
86-42	20860-20867	satisfy	
86-43	20868-20871	the	
86-44	20872-20881	condition	
86-45	20881-20882	.	
86-46	20883-20888	Pages	
86-47	20889-20892	can	
86-48	20893-20900	contain	
86-49	20901-20909	multiple	
86-50	20910-20914	rows	
86-51	20914-20915	.	
86-52	20916-20919	The	
86-53	20920-20925	first	
86-54	20926-20930	step	
86-55	20931-20935	uses	
86-56	20936-20939	the	
86-57	20940-20945	index	
86-58	20946-20948	to	
86-59	20949-20953	find	
86-60	20954-20959	pages	
86-61	20959-20960	.	
86-62	20961-20964	The	
86-63	20965-20971	second	
86-64	20972-20976	step	
86-65	20977-20982	check	
86-66	20983-20986	for	
86-67	20987-20991	rows	
86-68	20992-20998	inside	
86-69	20999-21004	these	
86-70	21005-21010	pages	
86-71	21010-21011	,	
86-72	21012-21017	hence	
86-73	21018-21021	the	
86-74	21022-21023	"	
86-75	21023-21030	Recheck	
86-76	21031-21035	Cond	
86-77	21035-21036	"	
86-78	21037-21046	operation	
86-79	21047-21049	in	
86-80	21050-21053	the	
86-81	21054-21063	execution	
86-82	21064-21068	plan	
86-83	21068-21069	.	

#Text=At this point many DBAs and developers will call it a day and move on to the next query. BUT, there's a way to make this query better. Index Scan To make things better, we'll make a small change in how we load the data. db=# TRUNCATE sale_fact; TRUNCATE TABLE db=# INSERT INTO sale_fact (username, sold_at)
87-1	21070-21072	At	
87-2	21073-21077	this	
87-3	21078-21083	point	
87-4	21084-21088	many	
87-5	21089-21093	DBAs	
87-6	21094-21097	and	
87-7	21098-21108	developers	
87-8	21109-21113	will	
87-9	21114-21118	call	
87-10	21119-21121	it	
87-11	21122-21123	a	
87-12	21124-21127	day	
87-13	21128-21131	and	
87-14	21132-21136	move	
87-15	21137-21139	on	
87-16	21140-21142	to	
87-17	21143-21146	the	
87-18	21147-21151	next	
87-19	21152-21157	query	
87-20	21157-21158	.	
87-21	21159-21162	BUT	
87-22	21162-21163	,	
87-23	21164-21171	there's	
87-24	21172-21173	a	
87-25	21174-21177	way	
87-26	21178-21180	to	
87-27	21181-21185	make	
87-28	21186-21190	this	
87-29	21191-21196	query	
87-30	21197-21203	better	
87-31	21203-21204	.	
87-32	21205-21210	Index	
87-33	21211-21215	Scan	
87-34	21216-21218	To	
87-35	21219-21223	make	
87-36	21224-21230	things	
87-37	21231-21237	better	
87-38	21237-21238	,	
87-39	21239-21244	we'll	
87-40	21245-21249	make	
87-41	21250-21251	a	
87-42	21252-21257	small	
87-43	21258-21264	change	
87-44	21265-21267	in	
87-45	21268-21271	how	
87-46	21272-21274	we	
87-47	21275-21279	load	
87-48	21280-21283	the	
87-49	21284-21288	data	
87-50	21288-21289	.	
87-51	21290-21292	db	
87-52	21292-21293	=	
87-53	21293-21294	#	
87-54	21295-21303	TRUNCATE	
87-55	21304-21313	sale_fact	
87-56	21313-21314	;	
87-57	21315-21323	TRUNCATE	
87-58	21324-21329	TABLE	
87-59	21330-21332	db	
87-60	21332-21333	=	
87-61	21333-21334	#	
87-62	21335-21341	INSERT	
87-63	21342-21346	INTO	
87-64	21347-21356	sale_fact	
87-65	21357-21358	(	
87-66	21358-21366	username	
87-67	21366-21367	,	
87-68	21368-21375	sold_at	
87-69	21375-21376	)	

#Text=db-# SELECT db-# md5(random()::text) AS username, db-# '2020-01-01'::date + (interval '1 day') * round(random() * 365 * 2) AS sold_at
88-1	21377-21379	db	
88-2	21379-21380	-	
88-3	21380-21381	#	
88-4	21382-21388	SELECT	
88-5	21389-21391	db	
88-6	21391-21392	-	
88-7	21392-21393	#	
88-8	21394-21397	md5	
88-9	21397-21398	(	
88-10	21398-21404	random	
88-11	21404-21405	(	
88-12	21405-21406	)	
88-13	21406-21407	:	
88-14	21407-21408	:	
88-15	21408-21412	text	
88-16	21412-21413	)	
88-17	21414-21416	AS	
88-18	21417-21425	username	
88-19	21425-21426	,	
88-20	21427-21429	db	
88-21	21429-21430	-	
88-22	21430-21431	#	
88-23	21432-21433	'	
88-24	21433-21437	2020	
88-25	21437-21438	-	
88-26	21438-21440	01	
88-27	21440-21441	-	
88-28	21441-21443	01	
88-29	21443-21444	'	
88-30	21444-21445	:	
88-31	21445-21446	:	
88-32	21446-21450	date	
88-33	21451-21452	+	
88-34	21453-21454	(	
88-35	21454-21462	interval	
88-36	21463-21464	'	
88-37	21464-21465	1	
88-38	21466-21469	day	
88-39	21469-21470	'	
88-40	21470-21471	)	
88-41	21472-21473	*	
88-42	21474-21479	round	
88-43	21479-21480	(	
88-44	21480-21486	random	
88-45	21486-21487	(	
88-46	21487-21488	)	
88-47	21489-21490	*	
88-48	21491-21494	365	
88-49	21495-21496	*	
88-50	21497-21498	2	
88-51	21498-21499	)	
88-52	21500-21502	AS	
88-53	21503-21510	sold_at	

#Text=db-# FROM db-# generate_series(1, 100000) db-# ORDER BY sold_at; INSERT 0 100000 db=# VACUUM ANALYZE sale_fact; VACUUM
89-1	21511-21513	db	
89-2	21513-21514	-	
89-3	21514-21515	#	
89-4	21516-21520	FROM	
89-5	21521-21523	db	
89-6	21523-21524	-	
89-7	21524-21525	#	
89-8	21526-21541	generate_series	
89-9	21541-21542	(	
89-10	21542-21543	1	
89-11	21543-21544	,	
89-12	21545-21551	100000	
89-13	21551-21552	)	
89-14	21553-21555	db	
89-15	21555-21556	-	
89-16	21556-21557	#	
89-17	21558-21563	ORDER	
89-18	21564-21566	BY	
89-19	21567-21574	sold_at	
89-20	21574-21575	;	
89-21	21576-21582	INSERT	
89-22	21583-21584	0	
89-23	21585-21591	100000	
89-24	21592-21594	db	
89-25	21594-21595	=	
89-26	21595-21596	#	
89-27	21597-21603	VACUUM	
89-28	21604-21611	ANALYZE	
89-29	21612-21621	sale_fact	
89-30	21621-21622	;	
89-31	21623-21629	VACUUM	

#Text=This time, we loaded the data sorted by the sold_at. Let's see what the execution plan for the exact same query looks like now: db=# EXPLAIN (ANALYZE) db-# SELECT * db-# FROM sale_fact
90-1	21630-21634	This	
90-2	21635-21639	time	
90-3	21639-21640	,	
90-4	21641-21643	we	
90-5	21644-21650	loaded	
90-6	21651-21654	the	
90-7	21655-21659	data	
90-8	21660-21666	sorted	
90-9	21667-21669	by	
90-10	21670-21673	the	
90-11	21674-21681	sold_at	
90-12	21681-21682	.	
90-13	21683-21688	Let's	
90-14	21689-21692	see	
90-15	21693-21697	what	
90-16	21698-21701	the	
90-17	21702-21711	execution	
90-18	21712-21716	plan	
90-19	21717-21720	for	
90-20	21721-21724	the	
90-21	21725-21730	exact	
90-22	21731-21735	same	
90-23	21736-21741	query	
90-24	21742-21747	looks	
90-25	21748-21752	like	
90-26	21753-21756	now	
90-27	21756-21757	:	
90-28	21758-21760	db	
90-29	21760-21761	=	
90-30	21761-21762	#	
90-31	21763-21770	EXPLAIN	
90-32	21771-21772	(	
90-33	21772-21779	ANALYZE	
90-34	21779-21780	)	
90-35	21781-21783	db	
90-36	21783-21784	-	
90-37	21784-21785	#	
90-38	21786-21792	SELECT	
90-39	21793-21794	*	
90-40	21795-21797	db	
90-41	21797-21798	-	
90-42	21798-21799	#	
90-43	21800-21804	FROM	
90-44	21805-21814	sale_fact	

#Text=db-# WHERE sold_at BETWEEN '2020-07-01' AND '2020-07-31'; QUERY PLAN ---------------------------------------------------------------------------------------------
91-1	21815-21817	db	
91-2	21817-21818	-	
91-3	21818-21819	#	
91-4	21820-21825	WHERE	
91-5	21826-21833	sold_at	
91-6	21834-21841	BETWEEN	
91-7	21842-21843	'	
91-8	21843-21847	2020	
91-9	21847-21848	-	
91-10	21848-21850	07	
91-11	21850-21851	-	
91-12	21851-21853	01	
91-13	21853-21854	'	
91-14	21855-21858	AND	
91-15	21859-21860	'	
91-16	21860-21864	2020	
91-17	21864-21865	-	
91-18	21865-21867	07	
91-19	21867-21868	-	
91-20	21868-21870	31	
91-21	21870-21871	'	
91-22	21871-21872	;	
91-23	21873-21878	QUERY	
91-24	21879-21883	PLAN	
91-25	21884-21885	-	
91-26	21885-21886	-	
91-27	21886-21887	-	
91-28	21887-21888	-	
91-29	21888-21889	-	
91-30	21889-21890	-	
91-31	21890-21891	-	
91-32	21891-21892	-	
91-33	21892-21893	-	
91-34	21893-21894	-	
91-35	21894-21895	-	
91-36	21895-21896	-	
91-37	21896-21897	-	
91-38	21897-21898	-	
91-39	21898-21899	-	
91-40	21899-21900	-	
91-41	21900-21901	-	
91-42	21901-21902	-	
91-43	21902-21903	-	
91-44	21903-21904	-	
91-45	21904-21905	-	
91-46	21905-21906	-	
91-47	21906-21907	-	
91-48	21907-21908	-	
91-49	21908-21909	-	
91-50	21909-21910	-	
91-51	21910-21911	-	
91-52	21911-21912	-	
91-53	21912-21913	-	
91-54	21913-21914	-	
91-55	21914-21915	-	
91-56	21915-21916	-	
91-57	21916-21917	-	
91-58	21917-21918	-	
91-59	21918-21919	-	
91-60	21919-21920	-	
91-61	21920-21921	-	
91-62	21921-21922	-	
91-63	21922-21923	-	
91-64	21923-21924	-	
91-65	21924-21925	-	
91-66	21925-21926	-	
91-67	21926-21927	-	
91-68	21927-21928	-	
91-69	21928-21929	-	
91-70	21929-21930	-	
91-71	21930-21931	-	
91-72	21931-21932	-	
91-73	21932-21933	-	
91-74	21933-21934	-	
91-75	21934-21935	-	
91-76	21935-21936	-	
91-77	21936-21937	-	
91-78	21937-21938	-	
91-79	21938-21939	-	
91-80	21939-21940	-	
91-81	21940-21941	-	
91-82	21941-21942	-	
91-83	21942-21943	-	
91-84	21943-21944	-	
91-85	21944-21945	-	
91-86	21945-21946	-	
91-87	21946-21947	-	
91-88	21947-21948	-	
91-89	21948-21949	-	
91-90	21949-21950	-	
91-91	21950-21951	-	
91-92	21951-21952	-	
91-93	21952-21953	-	
91-94	21953-21954	-	
91-95	21954-21955	-	
91-96	21955-21956	-	
91-97	21956-21957	-	
91-98	21957-21958	-	
91-99	21958-21959	-	
91-100	21959-21960	-	
91-101	21960-21961	-	
91-102	21961-21962	-	
91-103	21962-21963	-	
91-104	21963-21964	-	
91-105	21964-21965	-	
91-106	21965-21966	-	
91-107	21966-21967	-	
91-108	21967-21968	-	
91-109	21968-21969	-	
91-110	21969-21970	-	
91-111	21970-21971	-	
91-112	21971-21972	-	
91-113	21972-21973	-	
91-114	21973-21974	-	
91-115	21974-21975	-	
91-116	21975-21976	-	
91-117	21976-21977	-	

#Text=Index Scan using sale_fact_sold_at_ix on sale_fact (cost=0.29..184.73 rows=4272 width=41) Index Cond: ((sold_at >= '2020-07-01'::date) AND (sold_at <= '2020-07-31'::date)) Planning Time: 0.145 ms Execution Time: 2.294 ms
92-1	21978-21983	Index	
92-2	21984-21988	Scan	
92-3	21989-21994	using	
92-4	21995-22015	sale_fact_sold_at_ix	
92-5	22016-22018	on	
92-6	22019-22028	sale_fact	
92-7	22029-22030	(	
92-8	22030-22034	cost	
92-9	22034-22035	=	
92-10	22035-22039	0.29	
92-11	22039-22040	.	
92-12	22040-22047	.184.73	
92-13	22048-22052	rows	
92-14	22052-22053	=	
92-15	22053-22057	4272	
92-16	22058-22063	width	
92-17	22063-22064	=	
92-18	22064-22066	41	
92-19	22066-22067	)	
92-20	22068-22073	Index	
92-21	22074-22078	Cond	
92-22	22078-22079	:	
92-23	22080-22081	(	
92-24	22081-22082	(	
92-25	22082-22089	sold_at	
92-26	22090-22091	>	
92-27	22091-22092	=	
92-28	22093-22094	'	
92-29	22094-22098	2020	
92-30	22098-22099	-	
92-31	22099-22101	07	
92-32	22101-22102	-	
92-33	22102-22104	01	
92-34	22104-22105	'	
92-35	22105-22106	:	
92-36	22106-22107	:	
92-37	22107-22111	date	
92-38	22111-22112	)	
92-39	22113-22116	AND	
92-40	22117-22118	(	
92-41	22118-22125	sold_at	
92-42	22126-22127	<	
92-43	22127-22128	=	
92-44	22129-22130	'	
92-45	22130-22134	2020	
92-46	22134-22135	-	
92-47	22135-22137	07	
92-48	22137-22138	-	
92-49	22138-22140	31	
92-50	22140-22141	'	
92-51	22141-22142	:	
92-52	22142-22143	:	
92-53	22143-22147	date	
92-54	22147-22148	)	
92-55	22148-22149	)	
92-56	22150-22158	Planning	
92-57	22159-22163	Time	
92-58	22163-22164	:	
92-59	22165-22170	0.145	
92-60	22171-22173	ms	
92-61	22174-22183	Execution	
92-62	22184-22188	Time	
92-63	22188-22189	:	
92-64	22190-22195	2.294	
92-65	22196-22198	ms	

#Text=After running the query several times we get a stable timing at round 2.3ms. Compared to the previous query that took ~6ms, we get a consistent saving of ~60%. Another thing we can see right away, is that the database did not use a bitmap scan this time, but a "regular" index scan. Why is that? Correlation When the database is analyzing a table it collects all sort of statistics. One of those statistics is correlation:
93-1	22199-22204	After	
93-2	22205-22212	running	
93-3	22213-22216	the	
93-4	22217-22222	query	
93-5	22223-22230	several	
93-6	22231-22236	times	
93-7	22237-22239	we	
93-8	22240-22243	get	
93-9	22244-22245	a	
93-10	22246-22252	stable	
93-11	22253-22259	timing	
93-12	22260-22262	at	
93-13	22263-22268	round	
93-14	22269-22274	2.3ms	
93-15	22274-22275	.	
93-16	22276-22284	Compared	
93-17	22285-22287	to	
93-18	22288-22291	the	
93-19	22292-22300	previous	
93-20	22301-22306	query	
93-21	22307-22311	that	
93-22	22312-22316	took	
93-23	22317-22318	~	
93-24	22318-22321	6ms	
93-25	22321-22322	,	
93-26	22323-22325	we	
93-27	22326-22329	get	
93-28	22330-22331	a	
93-29	22332-22342	consistent	
93-30	22343-22349	saving	
93-31	22350-22352	of	
93-32	22353-22354	~	
93-33	22354-22357	60%	
93-34	22357-22358	.	
93-35	22359-22366	Another	
93-36	22367-22372	thing	
93-37	22373-22375	we	
93-38	22376-22379	can	
93-39	22380-22383	see	
93-40	22384-22389	right	
93-41	22390-22394	away	
93-42	22394-22395	,	
93-43	22396-22398	is	
93-44	22399-22403	that	
93-45	22404-22407	the	
93-46	22408-22416	database	
93-47	22417-22420	did	
93-48	22421-22424	not	
93-49	22425-22428	use	
93-50	22429-22430	a	
93-51	22431-22437	bitmap	
93-52	22438-22442	scan	
93-53	22443-22447	this	
93-54	22448-22452	time	
93-55	22452-22453	,	
93-56	22454-22457	but	
93-57	22458-22459	a	
93-58	22460-22461	"	
93-59	22461-22468	regular	
93-60	22468-22469	"	
93-61	22470-22475	index	
93-62	22476-22480	scan	
93-63	22480-22481	.	
93-64	22482-22485	Why	
93-65	22486-22488	is	
93-66	22489-22493	that	
93-67	22493-22494	?	
93-68	22495-22506	Correlation	
93-69	22507-22511	When	
93-70	22512-22515	the	
93-71	22516-22524	database	
93-72	22525-22527	is	
93-73	22528-22537	analyzing	
93-74	22538-22539	a	
93-75	22540-22545	table	
93-76	22546-22548	it	
93-77	22549-22557	collects	
93-78	22558-22561	all	
93-79	22562-22566	sort	
93-80	22567-22569	of	
93-81	22570-22580	statistics	
93-82	22580-22581	.	
93-83	22582-22585	One	
93-84	22586-22588	of	
93-85	22589-22594	those	
93-86	22595-22605	statistics	
93-87	22606-22608	is	
93-88	22609-22620	correlation	
93-89	22620-22621	:	

#Text=Statistical correlation between physical row ordering and logical ordering of the column values. This ranges from -1 to +1. When the value is near -1 or +1, an index scan on the column will be estimated to be cheaper than when it is near zero, due to reduction of random access to the disk. As the official documentation explains, the correlation measures how "sorted" values of a specific column are on disk. correlation = 1
94-1	22622-22633	Statistical	
94-2	22634-22645	correlation	
94-3	22646-22653	between	
94-4	22654-22662	physical	
94-5	22663-22666	row	
94-6	22667-22675	ordering	
94-7	22676-22679	and	
94-8	22680-22687	logical	
94-9	22688-22696	ordering	
94-10	22697-22699	of	
94-11	22700-22703	the	
94-12	22704-22710	column	
94-13	22711-22717	values	
94-14	22717-22718	.	
94-15	22719-22723	This	
94-16	22724-22730	ranges	
94-17	22731-22735	from	
94-18	22736-22737	-	
94-19	22737-22738	1	
94-20	22739-22741	to	
94-21	22742-22743	+	
94-22	22743-22744	1	
94-23	22744-22745	.	
94-24	22746-22750	When	
94-25	22751-22754	the	
94-26	22755-22760	value	
94-27	22761-22763	is	
94-28	22764-22768	near	
94-29	22769-22770	-	
94-30	22770-22771	1	
94-31	22772-22774	or	
94-32	22775-22776	+	
94-33	22776-22777	1	
94-34	22777-22778	,	
94-35	22779-22781	an	
94-36	22782-22787	index	
94-37	22788-22792	scan	
94-38	22793-22795	on	
94-39	22796-22799	the	
94-40	22800-22806	column	
94-41	22807-22811	will	
94-42	22812-22814	be	
94-43	22815-22824	estimated	
94-44	22825-22827	to	
94-45	22828-22830	be	
94-46	22831-22838	cheaper	
94-47	22839-22843	than	
94-48	22844-22848	when	
94-49	22849-22851	it	
94-50	22852-22854	is	
94-51	22855-22859	near	
94-52	22860-22864	zero	
94-53	22864-22865	,	
94-54	22866-22869	due	
94-55	22870-22872	to	
94-56	22873-22882	reduction	
94-57	22883-22885	of	
94-58	22886-22892	random	
94-59	22893-22899	access	
94-60	22900-22902	to	
94-61	22903-22906	the	
94-62	22907-22911	disk	
94-63	22911-22912	.	
94-64	22913-22915	As	
94-65	22916-22919	the	
94-66	22920-22928	official	
94-67	22929-22942	documentation	
94-68	22943-22951	explains	
94-69	22951-22952	,	
94-70	22953-22956	the	
94-71	22957-22968	correlation	
94-72	22969-22977	measures	
94-73	22978-22981	how	
94-74	22982-22983	"	
94-75	22983-22989	sorted	
94-76	22989-22990	"	
94-77	22991-22997	values	
94-78	22998-23000	of	
94-79	23001-23002	a	
94-80	23003-23011	specific	
94-81	23012-23018	column	
94-82	23019-23022	are	
94-83	23023-23025	on	
94-84	23026-23030	disk	
94-85	23030-23031	.	
94-86	23032-23043	correlation	
94-87	23044-23045	=	
94-88	23046-23047	1	

#Text=When the correlation is 1, or close to 1, it means the pages in the tables are stored on disk in roughly the same order as the rows in the table. This is actually very common. For example, auto incrementing ID's will usually have a correlation close to 1. Date and timestamp columns that keeps track of when rows were created will also usually have a correlation close to 1. When the correlation is -1, the pages of the table are sorted in reverse order relative to the column. correlation ~ 0 When the correlation is close to 0, it mean the values in the column have no or very little correlation to how the pages of the table are stored.
95-1	23048-23052	When	
95-2	23053-23056	the	
95-3	23057-23068	correlation	
95-4	23069-23071	is	
95-5	23072-23073	1	
95-6	23073-23074	,	
95-7	23075-23077	or	
95-8	23078-23083	close	
95-9	23084-23086	to	
95-10	23087-23088	1	
95-11	23088-23089	,	
95-12	23090-23092	it	
95-13	23093-23098	means	
95-14	23099-23102	the	
95-15	23103-23108	pages	
95-16	23109-23111	in	
95-17	23112-23115	the	
95-18	23116-23122	tables	
95-19	23123-23126	are	
95-20	23127-23133	stored	
95-21	23134-23136	on	
95-22	23137-23141	disk	
95-23	23142-23144	in	
95-24	23145-23152	roughly	
95-25	23153-23156	the	
95-26	23157-23161	same	
95-27	23162-23167	order	
95-28	23168-23170	as	
95-29	23171-23174	the	
95-30	23175-23179	rows	
95-31	23180-23182	in	
95-32	23183-23186	the	
95-33	23187-23192	table	
95-34	23192-23193	.	
95-35	23194-23198	This	
95-36	23199-23201	is	
95-37	23202-23210	actually	
95-38	23211-23215	very	
95-39	23216-23222	common	
95-40	23222-23223	.	
95-41	23224-23227	For	
95-42	23228-23235	example	
95-43	23235-23236	,	
95-44	23237-23241	auto	
95-45	23242-23254	incrementing	
95-46	23255-23259	ID's	
95-47	23260-23264	will	
95-48	23265-23272	usually	
95-49	23273-23277	have	
95-50	23278-23279	a	
95-51	23280-23291	correlation	
95-52	23292-23297	close	
95-53	23298-23300	to	
95-54	23301-23302	1	
95-55	23302-23303	.	
95-56	23304-23308	Date	
95-57	23309-23312	and	
95-58	23313-23322	timestamp	
95-59	23323-23330	columns	
95-60	23331-23335	that	
95-61	23336-23341	keeps	
95-62	23342-23347	track	
95-63	23348-23350	of	
95-64	23351-23355	when	
95-65	23356-23360	rows	
95-66	23361-23365	were	
95-67	23366-23373	created	
95-68	23374-23378	will	
95-69	23379-23383	also	
95-70	23384-23391	usually	
95-71	23392-23396	have	
95-72	23397-23398	a	
95-73	23399-23410	correlation	
95-74	23411-23416	close	
95-75	23417-23419	to	
95-76	23420-23421	1	
95-77	23421-23422	.	
95-78	23423-23427	When	
95-79	23428-23431	the	
95-80	23432-23443	correlation	
95-81	23444-23446	is	
95-82	23447-23448	-	
95-83	23448-23449	1	
95-84	23449-23450	,	
95-85	23451-23454	the	
95-86	23455-23460	pages	
95-87	23461-23463	of	
95-88	23464-23467	the	
95-89	23468-23473	table	
95-90	23474-23477	are	
95-91	23478-23484	sorted	
95-92	23485-23487	in	
95-93	23488-23495	reverse	
95-94	23496-23501	order	
95-95	23502-23510	relative	
95-96	23511-23513	to	
95-97	23514-23517	the	
95-98	23518-23524	column	
95-99	23524-23525	.	
95-100	23526-23537	correlation	
95-101	23538-23539	~	
95-102	23540-23541	0	
95-103	23542-23546	When	
95-104	23547-23550	the	
95-105	23551-23562	correlation	
95-106	23563-23565	is	
95-107	23566-23571	close	
95-108	23572-23574	to	
95-109	23575-23576	0	
95-110	23576-23577	,	
95-111	23578-23580	it	
95-112	23581-23585	mean	
95-113	23586-23589	the	
95-114	23590-23596	values	
95-115	23597-23599	in	
95-116	23600-23603	the	
95-117	23604-23610	column	
95-118	23611-23615	have	
95-119	23616-23618	no	
95-120	23619-23621	or	
95-121	23622-23626	very	
95-122	23627-23633	little	
95-123	23634-23645	correlation	
95-124	23646-23648	to	
95-125	23649-23652	how	
95-126	23653-23656	the	
95-127	23657-23662	pages	
95-128	23663-23665	of	
95-129	23666-23669	the	
95-130	23670-23675	table	
95-131	23676-23679	are	
95-132	23680-23686	stored	
95-133	23686-23687	.	

#Text=Going back to our sale_fact table, when we loaded the data into the table without sorting it first, these were the correlations: db=# SELECT tablename, attname, correlation db-# FROM pg_stats db=# WHERE tablename = 'sale_fact'; tablename | attname | correlation
96-1	23688-23693	Going	
96-2	23694-23698	back	
96-3	23699-23701	to	
96-4	23702-23705	our	
96-5	23706-23715	sale_fact	
96-6	23716-23721	table	
96-7	23721-23722	,	
96-8	23723-23727	when	
96-9	23728-23730	we	
96-10	23731-23737	loaded	
96-11	23738-23741	the	
96-12	23742-23746	data	
96-13	23747-23751	into	
96-14	23752-23755	the	
96-15	23756-23761	table	
96-16	23762-23769	without	
96-17	23770-23777	sorting	
96-18	23778-23780	it	
96-19	23781-23786	first	
96-20	23786-23787	,	
96-21	23788-23793	these	
96-22	23794-23798	were	
96-23	23799-23802	the	
96-24	23803-23815	correlations	
96-25	23815-23816	:	
96-26	23817-23819	db	
96-27	23819-23820	=	
96-28	23820-23821	#	
96-29	23822-23828	SELECT	
96-30	23829-23838	tablename	
96-31	23838-23839	,	
96-32	23840-23847	attname	
96-33	23847-23848	,	
96-34	23849-23860	correlation	
96-35	23861-23863	db	
96-36	23863-23864	-	
96-37	23864-23865	#	
96-38	23866-23870	FROM	
96-39	23871-23879	pg_stats	
96-40	23880-23882	db	
96-41	23882-23883	=	
96-42	23883-23884	#	
96-43	23885-23890	WHERE	
96-44	23891-23900	tablename	
96-45	23901-23902	=	
96-46	23903-23904	'	
96-47	23904-23913	sale_fact	
96-48	23913-23914	'	
96-49	23914-23915	;	
96-50	23916-23925	tablename	
96-51	23926-23927	|	
96-52	23928-23935	attname	
96-53	23936-23937	|	
96-54	23938-23949	correlation	

#Text=-----------+----------+-------------- sale | id sale | username | -0.005344716 sale | sold_at | -0.011389783 The auto generated column id has a correlation of 1. The sold_at column has a very low correlation: consecutive values are scattered across the entire table.
97-1	23950-23951	-	
97-2	23951-23952	-	
97-3	23952-23953	-	
97-4	23953-23954	-	
97-5	23954-23955	-	
97-6	23955-23956	-	
97-7	23956-23957	-	
97-8	23957-23958	-	
97-9	23958-23959	-	
97-10	23959-23960	-	
97-11	23960-23961	-	
97-12	23961-23962	+	
97-13	23962-23963	-	
97-14	23963-23964	-	
97-15	23964-23965	-	
97-16	23965-23966	-	
97-17	23966-23967	-	
97-18	23967-23968	-	
97-19	23968-23969	-	
97-20	23969-23970	-	
97-21	23970-23971	-	
97-22	23971-23972	-	
97-23	23972-23973	+	
97-24	23973-23974	-	
97-25	23974-23975	-	
97-26	23975-23976	-	
97-27	23976-23977	-	
97-28	23977-23978	-	
97-29	23978-23979	-	
97-30	23979-23980	-	
97-31	23980-23981	-	
97-32	23981-23982	-	
97-33	23982-23983	-	
97-34	23983-23984	-	
97-35	23984-23985	-	
97-36	23985-23986	-	
97-37	23986-23987	-	
97-38	23988-23992	sale	
97-39	23993-23994	|	
97-40	23995-23997	id	
97-41	23998-24002	sale	
97-42	24003-24004	|	
97-43	24005-24013	username	
97-44	24014-24015	|	
97-45	24016-24017	-	
97-46	24017-24028	0.005344716	
97-47	24029-24033	sale	
97-48	24034-24035	|	
97-49	24036-24043	sold_at	
97-50	24044-24045	|	
97-51	24046-24047	-	
97-52	24047-24058	0.011389783	
97-53	24059-24062	The	
97-54	24063-24067	auto	
97-55	24068-24077	generated	
97-56	24078-24084	column	
97-57	24085-24087	id	
97-58	24088-24091	has	
97-59	24092-24093	a	
97-60	24094-24105	correlation	
97-61	24106-24108	of	
97-62	24109-24110	1	
97-63	24110-24111	.	
97-64	24112-24115	The	
97-65	24116-24123	sold_at	
97-66	24124-24130	column	
97-67	24131-24134	has	
97-68	24135-24136	a	
97-69	24137-24141	very	
97-70	24142-24145	low	
97-71	24146-24157	correlation	
97-72	24157-24158	:	
97-73	24159-24170	consecutive	
97-74	24171-24177	values	
97-75	24178-24181	are	
97-76	24182-24191	scattered	
97-77	24192-24198	across	
97-78	24199-24202	the	
97-79	24203-24209	entire	
97-80	24210-24215	table	
97-81	24215-24216	.	

#Text=When we loaded sorted data into the table, these were the correlations calculated by the database: tablename | attname correlation -----------+----------+---------------- sale_fact | id
98-1	24217-24221	When	
98-2	24222-24224	we	
98-3	24225-24231	loaded	
98-4	24232-24238	sorted	
98-5	24239-24243	data	
98-6	24244-24248	into	
98-7	24249-24252	the	
98-8	24253-24258	table	
98-9	24258-24259	,	
98-10	24260-24265	these	
98-11	24266-24270	were	
98-12	24271-24274	the	
98-13	24275-24287	correlations	
98-14	24288-24298	calculated	
98-15	24299-24301	by	
98-16	24302-24305	the	
98-17	24306-24314	database	
98-18	24314-24315	:	
98-19	24316-24325	tablename	
98-20	24326-24327	|	
98-21	24328-24335	attname	
98-22	24336-24347	correlation	
98-23	24348-24349	-	
98-24	24349-24350	-	
98-25	24350-24351	-	
98-26	24351-24352	-	
98-27	24352-24353	-	
98-28	24353-24354	-	
98-29	24354-24355	-	
98-30	24355-24356	-	
98-31	24356-24357	-	
98-32	24357-24358	-	
98-33	24358-24359	-	
98-34	24359-24360	+	
98-35	24360-24361	-	
98-36	24361-24362	-	
98-37	24362-24363	-	
98-38	24363-24364	-	
98-39	24364-24365	-	
98-40	24365-24366	-	
98-41	24366-24367	-	
98-42	24367-24368	-	
98-43	24368-24369	-	
98-44	24369-24370	-	
98-45	24370-24371	+	
98-46	24371-24372	-	
98-47	24372-24373	-	
98-48	24373-24374	-	
98-49	24374-24375	-	
98-50	24375-24376	-	
98-51	24376-24377	-	
98-52	24377-24378	-	
98-53	24378-24379	-	
98-54	24379-24380	-	
98-55	24380-24381	-	
98-56	24381-24382	-	
98-57	24382-24383	-	
98-58	24383-24384	-	
98-59	24384-24385	-	
98-60	24385-24386	-	
98-61	24386-24387	-	
98-62	24388-24397	sale_fact	
98-63	24398-24399	|	
98-64	24400-24402	id	

#Text=sale_fact | username | -0.00041992788 sale_fact | sold_at The correlation for sold_at is now 1. So why did the database use a bitmap scan when the correlation was low, and an index scan when the correlation was close to 1?
99-1	24403-24412	sale_fact	
99-2	24413-24414	|	
99-3	24415-24423	username	
99-4	24424-24425	|	
99-5	24426-24427	-	
99-6	24427-24440	0.00041992788	
99-7	24441-24450	sale_fact	
99-8	24451-24452	|	
99-9	24453-24460	sold_at	
99-10	24461-24464	The	
99-11	24465-24476	correlation	
99-12	24477-24480	for	
99-13	24481-24488	sold_at	
99-14	24489-24491	is	
99-15	24492-24495	now	
99-16	24496-24497	1	
99-17	24497-24498	.	
99-18	24499-24501	So	
99-19	24502-24505	why	
99-20	24506-24509	did	
99-21	24510-24513	the	
99-22	24514-24522	database	
99-23	24523-24526	use	
99-24	24527-24528	a	
99-25	24529-24535	bitmap	
99-26	24536-24540	scan	
99-27	24541-24545	when	
99-28	24546-24549	the	
99-29	24550-24561	correlation	
99-30	24562-24565	was	
99-31	24566-24569	low	
99-32	24569-24570	,	
99-33	24571-24574	and	
99-34	24575-24577	an	
99-35	24578-24583	index	
99-36	24584-24588	scan	
99-37	24589-24593	when	
99-38	24594-24597	the	
99-39	24598-24609	correlation	
99-40	24610-24613	was	
99-41	24614-24619	close	
99-42	24620-24622	to	
99-43	24623-24624	1	
99-44	24624-24625	?	

#Text=When the correlation was 1, the database estimated that rows in the requested range are likely to be in consecutive pages. In this case, an index scan is likely to read very few pages. When the correlation was close to 0, the database estimated that rows in the requested range are likely to be scattered across the entire table. In this case, it makes sense to use a bitmap scan to map the table pages in which rows exist, and only then fetch them and apply the condition.
100-1	24626-24630	When	
100-2	24631-24634	the	
100-3	24635-24646	correlation	
100-4	24647-24650	was	
100-5	24651-24652	1	
100-6	24652-24653	,	
100-7	24654-24657	the	
100-8	24658-24666	database	
100-9	24667-24676	estimated	
100-10	24677-24681	that	
100-11	24682-24686	rows	
100-12	24687-24689	in	
100-13	24690-24693	the	
100-14	24694-24703	requested	
100-15	24704-24709	range	
100-16	24710-24713	are	
100-17	24714-24720	likely	
100-18	24721-24723	to	
100-19	24724-24726	be	
100-20	24727-24729	in	
100-21	24730-24741	consecutive	
100-22	24742-24747	pages	
100-23	24747-24748	.	
100-24	24749-24751	In	
100-25	24752-24756	this	
100-26	24757-24761	case	
100-27	24761-24762	,	
100-28	24763-24765	an	
100-29	24766-24771	index	
100-30	24772-24776	scan	
100-31	24777-24779	is	
100-32	24780-24786	likely	
100-33	24787-24789	to	
100-34	24790-24794	read	
100-35	24795-24799	very	
100-36	24800-24803	few	
100-37	24804-24809	pages	
100-38	24809-24810	.	
100-39	24811-24815	When	
100-40	24816-24819	the	
100-41	24820-24831	correlation	
100-42	24832-24835	was	
100-43	24836-24841	close	
100-44	24842-24844	to	
100-45	24845-24846	0	
100-46	24846-24847	,	
100-47	24848-24851	the	
100-48	24852-24860	database	
100-49	24861-24870	estimated	
100-50	24871-24875	that	
100-51	24876-24880	rows	
100-52	24881-24883	in	
100-53	24884-24887	the	
100-54	24888-24897	requested	
100-55	24898-24903	range	
100-56	24904-24907	are	
100-57	24908-24914	likely	
100-58	24915-24917	to	
100-59	24918-24920	be	
100-60	24921-24930	scattered	
100-61	24931-24937	across	
100-62	24938-24941	the	
100-63	24942-24948	entire	
100-64	24949-24954	table	
100-65	24954-24955	.	
100-66	24956-24958	In	
100-67	24959-24963	this	
100-68	24964-24968	case	
100-69	24968-24969	,	
100-70	24970-24972	it	
100-71	24973-24978	makes	
100-72	24979-24984	sense	
100-73	24985-24987	to	
100-74	24988-24991	use	
100-75	24992-24993	a	
100-76	24994-25000	bitmap	
100-77	25001-25005	scan	
100-78	25006-25008	to	
100-79	25009-25012	map	
100-80	25013-25016	the	
100-81	25017-25022	table	
100-82	25023-25028	pages	
100-83	25029-25031	in	
100-84	25032-25037	which	
100-85	25038-25042	rows	
100-86	25043-25048	exist	
100-87	25048-25049	,	
100-88	25050-25053	and	
100-89	25054-25058	only	
100-90	25059-25063	then	
100-91	25064-25069	fetch	
100-92	25070-25074	them	
100-93	25075-25078	and	
100-94	25079-25084	apply	
100-95	25085-25088	the	
100-96	25089-25098	condition	
100-97	25098-25099	.	

#Text=The next time you load data into a table, think about how the data is going to be queried, and make sure you sort it in a way that indexes used for range scan can benefit from. CLUSTER Command Another way of "sorting a table on disk" by a specific index is to use the CLUSTER command. For example: db=# TRUNCATE sale_fact; TRUNCATE TABLE
101-1	25100-25103	The	
101-2	25104-25108	next	
101-3	25109-25113	time	
101-4	25114-25117	you	
101-5	25118-25122	load	
101-6	25123-25127	data	
101-7	25128-25132	into	
101-8	25133-25134	a	
101-9	25135-25140	table	
101-10	25140-25141	,	
101-11	25142-25147	think	
101-12	25148-25153	about	
101-13	25154-25157	how	
101-14	25158-25161	the	
101-15	25162-25166	data	
101-16	25167-25169	is	
101-17	25170-25175	going	
101-18	25176-25178	to	
101-19	25179-25181	be	
101-20	25182-25189	queried	
101-21	25189-25190	,	
101-22	25191-25194	and	
101-23	25195-25199	make	
101-24	25200-25204	sure	
101-25	25205-25208	you	
101-26	25209-25213	sort	
101-27	25214-25216	it	
101-28	25217-25219	in	
101-29	25220-25221	a	
101-30	25222-25225	way	
101-31	25226-25230	that	
101-32	25231-25238	indexes	
101-33	25239-25243	used	
101-34	25244-25247	for	
101-35	25248-25253	range	
101-36	25254-25258	scan	
101-37	25259-25262	can	
101-38	25263-25270	benefit	
101-39	25271-25275	from	
101-40	25275-25276	.	
101-41	25277-25284	CLUSTER	
101-42	25285-25292	Command	
101-43	25293-25300	Another	
101-44	25301-25304	way	
101-45	25305-25307	of	
101-46	25308-25309	"	
101-47	25309-25316	sorting	
101-48	25317-25318	a	
101-49	25319-25324	table	
101-50	25325-25327	on	
101-51	25328-25332	disk	
101-52	25332-25333	"	
101-53	25334-25336	by	
101-54	25337-25338	a	
101-55	25339-25347	specific	
101-56	25348-25353	index	
101-57	25354-25356	is	
101-58	25357-25359	to	
101-59	25360-25363	use	
101-60	25364-25367	the	
101-61	25368-25375	CLUSTER	
101-62	25376-25383	command	
101-63	25383-25384	.	
101-64	25385-25388	For	
101-65	25389-25396	example	
101-66	25396-25397	:	
101-67	25398-25400	db	
101-68	25400-25401	=	
101-69	25401-25402	#	
101-70	25403-25411	TRUNCATE	
101-71	25412-25421	sale_fact	
101-72	25421-25422	;	
101-73	25423-25431	TRUNCATE	
101-74	25432-25437	TABLE	

#Text=-- Insert rows without sorting db=# INSERT INTO sale_fact (username, sold_at) db-# SELECT db-# md5(random()::text) AS username, db-#
102-1	25438-25439	-	
102-2	25439-25440	-	
102-3	25441-25447	Insert	
102-4	25448-25452	rows	
102-5	25453-25460	without	
102-6	25461-25468	sorting	
102-7	25469-25471	db	
102-8	25471-25472	=	
102-9	25472-25473	#	
102-10	25474-25480	INSERT	
102-11	25481-25485	INTO	
102-12	25486-25495	sale_fact	
102-13	25496-25497	(	
102-14	25497-25505	username	
102-15	25505-25506	,	
102-16	25507-25514	sold_at	
102-17	25514-25515	)	
102-18	25516-25518	db	
102-19	25518-25519	-	
102-20	25519-25520	#	
102-21	25521-25527	SELECT	
102-22	25528-25530	db	
102-23	25530-25531	-	
102-24	25531-25532	#	
102-25	25533-25536	md5	
102-26	25536-25537	(	
102-27	25537-25543	random	
102-28	25543-25544	(	
102-29	25544-25545	)	
102-30	25545-25546	:	
102-31	25546-25547	:	
102-32	25547-25551	text	
102-33	25551-25552	)	
102-34	25553-25555	AS	
102-35	25556-25564	username	
102-36	25564-25565	,	
102-37	25566-25568	db	
102-38	25568-25569	-	
102-39	25569-25570	#	

#Text='2020-01-01'::date + (interval '1 day') * round(random() * 365 * 2) AS sold_at db-# FROM db-# generate_series(1, 100000) INSERT 0 100000 db=# ANALYZE sale_fact; ANALYZE
103-1	25571-25572	'	
103-2	25572-25576	2020	
103-3	25576-25577	-	
103-4	25577-25579	01	
103-5	25579-25580	-	
103-6	25580-25582	01	
103-7	25582-25583	'	
103-8	25583-25584	:	
103-9	25584-25585	:	
103-10	25585-25589	date	
103-11	25590-25591	+	
103-12	25592-25593	(	
103-13	25593-25601	interval	
103-14	25602-25603	'	
103-15	25603-25604	1	
103-16	25605-25608	day	
103-17	25608-25609	'	
103-18	25609-25610	)	
103-19	25611-25612	*	
103-20	25613-25618	round	
103-21	25618-25619	(	
103-22	25619-25625	random	
103-23	25625-25626	(	
103-24	25626-25627	)	
103-25	25628-25629	*	
103-26	25630-25633	365	
103-27	25634-25635	*	
103-28	25636-25637	2	
103-29	25637-25638	)	
103-30	25639-25641	AS	
103-31	25642-25649	sold_at	
103-32	25650-25652	db	
103-33	25652-25653	-	
103-34	25653-25654	#	
103-35	25655-25659	FROM	
103-36	25660-25662	db	
103-37	25662-25663	-	
103-38	25663-25664	#	
103-39	25665-25680	generate_series	
103-40	25680-25681	(	
103-41	25681-25682	1	
103-42	25682-25683	,	
103-43	25684-25690	100000	
103-44	25690-25691	)	
103-45	25692-25698	INSERT	
103-46	25699-25700	0	
103-47	25701-25707	100000	
103-48	25708-25710	db	
103-49	25710-25711	=	
103-50	25711-25712	#	
103-51	25713-25720	ANALYZE	
103-52	25721-25730	sale_fact	
103-53	25730-25731	;	
103-54	25732-25739	ANALYZE	

#Text=db=# SELECT tablename, attname, correlation db-# FROM pg_stats db-# WHERE tablename = 'sale_fact'; tablename | attname correlation
104-1	25740-25742	db	
104-2	25742-25743	=	
104-3	25743-25744	#	
104-4	25745-25751	SELECT	
104-5	25752-25761	tablename	
104-6	25761-25762	,	
104-7	25763-25770	attname	
104-8	25770-25771	,	
104-9	25772-25783	correlation	
104-10	25784-25786	db	
104-11	25786-25787	-	
104-12	25787-25788	#	
104-13	25789-25793	FROM	
104-14	25794-25802	pg_stats	
104-15	25803-25805	db	
104-16	25805-25806	-	
104-17	25806-25807	#	
104-18	25808-25813	WHERE	
104-19	25814-25823	tablename	
104-20	25824-25825	=	
104-21	25826-25827	'	
104-22	25827-25836	sale_fact	
104-23	25836-25837	'	
104-24	25837-25838	;	
104-25	25839-25848	tablename	
104-26	25849-25850	|	
104-27	25851-25858	attname	
104-28	25859-25870	correlation	

#Text=-----------+-----------+---------------- sale_fact | sold_at | -5.9702674e-05 sale_fact | id sale_fact | username 0.010033822 We loaded data into the table in random order and as a result the correlation of sold_at is close to zero.
105-1	25871-25872	-	
105-2	25872-25873	-	
105-3	25873-25874	-	
105-4	25874-25875	-	
105-5	25875-25876	-	
105-6	25876-25877	-	
105-7	25877-25878	-	
105-8	25878-25879	-	
105-9	25879-25880	-	
105-10	25880-25881	-	
105-11	25881-25882	-	
105-12	25882-25883	+	
105-13	25883-25884	-	
105-14	25884-25885	-	
105-15	25885-25886	-	
105-16	25886-25887	-	
105-17	25887-25888	-	
105-18	25888-25889	-	
105-19	25889-25890	-	
105-20	25890-25891	-	
105-21	25891-25892	-	
105-22	25892-25893	-	
105-23	25893-25894	-	
105-24	25894-25895	+	
105-25	25895-25896	-	
105-26	25896-25897	-	
105-27	25897-25898	-	
105-28	25898-25899	-	
105-29	25899-25900	-	
105-30	25900-25901	-	
105-31	25901-25902	-	
105-32	25902-25903	-	
105-33	25903-25904	-	
105-34	25904-25905	-	
105-35	25905-25906	-	
105-36	25906-25907	-	
105-37	25907-25908	-	
105-38	25908-25909	-	
105-39	25909-25910	-	
105-40	25910-25911	-	
105-41	25912-25921	sale_fact	
105-42	25922-25923	|	
105-43	25924-25931	sold_at	
105-44	25932-25933	|	
105-45	25934-25935	-	
105-46	25935-25945	5.9702674e	
105-47	25945-25946	-	
105-48	25946-25948	05	
105-49	25949-25958	sale_fact	
105-50	25959-25960	|	
105-51	25961-25963	id	
105-52	25964-25973	sale_fact	
105-53	25974-25975	|	
105-54	25976-25984	username	
105-55	25985-25996	0.010033822	
105-56	25997-25999	We	
105-57	26000-26006	loaded	
105-58	26007-26011	data	
105-59	26012-26016	into	
105-60	26017-26020	the	
105-61	26021-26026	table	
105-62	26027-26029	in	
105-63	26030-26036	random	
105-64	26037-26042	order	
105-65	26043-26046	and	
105-66	26047-26049	as	
105-67	26050-26051	a	
105-68	26052-26058	result	
105-69	26059-26062	the	
105-70	26063-26074	correlation	
105-71	26075-26077	of	
105-72	26078-26085	sold_at	
105-73	26086-26088	is	
105-74	26089-26094	close	
105-75	26095-26097	to	
105-76	26098-26102	zero	
105-77	26102-26103	.	

#Text=To "rearrange" the table by sold_at, we used the CLUSTER command to sort the table on disk according to the index sale_fact_sold_at_ix: db=# CLUSTER sale_fact USING sale_fact_sold_at_ix; CLUSTER db=# ANALYZE sale_fact; ANALYZE
106-1	26104-26106	To	
106-2	26107-26108	"	
106-3	26108-26117	rearrange	
106-4	26117-26118	"	
106-5	26119-26122	the	
106-6	26123-26128	table	
106-7	26129-26131	by	
106-8	26132-26139	sold_at	
106-9	26139-26140	,	
106-10	26141-26143	we	
106-11	26144-26148	used	
106-12	26149-26152	the	
106-13	26153-26160	CLUSTER	
106-14	26161-26168	command	
106-15	26169-26171	to	
106-16	26172-26176	sort	
106-17	26177-26180	the	
106-18	26181-26186	table	
106-19	26187-26189	on	
106-20	26190-26194	disk	
106-21	26195-26204	according	
106-22	26205-26207	to	
106-23	26208-26211	the	
106-24	26212-26217	index	
106-25	26218-26238	sale_fact_sold_at_ix	
106-26	26238-26239	:	
106-27	26240-26242	db	
106-28	26242-26243	=	
106-29	26243-26244	#	
106-30	26245-26252	CLUSTER	
106-31	26253-26262	sale_fact	
106-32	26263-26268	USING	
106-33	26269-26289	sale_fact_sold_at_ix	
106-34	26289-26290	;	
106-35	26291-26298	CLUSTER	
106-36	26299-26301	db	
106-37	26301-26302	=	
106-38	26302-26303	#	
106-39	26304-26311	ANALYZE	
106-40	26312-26321	sale_fact	
106-41	26321-26322	;	
106-42	26323-26330	ANALYZE	

#Text=db=# SELECT tablename, attname, correlation db-# FROM pg_stats db-# WHERE tablename = 'sale_fact'; tablename | attname | correlation
107-1	26331-26333	db	
107-2	26333-26334	=	
107-3	26334-26335	#	
107-4	26336-26342	SELECT	
107-5	26343-26352	tablename	
107-6	26352-26353	,	
107-7	26354-26361	attname	
107-8	26361-26362	,	
107-9	26363-26374	correlation	
107-10	26375-26377	db	
107-11	26377-26378	-	
107-12	26378-26379	#	
107-13	26380-26384	FROM	
107-14	26385-26393	pg_stats	
107-15	26394-26396	db	
107-16	26396-26397	-	
107-17	26397-26398	#	
107-18	26399-26404	WHERE	
107-19	26405-26414	tablename	
107-20	26415-26416	=	
107-21	26417-26418	'	
107-22	26418-26427	sale_fact	
107-23	26427-26428	'	
107-24	26428-26429	;	
107-25	26430-26439	tablename	
107-26	26440-26441	|	
107-27	26442-26449	attname	
107-28	26450-26451	|	
107-29	26452-26463	correlation	

#Text=-----------+----------+-------------- sale_fact | sold_at sale_fact | id | -0.002239401 sale_fact | username | 0.013389298 After the table was clustered we can see that the correlation for sold_at is 1.
108-1	26464-26465	-	
108-2	26465-26466	-	
108-3	26466-26467	-	
108-4	26467-26468	-	
108-5	26468-26469	-	
108-6	26469-26470	-	
108-7	26470-26471	-	
108-8	26471-26472	-	
108-9	26472-26473	-	
108-10	26473-26474	-	
108-11	26474-26475	-	
108-12	26475-26476	+	
108-13	26476-26477	-	
108-14	26477-26478	-	
108-15	26478-26479	-	
108-16	26479-26480	-	
108-17	26480-26481	-	
108-18	26481-26482	-	
108-19	26482-26483	-	
108-20	26483-26484	-	
108-21	26484-26485	-	
108-22	26485-26486	-	
108-23	26486-26487	+	
108-24	26487-26488	-	
108-25	26488-26489	-	
108-26	26489-26490	-	
108-27	26490-26491	-	
108-28	26491-26492	-	
108-29	26492-26493	-	
108-30	26493-26494	-	
108-31	26494-26495	-	
108-32	26495-26496	-	
108-33	26496-26497	-	
108-34	26497-26498	-	
108-35	26498-26499	-	
108-36	26499-26500	-	
108-37	26500-26501	-	
108-38	26502-26511	sale_fact	
108-39	26512-26513	|	
108-40	26514-26521	sold_at	
108-41	26522-26531	sale_fact	
108-42	26532-26533	|	
108-43	26534-26536	id	
108-44	26537-26538	|	
108-45	26539-26540	-	
108-46	26540-26551	0.002239401	
108-47	26552-26561	sale_fact	
108-48	26562-26563	|	
108-49	26564-26572	username	
108-50	26573-26574	|	
108-51	26575-26586	0.013389298	
108-52	26587-26592	After	
108-53	26593-26596	the	
108-54	26597-26602	table	
108-55	26603-26606	was	
108-56	26607-26616	clustered	
108-57	26617-26619	we	
108-58	26620-26623	can	
108-59	26624-26627	see	
108-60	26628-26632	that	
108-61	26633-26636	the	
108-62	26637-26648	correlation	
108-63	26649-26652	for	
108-64	26653-26660	sold_at	
108-65	26661-26663	is	
108-66	26664-26665	1	
108-67	26665-26666	.	

#Text=CLUSTER command Some things to note about the CLUSTER command: Clustering the table by a specific column may affect the correlation of other column. See for example the correlation of the column id after we clustered the table by sold_at.
109-1	26667-26674	CLUSTER	
109-2	26675-26682	command	
109-3	26683-26687	Some	
109-4	26688-26694	things	
109-5	26695-26697	to	
109-6	26698-26702	note	
109-7	26703-26708	about	
109-8	26709-26712	the	
109-9	26713-26720	CLUSTER	
109-10	26721-26728	command	
109-11	26728-26729	:	
109-12	26730-26740	Clustering	
109-13	26741-26744	the	
109-14	26745-26750	table	
109-15	26751-26753	by	
109-16	26754-26755	a	
109-17	26756-26764	specific	
109-18	26765-26771	column	
109-19	26772-26775	may	
109-20	26776-26782	affect	
109-21	26783-26786	the	
109-22	26787-26798	correlation	
109-23	26799-26801	of	
109-24	26802-26807	other	
109-25	26808-26814	column	
109-26	26814-26815	.	
109-27	26816-26819	See	
109-28	26820-26823	for	
109-29	26824-26831	example	
109-30	26832-26835	the	
109-31	26836-26847	correlation	
109-32	26848-26850	of	
109-33	26851-26854	the	
109-34	26855-26861	column	
109-35	26862-26864	id	
109-36	26865-26870	after	
109-37	26871-26873	we	
109-38	26874-26883	clustered	
109-39	26884-26887	the	
109-40	26888-26893	table	
109-41	26894-26896	by	
109-42	26897-26904	sold_at	
109-43	26904-26905	.	

#Text=CLUSTER is a heavy, blocking operation, so make sure you don't execute it on a live table. For these two reason it's best to insert the data sorted and not rely on CLUSTER. Index Columns With High Correlation Using BRIN When talking about indexes, most developers will think about B-Tree indexes. But, PostgreSQL provides other types of indexes such as BRIN:
110-1	26906-26913	CLUSTER	
110-2	26914-26916	is	
110-3	26917-26918	a	
110-4	26919-26924	heavy	
110-5	26924-26925	,	
110-6	26926-26934	blocking	
110-7	26935-26944	operation	
110-8	26944-26945	,	
110-9	26946-26948	so	
110-10	26949-26953	make	
110-11	26954-26958	sure	
110-12	26959-26962	you	
110-13	26963-26968	don't	
110-14	26969-26976	execute	
110-15	26977-26979	it	
110-16	26980-26982	on	
110-17	26983-26984	a	
110-18	26985-26989	live	
110-19	26990-26995	table	
110-20	26995-26996	.	
110-21	26997-27000	For	
110-22	27001-27006	these	
110-23	27007-27010	two	
110-24	27011-27017	reason	
110-25	27018-27022	it's	
110-26	27023-27027	best	
110-27	27028-27030	to	
110-28	27031-27037	insert	
110-29	27038-27041	the	
110-30	27042-27046	data	
110-31	27047-27053	sorted	
110-32	27054-27057	and	
110-33	27058-27061	not	
110-34	27062-27066	rely	
110-35	27067-27069	on	
110-36	27070-27077	CLUSTER	
110-37	27077-27078	.	
110-38	27079-27084	Index	
110-39	27085-27092	Columns	
110-40	27093-27097	With	
110-41	27098-27102	High	
110-42	27103-27114	Correlation	
110-43	27115-27120	Using	
110-44	27121-27125	BRIN	
110-45	27126-27130	When	
110-46	27131-27138	talking	
110-47	27139-27144	about	
110-48	27145-27152	indexes	
110-49	27152-27153	,	
110-50	27154-27158	most	
110-51	27159-27169	developers	
110-52	27170-27174	will	
110-53	27175-27180	think	
110-54	27181-27186	about	
110-55	27187-27193	B-Tree	
110-56	27194-27201	indexes	
110-57	27201-27202	.	
110-58	27203-27206	But	
110-59	27206-27207	,	
110-60	27208-27218	PostgreSQL	
110-61	27219-27227	provides	
110-62	27228-27233	other	
110-63	27234-27239	types	
110-64	27240-27242	of	
110-65	27243-27250	indexes	
110-66	27251-27255	such	
110-67	27256-27258	as	
110-68	27259-27263	BRIN	
110-69	27263-27264	:	

#Text=BRIN is designed for handling very large tables in which certain columns have some natural correlation with their physical location within the table BRIN stands for Block Range Index. According to the documentation, a BRIN index works best for columns with high correlation. As we've already seen in previous sections, some fields such as auto incrementing IDs and timestamps are naturally correlated with the physical structure of the table, hence they are good candidates for a BRIN index.
111-1	27265-27269	BRIN	
111-2	27270-27272	is	
111-3	27273-27281	designed	
111-4	27282-27285	for	
111-5	27286-27294	handling	
111-6	27295-27299	very	
111-7	27300-27305	large	
111-8	27306-27312	tables	
111-9	27313-27315	in	
111-10	27316-27321	which	
111-11	27322-27329	certain	
111-12	27330-27337	columns	
111-13	27338-27342	have	
111-14	27343-27347	some	
111-15	27348-27355	natural	
111-16	27356-27367	correlation	
111-17	27368-27372	with	
111-18	27373-27378	their	
111-19	27379-27387	physical	
111-20	27388-27396	location	
111-21	27397-27403	within	
111-22	27404-27407	the	
111-23	27408-27413	table	
111-24	27414-27418	BRIN	
111-25	27419-27425	stands	
111-26	27426-27429	for	
111-27	27430-27435	Block	
111-28	27436-27441	Range	
111-29	27442-27447	Index	
111-30	27447-27448	.	
111-31	27449-27458	According	
111-32	27459-27461	to	
111-33	27462-27465	the	
111-34	27466-27479	documentation	
111-35	27479-27480	,	
111-36	27481-27482	a	
111-37	27483-27487	BRIN	
111-38	27488-27493	index	
111-39	27494-27499	works	
111-40	27500-27504	best	
111-41	27505-27508	for	
111-42	27509-27516	columns	
111-43	27517-27521	with	
111-44	27522-27526	high	
111-45	27527-27538	correlation	
111-46	27538-27539	.	
111-47	27540-27542	As	
111-48	27543-27548	we've	
111-49	27549-27556	already	
111-50	27557-27561	seen	
111-51	27562-27564	in	
111-52	27565-27573	previous	
111-53	27574-27582	sections	
111-54	27582-27583	,	
111-55	27584-27588	some	
111-56	27589-27595	fields	
111-57	27596-27600	such	
111-58	27601-27603	as	
111-59	27604-27608	auto	
111-60	27609-27621	incrementing	
111-61	27622-27625	IDs	
111-62	27626-27629	and	
111-63	27630-27640	timestamps	
111-64	27641-27644	are	
111-65	27645-27654	naturally	
111-66	27655-27665	correlated	
111-67	27666-27670	with	
111-68	27671-27674	the	
111-69	27675-27683	physical	
111-70	27684-27693	structure	
111-71	27694-27696	of	
111-72	27697-27700	the	
111-73	27701-27706	table	
111-74	27706-27707	,	
111-75	27708-27713	hence	
111-76	27714-27718	they	
111-77	27719-27722	are	
111-78	27723-27727	good	
111-79	27728-27738	candidates	
111-80	27739-27742	for	
111-81	27743-27744	a	
111-82	27745-27749	BRIN	
111-83	27750-27755	index	
111-84	27755-27756	.	

#Text=Under some circumstances, a BRIN index can provide a better "value for money" in terms of size and performance compared to a similar B-Tree index. BRIN Index A BRIN index works by keeping the range of values within a number of adjacent pages in the table. Say we have these values in a column, each is single table page: 1, 2, 3, 4, 5, 6, 7, 8, 9
112-1	27757-27762	Under	
112-2	27763-27767	some	
112-3	27768-27781	circumstances	
112-4	27781-27782	,	
112-5	27783-27784	a	
112-6	27785-27789	BRIN	
112-7	27790-27795	index	
112-8	27796-27799	can	
112-9	27800-27807	provide	
112-10	27808-27809	a	
112-11	27810-27816	better	
112-12	27817-27818	"	
112-13	27818-27823	value	
112-14	27824-27827	for	
112-15	27828-27833	money	
112-16	27833-27834	"	
112-17	27835-27837	in	
112-18	27838-27843	terms	
112-19	27844-27846	of	
112-20	27847-27851	size	
112-21	27852-27855	and	
112-22	27856-27867	performance	
112-23	27868-27876	compared	
112-24	27877-27879	to	
112-25	27880-27881	a	
112-26	27882-27889	similar	
112-27	27890-27896	B-Tree	
112-28	27897-27902	index	
112-29	27902-27903	.	
112-30	27904-27908	BRIN	
112-31	27909-27914	Index	
112-32	27915-27916	A	
112-33	27917-27921	BRIN	
112-34	27922-27927	index	
112-35	27928-27933	works	
112-36	27934-27936	by	
112-37	27937-27944	keeping	
112-38	27945-27948	the	
112-39	27949-27954	range	
112-40	27955-27957	of	
112-41	27958-27964	values	
112-42	27965-27971	within	
112-43	27972-27973	a	
112-44	27974-27980	number	
112-45	27981-27983	of	
112-46	27984-27992	adjacent	
112-47	27993-27998	pages	
112-48	27999-28001	in	
112-49	28002-28005	the	
112-50	28006-28011	table	
112-51	28011-28012	.	
112-52	28013-28016	Say	
112-53	28017-28019	we	
112-54	28020-28024	have	
112-55	28025-28030	these	
112-56	28031-28037	values	
112-57	28038-28040	in	
112-58	28041-28042	a	
112-59	28043-28049	column	
112-60	28049-28050	,	
112-61	28051-28055	each	
112-62	28056-28058	is	
112-63	28059-28065	single	
112-64	28066-28071	table	
112-65	28072-28076	page	
112-66	28076-28077	:	
112-67	28078-28079	1	
112-68	28079-28080	,	
112-69	28081-28082	2	
112-70	28082-28083	,	
112-71	28084-28085	3	
112-72	28085-28086	,	
112-73	28087-28088	4	
112-74	28088-28089	,	
112-75	28090-28091	5	
112-76	28091-28092	,	
112-77	28093-28094	6	
112-78	28094-28095	,	
112-79	28096-28097	7	
112-80	28097-28098	,	
112-81	28099-28100	8	
112-82	28100-28101	,	
112-83	28102-28103	9	

#Text=A BRIN index works on ranges of adjacent pages in the table. If the number of adjacent pages is set to 3, the index will divide the table into the following ranges: [1,2,3], [4,5,6], [7,8,9] For each range, the BRIN index keeps the minimum and maximum value: [13], [46], [79]
113-1	28104-28105	A	
113-2	28106-28110	BRIN	
113-3	28111-28116	index	
113-4	28117-28122	works	
113-5	28123-28125	on	
113-6	28126-28132	ranges	
113-7	28133-28135	of	
113-8	28136-28144	adjacent	
113-9	28145-28150	pages	
113-10	28151-28153	in	
113-11	28154-28157	the	
113-12	28158-28163	table	
113-13	28163-28164	.	
113-14	28165-28167	If	
113-15	28168-28171	the	
113-16	28172-28178	number	
113-17	28179-28181	of	
113-18	28182-28190	adjacent	
113-19	28191-28196	pages	
113-20	28197-28199	is	
113-21	28200-28203	set	
113-22	28204-28206	to	
113-23	28207-28208	3	
113-24	28208-28209	,	
113-25	28210-28213	the	
113-26	28214-28219	index	
113-27	28220-28224	will	
113-28	28225-28231	divide	
113-29	28232-28235	the	
113-30	28236-28241	table	
113-31	28242-28246	into	
113-32	28247-28250	the	
113-33	28251-28260	following	
113-34	28261-28267	ranges	
113-35	28267-28268	:	
113-36	28269-28270	[	
113-37	28270-28275	1,2,3	
113-38	28275-28276	]	
113-39	28276-28277	,	
113-40	28278-28279	[	
113-41	28279-28284	4,5,6	
113-42	28284-28285	]	
113-43	28285-28286	,	
113-44	28287-28288	[	
113-45	28288-28293	7,8,9	
113-46	28293-28294	]	
113-47	28295-28298	For	
113-48	28299-28303	each	
113-49	28304-28309	range	
113-50	28309-28310	,	
113-51	28311-28314	the	
113-52	28315-28319	BRIN	
113-53	28320-28325	index	
113-54	28326-28331	keeps	
113-55	28332-28335	the	
113-56	28336-28343	minimum	
113-57	28344-28347	and	
113-58	28348-28355	maximum	
113-59	28356-28361	value	
113-60	28361-28362	:	
113-61	28363-28364	[	
113-62	28364-28365	1	
113-63	28365-28366		
113-64	28366-28367	3	
113-65	28367-28368	]	
113-66	28368-28369	,	
113-67	28370-28371	[	
113-68	28371-28372	4	
113-69	28372-28373		
113-70	28373-28374	6	
113-71	28374-28375	]	
113-72	28375-28376	,	
113-73	28377-28378	[	
113-74	28378-28379	7	
113-75	28379-28380		
113-76	28380-28381	9	
113-77	28381-28382	]	

#Text=Using the index above, try to search for the value 5: [13] - Definitely not here [46] - Might be here [79] - Definitely not here Using the BRIN index we managed to limit our search to blocks 46.
114-1	28383-28388	Using	
114-2	28389-28392	the	
114-3	28393-28398	index	
114-4	28399-28404	above	
114-5	28404-28405	,	
114-6	28406-28409	try	
114-7	28410-28412	to	
114-8	28413-28419	search	
114-9	28420-28423	for	
114-10	28424-28427	the	
114-11	28428-28433	value	
114-12	28434-28435	5	
114-13	28435-28436	:	
114-14	28437-28438	[	
114-15	28438-28439	1	
114-16	28439-28440		
114-17	28440-28441	3	
114-18	28441-28442	]	
114-19	28443-28444	-	
114-20	28445-28455	Definitely	
114-21	28456-28459	not	
114-22	28460-28464	here	
114-23	28465-28466	[	
114-24	28466-28467	4	
114-25	28467-28468		
114-26	28468-28469	6	
114-27	28469-28470	]	
114-28	28471-28472	-	
114-29	28473-28478	Might	
114-30	28479-28481	be	
114-31	28482-28486	here	
114-32	28487-28488	[	
114-33	28488-28489	7	
114-34	28489-28490		
114-35	28490-28491	9	
114-36	28491-28492	]	
114-37	28493-28494	-	
114-38	28495-28505	Definitely	
114-39	28506-28509	not	
114-40	28510-28514	here	
114-41	28515-28520	Using	
114-42	28521-28524	the	
114-43	28525-28529	BRIN	
114-44	28530-28535	index	
114-45	28536-28538	we	
114-46	28539-28546	managed	
114-47	28547-28549	to	
114-48	28550-28555	limit	
114-49	28556-28559	our	
114-50	28560-28566	search	
114-51	28567-28569	to	
114-52	28570-28576	blocks	
114-53	28577-28578	4	
114-54	28578-28579		
114-55	28579-28580	6	
114-56	28580-28581	.	

#Text=Let's take another example, this time the values in the column will have a correlation close to zero, meaning they are not sorted: [2,9,5], [1,4,7], [3,8,6] Indexing 3 adjacent blocks produces the following ranges: [29], [17], [38] Let's try to search for the value 5:
115-1	28582-28587	Let's	
115-2	28588-28592	take	
115-3	28593-28600	another	
115-4	28601-28608	example	
115-5	28608-28609	,	
115-6	28610-28614	this	
115-7	28615-28619	time	
115-8	28620-28623	the	
115-9	28624-28630	values	
115-10	28631-28633	in	
115-11	28634-28637	the	
115-12	28638-28644	column	
115-13	28645-28649	will	
115-14	28650-28654	have	
115-15	28655-28656	a	
115-16	28657-28668	correlation	
115-17	28669-28674	close	
115-18	28675-28677	to	
115-19	28678-28682	zero	
115-20	28682-28683	,	
115-21	28684-28691	meaning	
115-22	28692-28696	they	
115-23	28697-28700	are	
115-24	28701-28704	not	
115-25	28705-28711	sorted	
115-26	28711-28712	:	
115-27	28713-28714	[	
115-28	28714-28719	2,9,5	
115-29	28719-28720	]	
115-30	28720-28721	,	
115-31	28722-28723	[	
115-32	28723-28728	1,4,7	
115-33	28728-28729	]	
115-34	28729-28730	,	
115-35	28731-28732	[	
115-36	28732-28737	3,8,6	
115-37	28737-28738	]	
115-38	28739-28747	Indexing	
115-39	28748-28749	3	
115-40	28750-28758	adjacent	
115-41	28759-28765	blocks	
115-42	28766-28774	produces	
115-43	28775-28778	the	
115-44	28779-28788	following	
115-45	28789-28795	ranges	
115-46	28795-28796	:	
115-47	28797-28798	[	
115-48	28798-28799	2	
115-49	28799-28800		
115-50	28800-28801	9	
115-51	28801-28802	]	
115-52	28802-28803	,	
115-53	28804-28805	[	
115-54	28805-28806	1	
115-55	28806-28807		
115-56	28807-28808	7	
115-57	28808-28809	]	
115-58	28809-28810	,	
115-59	28811-28812	[	
115-60	28812-28813	3	
115-61	28813-28814		
115-62	28814-28815	8	
115-63	28815-28816	]	
115-64	28817-28822	Let's	
115-65	28823-28826	try	
115-66	28827-28829	to	
115-67	28830-28836	search	
115-68	28837-28840	for	
115-69	28841-28844	the	
115-70	28845-28850	value	
115-71	28851-28852	5	
115-72	28852-28853	:	

#Text=[29] - Might be here [17] - Might be here [38] - Might be here In this case the index is not limiting the search at all, hence it is useless. Understanding pages_per_range
116-1	28854-28855	[	
116-2	28855-28856	2	
116-3	28856-28857		
116-4	28857-28858	9	
116-5	28858-28859	]	
116-6	28860-28861	-	
116-7	28862-28867	Might	
116-8	28868-28870	be	
116-9	28871-28875	here	
116-10	28876-28877	[	
116-11	28877-28878	1	
116-12	28878-28879		
116-13	28879-28880	7	
116-14	28880-28881	]	
116-15	28882-28883	-	
116-16	28884-28889	Might	
116-17	28890-28892	be	
116-18	28893-28897	here	
116-19	28898-28899	[	
116-20	28899-28900	3	
116-21	28900-28901		
116-22	28901-28902	8	
116-23	28902-28903	]	
116-24	28904-28905	-	
116-25	28906-28911	Might	
116-26	28912-28914	be	
116-27	28915-28919	here	
116-28	28920-28922	In	
116-29	28923-28927	this	
116-30	28928-28932	case	
116-31	28933-28936	the	
116-32	28937-28942	index	
116-33	28943-28945	is	
116-34	28946-28949	not	
116-35	28950-28958	limiting	
116-36	28959-28962	the	
116-37	28963-28969	search	
116-38	28970-28972	at	
116-39	28973-28976	all	
116-40	28976-28977	,	
116-41	28978-28983	hence	
116-42	28984-28986	it	
116-43	28987-28989	is	
116-44	28990-28997	useless	
116-45	28997-28998	.	
116-46	28999-29012	Understanding	
116-47	29013-29028	pages_per_range	

#Text=The number of adjacent pages is determined by the parameter pages_per_range. The number of pages per range effects the size and accuracy of the BRIN index: A large pages_per_range will produce a small and less accurate index A small pages_per_range will produce a bigger and more accurate index The default pages_per_range is 128. BRIN index with lower `pages_per_range`
117-1	29029-29032	The	
117-2	29033-29039	number	
117-3	29040-29042	of	
117-4	29043-29051	adjacent	
117-5	29052-29057	pages	
117-6	29058-29060	is	
117-7	29061-29071	determined	
117-8	29072-29074	by	
117-9	29075-29078	the	
117-10	29079-29088	parameter	
117-11	29089-29104	pages_per_range	
117-12	29104-29105	.	
117-13	29106-29109	The	
117-14	29110-29116	number	
117-15	29117-29119	of	
117-16	29120-29125	pages	
117-17	29126-29129	per	
117-18	29130-29135	range	
117-19	29136-29143	effects	
117-20	29144-29147	the	
117-21	29148-29152	size	
117-22	29153-29156	and	
117-23	29157-29165	accuracy	
117-24	29166-29168	of	
117-25	29169-29172	the	
117-26	29173-29177	BRIN	
117-27	29178-29183	index	
117-28	29183-29184	:	
117-29	29185-29186	A	
117-30	29187-29192	large	
117-31	29193-29208	pages_per_range	
117-32	29209-29213	will	
117-33	29214-29221	produce	
117-34	29222-29223	a	
117-35	29224-29229	small	
117-36	29230-29233	and	
117-37	29234-29238	less	
117-38	29239-29247	accurate	
117-39	29248-29253	index	
117-40	29254-29255	A	
117-41	29256-29261	small	
117-42	29262-29277	pages_per_range	
117-43	29278-29282	will	
117-44	29283-29290	produce	
117-45	29291-29292	a	
117-46	29293-29299	bigger	
117-47	29300-29303	and	
117-48	29304-29308	more	
117-49	29309-29317	accurate	
117-50	29318-29323	index	
117-51	29324-29327	The	
117-52	29328-29335	default	
117-53	29336-29351	pages_per_range	
117-54	29352-29354	is	
117-55	29355-29358	128	
117-56	29358-29359	.	
117-57	29360-29364	BRIN	
117-58	29365-29370	index	
117-59	29371-29375	with	
117-60	29376-29381	lower	
117-61	29382-29383	`	
117-62	29383-29398	pages_per_range	
117-63	29398-29399	`	

#Text=To demonstrate, let's create a BRIN index on ranges of 2 adjacent pages and search for the value 5: [12] - Definitely not here [34] - Definitely not here [56] - Might be here [78] - Definitely not here [9] - Definitely not here
118-1	29400-29402	To	
118-2	29403-29414	demonstrate	
118-3	29414-29415	,	
118-4	29416-29421	let's	
118-5	29422-29428	create	
118-6	29429-29430	a	
118-7	29431-29435	BRIN	
118-8	29436-29441	index	
118-9	29442-29444	on	
118-10	29445-29451	ranges	
118-11	29452-29454	of	
118-12	29455-29456	2	
118-13	29457-29465	adjacent	
118-14	29466-29471	pages	
118-15	29472-29475	and	
118-16	29476-29482	search	
118-17	29483-29486	for	
118-18	29487-29490	the	
118-19	29491-29496	value	
118-20	29497-29498	5	
118-21	29498-29499	:	
118-22	29500-29501	[	
118-23	29501-29502	1	
118-24	29502-29503		
118-25	29503-29504	2	
118-26	29504-29505	]	
118-27	29506-29507	-	
118-28	29508-29518	Definitely	
118-29	29519-29522	not	
118-30	29523-29527	here	
118-31	29528-29529	[	
118-32	29529-29530	3	
118-33	29530-29531		
118-34	29531-29532	4	
118-35	29532-29533	]	
118-36	29534-29535	-	
118-37	29536-29546	Definitely	
118-38	29547-29550	not	
118-39	29551-29555	here	
118-40	29556-29557	[	
118-41	29557-29558	5	
118-42	29558-29559		
118-43	29559-29560	6	
118-44	29560-29561	]	
118-45	29562-29563	-	
118-46	29564-29569	Might	
118-47	29570-29572	be	
118-48	29573-29577	here	
118-49	29578-29579	[	
118-50	29579-29580	7	
118-51	29580-29581		
118-52	29581-29582	8	
118-53	29582-29583	]	
118-54	29584-29585	-	
118-55	29586-29596	Definitely	
118-56	29597-29600	not	
118-57	29601-29605	here	
118-58	29606-29607	[	
118-59	29607-29608	9	
118-60	29608-29609	]	
118-61	29610-29611	-	
118-62	29612-29622	Definitely	
118-63	29623-29626	not	
118-64	29627-29631	here	

#Text=Using the index with 2 pages per range we were able to limit the search to blocks 5 and 6. When the range was 3 pages, the index limited the search to blocks 4,5 and 6. Another difference between the two indexes is that when the range was 3 we only had to keep 3 ranges. When the range was 2 we had to keep 5 ranges so the index was bigger. Creating a BRIN Index Using the sales_fact from before, let's create a BRIN index on the column sold_at:
119-1	29632-29637	Using	
119-2	29638-29641	the	
119-3	29642-29647	index	
119-4	29648-29652	with	
119-5	29653-29654	2	
119-6	29655-29660	pages	
119-7	29661-29664	per	
119-8	29665-29670	range	
119-9	29671-29673	we	
119-10	29674-29678	were	
119-11	29679-29683	able	
119-12	29684-29686	to	
119-13	29687-29692	limit	
119-14	29693-29696	the	
119-15	29697-29703	search	
119-16	29704-29706	to	
119-17	29707-29713	blocks	
119-18	29714-29715	5	
119-19	29716-29719	and	
119-20	29720-29721	6	
119-21	29721-29722	.	
119-22	29723-29727	When	
119-23	29728-29731	the	
119-24	29732-29737	range	
119-25	29738-29741	was	
119-26	29742-29743	3	
119-27	29744-29749	pages	
119-28	29749-29750	,	
119-29	29751-29754	the	
119-30	29755-29760	index	
119-31	29761-29768	limited	
119-32	29769-29772	the	
119-33	29773-29779	search	
119-34	29780-29782	to	
119-35	29783-29789	blocks	
119-36	29790-29793	4,5	
119-37	29794-29797	and	
119-38	29798-29799	6	
119-39	29799-29800	.	
119-40	29801-29808	Another	
119-41	29809-29819	difference	
119-42	29820-29827	between	
119-43	29828-29831	the	
119-44	29832-29835	two	
119-45	29836-29843	indexes	
119-46	29844-29846	is	
119-47	29847-29851	that	
119-48	29852-29856	when	
119-49	29857-29860	the	
119-50	29861-29866	range	
119-51	29867-29870	was	
119-52	29871-29872	3	
119-53	29873-29875	we	
119-54	29876-29880	only	
119-55	29881-29884	had	
119-56	29885-29887	to	
119-57	29888-29892	keep	
119-58	29893-29894	3	
119-59	29895-29901	ranges	
119-60	29901-29902	.	
119-61	29903-29907	When	
119-62	29908-29911	the	
119-63	29912-29917	range	
119-64	29918-29921	was	
119-65	29922-29923	2	
119-66	29924-29926	we	
119-67	29927-29930	had	
119-68	29931-29933	to	
119-69	29934-29938	keep	
119-70	29939-29940	5	
119-71	29941-29947	ranges	
119-72	29948-29950	so	
119-73	29951-29954	the	
119-74	29955-29960	index	
119-75	29961-29964	was	
119-76	29965-29971	bigger	
119-77	29971-29972	.	
119-78	29973-29981	Creating	
119-79	29982-29983	a	
119-80	29984-29988	BRIN	
119-81	29989-29994	Index	
119-82	29995-30000	Using	
119-83	30001-30004	the	
119-84	30005-30015	sales_fact	
119-85	30016-30020	from	
119-86	30021-30027	before	
119-87	30027-30028	,	
119-88	30029-30034	let's	
119-89	30035-30041	create	
119-90	30042-30043	a	
119-91	30044-30048	BRIN	
119-92	30049-30054	index	
119-93	30055-30057	on	
119-94	30058-30061	the	
119-95	30062-30068	column	
119-96	30069-30076	sold_at	
119-97	30076-30077	:	

#Text=db=# CREATE INDEX sale_fact_sold_at_bix ON sale_fact db-# USING BRIN(sold_at) WITH (pages_per_range = 128); CREATE INDEX This creates a BRIN index with the default pages_per_range = 128. Let's try to query for a range of sale dates:
120-1	30078-30080	db	
120-2	30080-30081	=	
120-3	30081-30082	#	
120-4	30083-30089	CREATE	
120-5	30090-30095	INDEX	
120-6	30096-30117	sale_fact_sold_at_bix	
120-7	30118-30120	ON	
120-8	30121-30130	sale_fact	
120-9	30131-30133	db	
120-10	30133-30134	-	
120-11	30134-30135	#	
120-12	30136-30141	USING	
120-13	30142-30146	BRIN	
120-14	30146-30147	(	
120-15	30147-30154	sold_at	
120-16	30154-30155	)	
120-17	30156-30160	WITH	
120-18	30161-30162	(	
120-19	30162-30177	pages_per_range	
120-20	30178-30179	=	
120-21	30180-30183	128	
120-22	30183-30184	)	
120-23	30184-30185	;	
120-24	30186-30192	CREATE	
120-25	30193-30198	INDEX	
120-26	30199-30203	This	
120-27	30204-30211	creates	
120-28	30212-30213	a	
120-29	30214-30218	BRIN	
120-30	30219-30224	index	
120-31	30225-30229	with	
120-32	30230-30233	the	
120-33	30234-30241	default	
120-34	30242-30257	pages_per_range	
120-35	30258-30259	=	
120-36	30260-30263	128	
120-37	30263-30264	.	
120-38	30265-30270	Let's	
120-39	30271-30274	try	
120-40	30275-30277	to	
120-41	30278-30283	query	
120-42	30284-30287	for	
120-43	30288-30289	a	
120-44	30290-30295	range	
120-45	30296-30298	of	
120-46	30299-30303	sale	
120-47	30304-30309	dates	
120-48	30309-30310	:	

#Text=db=# EXPLAIN (ANALYZE) db-# SELECT * db-# FROM sale_fact db-# WHERE sold_at BETWEEN '2020-07-01' AND '2020-07-31'; QUERY PLAN
121-1	30311-30313	db	
121-2	30313-30314	=	
121-3	30314-30315	#	
121-4	30316-30323	EXPLAIN	
121-5	30324-30325	(	
121-6	30325-30332	ANALYZE	
121-7	30332-30333	)	
121-8	30334-30336	db	
121-9	30336-30337	-	
121-10	30337-30338	#	
121-11	30339-30345	SELECT	
121-12	30346-30347	*	
121-13	30348-30350	db	
121-14	30350-30351	-	
121-15	30351-30352	#	
121-16	30353-30357	FROM	
121-17	30358-30367	sale_fact	
121-18	30368-30370	db	
121-19	30370-30371	-	
121-20	30371-30372	#	
121-21	30373-30378	WHERE	
121-22	30379-30386	sold_at	
121-23	30387-30394	BETWEEN	
121-24	30395-30396	'	
121-25	30396-30400	2020	
121-26	30400-30401	-	
121-27	30401-30403	07	
121-28	30403-30404	-	
121-29	30404-30406	01	
121-30	30406-30407	'	
121-31	30408-30411	AND	
121-32	30412-30413	'	
121-33	30413-30417	2020	
121-34	30417-30418	-	
121-35	30418-30420	07	
121-36	30420-30421	-	
121-37	30421-30423	31	
121-38	30423-30424	'	
121-39	30424-30425	;	
121-40	30426-30431	QUERY	
121-41	30432-30436	PLAN	

#Text=-------------------------------------------------------------------------------------------- Bitmap Heap Scan on sale_fact (cost=13.11..1135.61 rows=4319 width=41) Recheck Cond: ((sold_at >= '2020-07-01'::date) AND (sold_at <= '2020-07-31'::date))
122-1	30437-30438	-	
122-2	30438-30439	-	
122-3	30439-30440	-	
122-4	30440-30441	-	
122-5	30441-30442	-	
122-6	30442-30443	-	
122-7	30443-30444	-	
122-8	30444-30445	-	
122-9	30445-30446	-	
122-10	30446-30447	-	
122-11	30447-30448	-	
122-12	30448-30449	-	
122-13	30449-30450	-	
122-14	30450-30451	-	
122-15	30451-30452	-	
122-16	30452-30453	-	
122-17	30453-30454	-	
122-18	30454-30455	-	
122-19	30455-30456	-	
122-20	30456-30457	-	
122-21	30457-30458	-	
122-22	30458-30459	-	
122-23	30459-30460	-	
122-24	30460-30461	-	
122-25	30461-30462	-	
122-26	30462-30463	-	
122-27	30463-30464	-	
122-28	30464-30465	-	
122-29	30465-30466	-	
122-30	30466-30467	-	
122-31	30467-30468	-	
122-32	30468-30469	-	
122-33	30469-30470	-	
122-34	30470-30471	-	
122-35	30471-30472	-	
122-36	30472-30473	-	
122-37	30473-30474	-	
122-38	30474-30475	-	
122-39	30475-30476	-	
122-40	30476-30477	-	
122-41	30477-30478	-	
122-42	30478-30479	-	
122-43	30479-30480	-	
122-44	30480-30481	-	
122-45	30481-30482	-	
122-46	30482-30483	-	
122-47	30483-30484	-	
122-48	30484-30485	-	
122-49	30485-30486	-	
122-50	30486-30487	-	
122-51	30487-30488	-	
122-52	30488-30489	-	
122-53	30489-30490	-	
122-54	30490-30491	-	
122-55	30491-30492	-	
122-56	30492-30493	-	
122-57	30493-30494	-	
122-58	30494-30495	-	
122-59	30495-30496	-	
122-60	30496-30497	-	
122-61	30497-30498	-	
122-62	30498-30499	-	
122-63	30499-30500	-	
122-64	30500-30501	-	
122-65	30501-30502	-	
122-66	30502-30503	-	
122-67	30503-30504	-	
122-68	30504-30505	-	
122-69	30505-30506	-	
122-70	30506-30507	-	
122-71	30507-30508	-	
122-72	30508-30509	-	
122-73	30509-30510	-	
122-74	30510-30511	-	
122-75	30511-30512	-	
122-76	30512-30513	-	
122-77	30513-30514	-	
122-78	30514-30515	-	
122-79	30515-30516	-	
122-80	30516-30517	-	
122-81	30517-30518	-	
122-82	30518-30519	-	
122-83	30519-30520	-	
122-84	30520-30521	-	
122-85	30521-30522	-	
122-86	30522-30523	-	
122-87	30523-30524	-	
122-88	30524-30525	-	
122-89	30525-30526	-	
122-90	30526-30527	-	
122-91	30527-30528	-	
122-92	30528-30529	-	
122-93	30530-30536	Bitmap	
122-94	30537-30541	Heap	
122-95	30542-30546	Scan	
122-96	30547-30549	on	
122-97	30550-30559	sale_fact	
122-98	30560-30561	(	
122-99	30561-30565	cost	
122-100	30565-30566	=	
122-101	30566-30571	13.11	
122-102	30571-30572	.	
122-103	30572-30580	.1135.61	
122-104	30581-30585	rows	
122-105	30585-30586	=	
122-106	30586-30590	4319	
122-107	30591-30596	width	
122-108	30596-30597	=	
122-109	30597-30599	41	
122-110	30599-30600	)	
122-111	30601-30608	Recheck	
122-112	30609-30613	Cond	
122-113	30613-30614	:	
122-114	30615-30616	(	
122-115	30616-30617	(	
122-116	30617-30624	sold_at	
122-117	30625-30626	>	
122-118	30626-30627	=	
122-119	30628-30629	'	
122-120	30629-30633	2020	
122-121	30633-30634	-	
122-122	30634-30636	07	
122-123	30636-30637	-	
122-124	30637-30639	01	
122-125	30639-30640	'	
122-126	30640-30641	:	
122-127	30641-30642	:	
122-128	30642-30646	date	
122-129	30646-30647	)	
122-130	30648-30651	AND	
122-131	30652-30653	(	
122-132	30653-30660	sold_at	
122-133	30661-30662	<	
122-134	30662-30663	=	
122-135	30664-30665	'	
122-136	30665-30669	2020	
122-137	30669-30670	-	
122-138	30670-30672	07	
122-139	30672-30673	-	
122-140	30673-30675	31	
122-141	30675-30676	'	
122-142	30676-30677	:	
122-143	30677-30678	:	
122-144	30678-30682	date	
122-145	30682-30683	)	
122-146	30683-30684	)	

#Text=Rows Removed by Index Recheck: 23130 Heap Blocks: lossy=256 Bitmap Index Scan on sale_fact_sold_at_bix (cost=0.00..12.03 rows=12500 width=0)
123-1	30685-30689	Rows	
123-2	30690-30697	Removed	
123-3	30698-30700	by	
123-4	30701-30706	Index	
123-5	30707-30714	Recheck	
123-6	30714-30715	:	
123-7	30716-30721	23130	
123-8	30722-30726	Heap	
123-9	30727-30733	Blocks	
123-10	30733-30734	:	
123-11	30735-30740	lossy	
123-12	30740-30741	=	
123-13	30741-30744	256	
123-14	30745-30751	Bitmap	
123-15	30752-30757	Index	
123-16	30758-30762	Scan	
123-17	30763-30765	on	
123-18	30766-30787	sale_fact_sold_at_bix	
123-19	30788-30789	(	
123-20	30789-30793	cost	
123-21	30793-30794	=	
123-22	30794-30798	0.00	
123-23	30798-30799	.	
123-24	30799-30805	.12.03	
123-25	30806-30810	rows	
123-26	30810-30811	=	
123-27	30811-30816	12500	
123-28	30817-30822	width	
123-29	30822-30823	=	
123-30	30823-30824	0	
123-31	30824-30825	)	

#Text=Index Cond: ((sold_at >= '2020-07-01'::date) AND (sold_at <= '2020-07-31'::date)) Execution Time: 8.877 ms The database used our BRIN index to get a range of sale dates, but that's not the interesting part... Optimizing pages_per_range
124-1	30826-30831	Index	
124-2	30832-30836	Cond	
124-3	30836-30837	:	
124-4	30838-30839	(	
124-5	30839-30840	(	
124-6	30840-30847	sold_at	
124-7	30848-30849	>	
124-8	30849-30850	=	
124-9	30851-30852	'	
124-10	30852-30856	2020	
124-11	30856-30857	-	
124-12	30857-30859	07	
124-13	30859-30860	-	
124-14	30860-30862	01	
124-15	30862-30863	'	
124-16	30863-30864	:	
124-17	30864-30865	:	
124-18	30865-30869	date	
124-19	30869-30870	)	
124-20	30871-30874	AND	
124-21	30875-30876	(	
124-22	30876-30883	sold_at	
124-23	30884-30885	<	
124-24	30885-30886	=	
124-25	30887-30888	'	
124-26	30888-30892	2020	
124-27	30892-30893	-	
124-28	30893-30895	07	
124-29	30895-30896	-	
124-30	30896-30898	31	
124-31	30898-30899	'	
124-32	30899-30900	:	
124-33	30900-30901	:	
124-34	30901-30905	date	
124-35	30905-30906	)	
124-36	30906-30907	)	
124-37	30908-30917	Execution	
124-38	30918-30922	Time	
124-39	30922-30923	:	
124-40	30924-30929	8.877	
124-41	30930-30932	ms	
124-42	30933-30936	The	
124-43	30937-30945	database	
124-44	30946-30950	used	
124-45	30951-30954	our	
124-46	30955-30959	BRIN	
124-47	30960-30965	index	
124-48	30966-30968	to	
124-49	30969-30972	get	
124-50	30973-30974	a	
124-51	30975-30980	range	
124-52	30981-30983	of	
124-53	30984-30988	sale	
124-54	30989-30994	dates	
124-55	30994-30995	,	
124-56	30996-30999	but	
124-57	31000-31006	that's	
124-58	31007-31010	not	
124-59	31011-31014	the	
124-60	31015-31026	interesting	
124-61	31027-31031	part	
124-62	31031-31032	.	
124-63	31032-31033	.	
124-64	31033-31034	.	
124-65	31035-31045	Optimizing	
124-66	31046-31061	pages_per_range	

#Text=According to the execution plan, the database removed 23,130 rows from the pages it found using the index. This may indicate that the range we set for the index it too large for this particular query. Let's try to create an index with less pages per range: db=# CREATE INDEX sale_fact_sold_at_bix64 ON sale_fact db-# USING BRIN(sold_at) WITH (pages_per_range = 64); CREATE INDEX
125-1	31062-31071	According	
125-2	31072-31074	to	
125-3	31075-31078	the	
125-4	31079-31088	execution	
125-5	31089-31093	plan	
125-6	31093-31094	,	
125-7	31095-31098	the	
125-8	31099-31107	database	
125-9	31108-31115	removed	
125-10	31116-31122	23,130	
125-11	31123-31127	rows	
125-12	31128-31132	from	
125-13	31133-31136	the	
125-14	31137-31142	pages	
125-15	31143-31145	it	
125-16	31146-31151	found	
125-17	31152-31157	using	
125-18	31158-31161	the	
125-19	31162-31167	index	
125-20	31167-31168	.	
125-21	31169-31173	This	
125-22	31174-31177	may	
125-23	31178-31186	indicate	
125-24	31187-31191	that	
125-25	31192-31195	the	
125-26	31196-31201	range	
125-27	31202-31204	we	
125-28	31205-31208	set	
125-29	31209-31212	for	
125-30	31213-31216	the	
125-31	31217-31222	index	
125-32	31223-31225	it	
125-33	31226-31229	too	
125-34	31230-31235	large	
125-35	31236-31239	for	
125-36	31240-31244	this	
125-37	31245-31255	particular	
125-38	31256-31261	query	
125-39	31261-31262	.	
125-40	31263-31268	Let's	
125-41	31269-31272	try	
125-42	31273-31275	to	
125-43	31276-31282	create	
125-44	31283-31285	an	
125-45	31286-31291	index	
125-46	31292-31296	with	
125-47	31297-31301	less	
125-48	31302-31307	pages	
125-49	31308-31311	per	
125-50	31312-31317	range	
125-51	31317-31318	:	
125-52	31319-31321	db	
125-53	31321-31322	=	
125-54	31322-31323	#	
125-55	31324-31330	CREATE	
125-56	31331-31336	INDEX	
125-57	31337-31360	sale_fact_sold_at_bix64	
125-58	31361-31363	ON	
125-59	31364-31373	sale_fact	
125-60	31374-31376	db	
125-61	31376-31377	-	
125-62	31377-31378	#	
125-63	31379-31384	USING	
125-64	31385-31389	BRIN	
125-65	31389-31390	(	
125-66	31390-31397	sold_at	
125-67	31397-31398	)	
125-68	31399-31403	WITH	
125-69	31404-31405	(	
125-70	31405-31420	pages_per_range	
125-71	31421-31422	=	
125-72	31423-31425	64	
125-73	31425-31426	)	
125-74	31426-31427	;	
125-75	31428-31434	CREATE	
125-76	31435-31440	INDEX	

#Text=db=# EXPLAIN (ANALYZE) db- SELECT * db- FROM sale_fact db- WHERE sold_at BETWEEN '2020-07-01' AND '2020-07-31'; QUERY PLAN
126-1	31441-31443	db	
126-2	31443-31444	=	
126-3	31444-31445	#	
126-4	31446-31453	EXPLAIN	
126-5	31454-31455	(	
126-6	31455-31462	ANALYZE	
126-7	31462-31463	)	
126-8	31464-31466	db	
126-9	31466-31467	-	
126-10	31468-31474	SELECT	
126-11	31475-31476	*	
126-12	31477-31479	db	
126-13	31479-31480	-	
126-14	31481-31485	FROM	
126-15	31486-31495	sale_fact	
126-16	31496-31498	db	
126-17	31498-31499	-	
126-18	31500-31505	WHERE	
126-19	31506-31513	sold_at	
126-20	31514-31521	BETWEEN	
126-21	31522-31523	'	
126-22	31523-31527	2020	
126-23	31527-31528	-	
126-24	31528-31530	07	
126-25	31530-31531	-	
126-26	31531-31533	01	
126-27	31533-31534	'	
126-28	31535-31538	AND	
126-29	31539-31540	'	
126-30	31540-31544	2020	
126-31	31544-31545	-	
126-32	31545-31547	07	
126-33	31547-31548	-	
126-34	31548-31550	31	
126-35	31550-31551	'	
126-36	31551-31552	;	
126-37	31553-31558	QUERY	
126-38	31559-31563	PLAN	

#Text=--------------------------------------------------------------------------------------------- Bitmap Heap Scan on sale_fact (cost=13.10..1048.10 rows=4319 width=41) Recheck Cond: ((sold_at >= '2020-07-01'::date) AND (sold_at <= '2020-07-31'::date))
127-1	31564-31565	-	
127-2	31565-31566	-	
127-3	31566-31567	-	
127-4	31567-31568	-	
127-5	31568-31569	-	
127-6	31569-31570	-	
127-7	31570-31571	-	
127-8	31571-31572	-	
127-9	31572-31573	-	
127-10	31573-31574	-	
127-11	31574-31575	-	
127-12	31575-31576	-	
127-13	31576-31577	-	
127-14	31577-31578	-	
127-15	31578-31579	-	
127-16	31579-31580	-	
127-17	31580-31581	-	
127-18	31581-31582	-	
127-19	31582-31583	-	
127-20	31583-31584	-	
127-21	31584-31585	-	
127-22	31585-31586	-	
127-23	31586-31587	-	
127-24	31587-31588	-	
127-25	31588-31589	-	
127-26	31589-31590	-	
127-27	31590-31591	-	
127-28	31591-31592	-	
127-29	31592-31593	-	
127-30	31593-31594	-	
127-31	31594-31595	-	
127-32	31595-31596	-	
127-33	31596-31597	-	
127-34	31597-31598	-	
127-35	31598-31599	-	
127-36	31599-31600	-	
127-37	31600-31601	-	
127-38	31601-31602	-	
127-39	31602-31603	-	
127-40	31603-31604	-	
127-41	31604-31605	-	
127-42	31605-31606	-	
127-43	31606-31607	-	
127-44	31607-31608	-	
127-45	31608-31609	-	
127-46	31609-31610	-	
127-47	31610-31611	-	
127-48	31611-31612	-	
127-49	31612-31613	-	
127-50	31613-31614	-	
127-51	31614-31615	-	
127-52	31615-31616	-	
127-53	31616-31617	-	
127-54	31617-31618	-	
127-55	31618-31619	-	
127-56	31619-31620	-	
127-57	31620-31621	-	
127-58	31621-31622	-	
127-59	31622-31623	-	
127-60	31623-31624	-	
127-61	31624-31625	-	
127-62	31625-31626	-	
127-63	31626-31627	-	
127-64	31627-31628	-	
127-65	31628-31629	-	
127-66	31629-31630	-	
127-67	31630-31631	-	
127-68	31631-31632	-	
127-69	31632-31633	-	
127-70	31633-31634	-	
127-71	31634-31635	-	
127-72	31635-31636	-	
127-73	31636-31637	-	
127-74	31637-31638	-	
127-75	31638-31639	-	
127-76	31639-31640	-	
127-77	31640-31641	-	
127-78	31641-31642	-	
127-79	31642-31643	-	
127-80	31643-31644	-	
127-81	31644-31645	-	
127-82	31645-31646	-	
127-83	31646-31647	-	
127-84	31647-31648	-	
127-85	31648-31649	-	
127-86	31649-31650	-	
127-87	31650-31651	-	
127-88	31651-31652	-	
127-89	31652-31653	-	
127-90	31653-31654	-	
127-91	31654-31655	-	
127-92	31655-31656	-	
127-93	31656-31657	-	
127-94	31658-31664	Bitmap	
127-95	31665-31669	Heap	
127-96	31670-31674	Scan	
127-97	31675-31677	on	
127-98	31678-31687	sale_fact	
127-99	31688-31689	(	
127-100	31689-31693	cost	
127-101	31693-31694	=	
127-102	31694-31699	13.10	
127-103	31699-31700	.	
127-104	31700-31708	.1048.10	
127-105	31709-31713	rows	
127-106	31713-31714	=	
127-107	31714-31718	4319	
127-108	31719-31724	width	
127-109	31724-31725	=	
127-110	31725-31727	41	
127-111	31727-31728	)	
127-112	31729-31736	Recheck	
127-113	31737-31741	Cond	
127-114	31741-31742	:	
127-115	31743-31744	(	
127-116	31744-31745	(	
127-117	31745-31752	sold_at	
127-118	31753-31754	>	
127-119	31754-31755	=	
127-120	31756-31757	'	
127-121	31757-31761	2020	
127-122	31761-31762	-	
127-123	31762-31764	07	
127-124	31764-31765	-	
127-125	31765-31767	01	
127-126	31767-31768	'	
127-127	31768-31769	:	
127-128	31769-31770	:	
127-129	31770-31774	date	
127-130	31774-31775	)	
127-131	31776-31779	AND	
127-132	31780-31781	(	
127-133	31781-31788	sold_at	
127-134	31789-31790	<	
127-135	31790-31791	=	
127-136	31792-31793	'	
127-137	31793-31797	2020	
127-138	31797-31798	-	
127-139	31798-31800	07	
127-140	31800-31801	-	
127-141	31801-31803	31	
127-142	31803-31804	'	
127-143	31804-31805	:	
127-144	31805-31806	:	
127-145	31806-31810	date	
127-146	31810-31811	)	
127-147	31811-31812	)	

#Text=Rows Removed by Index Recheck: 9434 Heap Blocks: lossy=128 Bitmap Index Scan on sale_fact_sold_at_bix64 (cost=0.00..12.02 rows=6667 width=0)
128-1	31813-31817	Rows	
128-2	31818-31825	Removed	
128-3	31826-31828	by	
128-4	31829-31834	Index	
128-5	31835-31842	Recheck	
128-6	31842-31843	:	
128-7	31844-31848	9434	
128-8	31849-31853	Heap	
128-9	31854-31860	Blocks	
128-10	31860-31861	:	
128-11	31862-31867	lossy	
128-12	31867-31868	=	
128-13	31868-31871	128	
128-14	31872-31878	Bitmap	
128-15	31879-31884	Index	
128-16	31885-31889	Scan	
128-17	31890-31892	on	
128-18	31893-31916	sale_fact_sold_at_bix64	
128-19	31917-31918	(	
128-20	31918-31922	cost	
128-21	31922-31923	=	
128-22	31923-31927	0.00	
128-23	31927-31928	.	
128-24	31928-31934	.12.02	
128-25	31935-31939	rows	
128-26	31939-31940	=	
128-27	31940-31944	6667	
128-28	31945-31950	width	
128-29	31950-31951	=	
128-30	31951-31952	0	
128-31	31952-31953	)	

#Text=Index Cond: ((sold_at >= '2020-07-01'::date) AND (sold_at <= '2020-07-31'::date)) Execution Time: 5.491 ms With 64 pages per range the database removed less rows from the pages it found using the the index, only 9,434 were removed compared with 23,130 when the the range was 128 pages. This means the database had to do less IO and the query was slightly faster, ~5.5ms compared to ~8.9ms.
129-1	31954-31959	Index	
129-2	31960-31964	Cond	
129-3	31964-31965	:	
129-4	31966-31967	(	
129-5	31967-31968	(	
129-6	31968-31975	sold_at	
129-7	31976-31977	>	
129-8	31977-31978	=	
129-9	31979-31980	'	
129-10	31980-31984	2020	
129-11	31984-31985	-	
129-12	31985-31987	07	
129-13	31987-31988	-	
129-14	31988-31990	01	
129-15	31990-31991	'	
129-16	31991-31992	:	
129-17	31992-31993	:	
129-18	31993-31997	date	
129-19	31997-31998	)	
129-20	31999-32002	AND	
129-21	32003-32004	(	
129-22	32004-32011	sold_at	
129-23	32012-32013	<	
129-24	32013-32014	=	
129-25	32015-32016	'	
129-26	32016-32020	2020	
129-27	32020-32021	-	
129-28	32021-32023	07	
129-29	32023-32024	-	
129-30	32024-32026	31	
129-31	32026-32027	'	
129-32	32027-32028	:	
129-33	32028-32029	:	
129-34	32029-32033	date	
129-35	32033-32034	)	
129-36	32034-32035	)	
129-37	32036-32045	Execution	
129-38	32046-32050	Time	
129-39	32050-32051	:	
129-40	32052-32057	5.491	
129-41	32058-32060	ms	
129-42	32061-32065	With	
129-43	32066-32068	64	
129-44	32069-32074	pages	
129-45	32075-32078	per	
129-46	32079-32084	range	
129-47	32085-32088	the	
129-48	32089-32097	database	
129-49	32098-32105	removed	
129-50	32106-32110	less	
129-51	32111-32115	rows	
129-52	32116-32120	from	
129-53	32121-32124	the	
129-54	32125-32130	pages	
129-55	32131-32133	it	
129-56	32134-32139	found	
129-57	32140-32145	using	
129-58	32146-32149	the	
129-59	32150-32153	the	
129-60	32154-32159	index	
129-61	32159-32160	,	
129-62	32161-32165	only	
129-63	32166-32171	9,434	
129-64	32172-32176	were	
129-65	32177-32184	removed	
129-66	32185-32193	compared	
129-67	32194-32198	with	
129-68	32199-32205	23,130	
129-69	32206-32210	when	
129-70	32211-32214	the	
129-71	32215-32218	the	
129-72	32219-32224	range	
129-73	32225-32228	was	
129-74	32229-32232	128	
129-75	32233-32238	pages	
129-76	32238-32239	.	
129-77	32240-32244	This	
129-78	32245-32250	means	
129-79	32251-32254	the	
129-80	32255-32263	database	
129-81	32264-32267	had	
129-82	32268-32270	to	
129-83	32271-32273	do	
129-84	32274-32278	less	
129-85	32279-32281	IO	
129-86	32282-32285	and	
129-87	32286-32289	the	
129-88	32290-32295	query	
129-89	32296-32299	was	
129-90	32300-32308	slightly	
129-91	32309-32315	faster	
129-92	32315-32316	,	
129-93	32317-32318	~	
129-94	32318-32323	5.5ms	
129-95	32324-32332	compared	
129-96	32333-32335	to	
129-97	32336-32337	~	
129-98	32337-32342	8.9ms	
129-99	32342-32343	.	

#Text=Testing the index with different values for pages_per_range produced the following results: pages_per_range Rows Removed by Index Recheck 128 23,130 9,434 874 446 446 We can see that as we decrease pages_per_range, the index is more accurate and less rows are removed from the pages found using the index.
130-1	32344-32351	Testing	
130-2	32352-32355	the	
130-3	32356-32361	index	
130-4	32362-32366	with	
130-5	32367-32376	different	
130-6	32377-32383	values	
130-7	32384-32387	for	
130-8	32388-32403	pages_per_range	
130-9	32404-32412	produced	
130-10	32413-32416	the	
130-11	32417-32426	following	
130-12	32427-32434	results	
130-13	32434-32435	:	
130-14	32436-32451	pages_per_range	
130-15	32452-32456	Rows	
130-16	32457-32464	Removed	
130-17	32465-32467	by	
130-18	32468-32473	Index	
130-19	32474-32481	Recheck	
130-20	32482-32485	128	
130-21	32486-32492	23,130	
130-22	32493-32498	9,434	
130-23	32499-32502	874	
130-24	32503-32506	446	
130-25	32507-32510	446	
130-26	32511-32513	We	
130-27	32514-32517	can	
130-28	32518-32521	see	
130-29	32522-32526	that	
130-30	32527-32529	as	
130-31	32530-32532	we	
130-32	32533-32541	decrease	
130-33	32542-32557	pages_per_range	
130-34	32557-32558	,	
130-35	32559-32562	the	
130-36	32563-32568	index	
130-37	32569-32571	is	
130-38	32572-32576	more	
130-39	32577-32585	accurate	
130-40	32586-32589	and	
130-41	32590-32594	less	
130-42	32595-32599	rows	
130-43	32600-32603	are	
130-44	32604-32611	removed	
130-45	32612-32616	from	
130-46	32617-32620	the	
130-47	32621-32626	pages	
130-48	32627-32632	found	
130-49	32633-32638	using	
130-50	32639-32642	the	
130-51	32643-32648	index	
130-52	32648-32649	.	

#Text=Note that we optimized the query for a very specific query. This is fine for demonstration purposes, but in real life it's best to use values that meet the needs of most queries. Evaluating Index Size Another big selling point for BRIN indexes is their size. In previous sections we created a B-Tree index on the sold_at field. The size of the index was 2224kB. The size a BRIN index with pages_per_range=128 is only 48kb. That's 46 times smaller than the B-Tree index.
131-1	32650-32654	Note	
131-2	32655-32659	that	
131-3	32660-32662	we	
131-4	32663-32672	optimized	
131-5	32673-32676	the	
131-6	32677-32682	query	
131-7	32683-32686	for	
131-8	32687-32688	a	
131-9	32689-32693	very	
131-10	32694-32702	specific	
131-11	32703-32708	query	
131-12	32708-32709	.	
131-13	32710-32714	This	
131-14	32715-32717	is	
131-15	32718-32722	fine	
131-16	32723-32726	for	
131-17	32727-32740	demonstration	
131-18	32741-32749	purposes	
131-19	32749-32750	,	
131-20	32751-32754	but	
131-21	32755-32757	in	
131-22	32758-32762	real	
131-23	32763-32767	life	
131-24	32768-32772	it's	
131-25	32773-32777	best	
131-26	32778-32780	to	
131-27	32781-32784	use	
131-28	32785-32791	values	
131-29	32792-32796	that	
131-30	32797-32801	meet	
131-31	32802-32805	the	
131-32	32806-32811	needs	
131-33	32812-32814	of	
131-34	32815-32819	most	
131-35	32820-32827	queries	
131-36	32827-32828	.	
131-37	32829-32839	Evaluating	
131-38	32840-32845	Index	
131-39	32846-32850	Size	
131-40	32851-32858	Another	
131-41	32859-32862	big	
131-42	32863-32870	selling	
131-43	32871-32876	point	
131-44	32877-32880	for	
131-45	32881-32885	BRIN	
131-46	32886-32893	indexes	
131-47	32894-32896	is	
131-48	32897-32902	their	
131-49	32903-32907	size	
131-50	32907-32908	.	
131-51	32909-32911	In	
131-52	32912-32920	previous	
131-53	32921-32929	sections	
131-54	32930-32932	we	
131-55	32933-32940	created	
131-56	32941-32942	a	
131-57	32943-32949	B-Tree	
131-58	32950-32955	index	
131-59	32956-32958	on	
131-60	32959-32962	the	
131-61	32963-32970	sold_at	
131-62	32971-32976	field	
131-63	32976-32977	.	
131-64	32978-32981	The	
131-65	32982-32986	size	
131-66	32987-32989	of	
131-67	32990-32993	the	
131-68	32994-32999	index	
131-69	33000-33003	was	
131-70	33004-33010	2224kB	
131-71	33010-33011	.	
131-72	33012-33015	The	
131-73	33016-33020	size	
131-74	33021-33022	a	
131-75	33023-33027	BRIN	
131-76	33028-33033	index	
131-77	33034-33038	with	
131-78	33039-33054	pages_per_range	
131-79	33054-33055	=	
131-80	33055-33058	128	
131-81	33059-33061	is	
131-82	33062-33066	only	
131-83	33067-33071	48kb	
131-84	33071-33072	.	
131-85	33073-33079	That's	
131-86	33080-33082	46	
131-87	33083-33088	times	
131-88	33089-33096	smaller	
131-89	33097-33101	than	
131-90	33102-33105	the	
131-91	33106-33112	B-Tree	
131-92	33113-33118	index	
131-93	33118-33119	.	

#Text=Schema | Name | Type | Owner | Table | Size --------+-----------------------+-------+-------+-----------+-------
132-1	33120-33126	Schema	
132-2	33127-33128	|	
132-3	33129-33133	Name	
132-4	33134-33135	|	
132-5	33136-33140	Type	
132-6	33141-33142	|	
132-7	33143-33148	Owner	
132-8	33149-33150	|	
132-9	33151-33156	Table	
132-10	33157-33158	|	
132-11	33159-33163	Size	
132-12	33164-33165	-	
132-13	33165-33166	-	
132-14	33166-33167	-	
132-15	33167-33168	-	
132-16	33168-33169	-	
132-17	33169-33170	-	
132-18	33170-33171	-	
132-19	33171-33172	-	
132-20	33172-33173	+	
132-21	33173-33174	-	
132-22	33174-33175	-	
132-23	33175-33176	-	
132-24	33176-33177	-	
132-25	33177-33178	-	
132-26	33178-33179	-	
132-27	33179-33180	-	
132-28	33180-33181	-	
132-29	33181-33182	-	
132-30	33182-33183	-	
132-31	33183-33184	-	
132-32	33184-33185	-	
132-33	33185-33186	-	
132-34	33186-33187	-	
132-35	33187-33188	-	
132-36	33188-33189	-	
132-37	33189-33190	-	
132-38	33190-33191	-	
132-39	33191-33192	-	
132-40	33192-33193	-	
132-41	33193-33194	-	
132-42	33194-33195	-	
132-43	33195-33196	-	
132-44	33196-33197	+	
132-45	33197-33198	-	
132-46	33198-33199	-	
132-47	33199-33200	-	
132-48	33200-33201	-	
132-49	33201-33202	-	
132-50	33202-33203	-	
132-51	33203-33204	-	
132-52	33204-33205	+	
132-53	33205-33206	-	
132-54	33206-33207	-	
132-55	33207-33208	-	
132-56	33208-33209	-	
132-57	33209-33210	-	
132-58	33210-33211	-	
132-59	33211-33212	-	
132-60	33212-33213	+	
132-61	33213-33214	-	
132-62	33214-33215	-	
132-63	33215-33216	-	
132-64	33216-33217	-	
132-65	33217-33218	-	
132-66	33218-33219	-	
132-67	33219-33220	-	
132-68	33220-33221	-	
132-69	33221-33222	-	
132-70	33222-33223	-	
132-71	33223-33224	-	
132-72	33224-33225	+	
132-73	33225-33226	-	
132-74	33226-33227	-	
132-75	33227-33228	-	
132-76	33228-33229	-	
132-77	33229-33230	-	
132-78	33230-33231	-	
132-79	33231-33232	-	

#Text=public | sale_fact_sold_at_bix | index | haki | sale_fact | 48 kB public | sale_fact_sold_at_ix | index | haki | sale_fact | 2224 kB
133-1	33233-33239	public	
133-2	33240-33241	|	
133-3	33242-33263	sale_fact_sold_at_bix	
133-4	33264-33265	|	
133-5	33266-33271	index	
133-6	33272-33273	|	
133-7	33274-33278	haki	
133-8	33279-33280	|	
133-9	33281-33290	sale_fact	
133-10	33291-33292	|	
133-11	33293-33295	48	
133-12	33296-33298	kB	
133-13	33299-33305	public	
133-14	33306-33307	|	
133-15	33308-33328	sale_fact_sold_at_ix	
133-16	33329-33330	|	
133-17	33331-33336	index	
133-18	33337-33338	|	
133-19	33339-33343	haki	
133-20	33344-33345	|	
133-21	33346-33355	sale_fact	
133-22	33356-33357	|	
133-23	33358-33362	2224	
133-24	33363-33365	kB	

#Text=The size of a BRIN index is also affected by pages_per_range. For example, a BRIN index with pages_per_range=2 weighs 56kb, which is only slightly bigger than 48kb. Make Indexes "Invisible" PostgreSQL has a nice feature called transactional DDL. After years of using Oracle, I got used to DDL commands such as CREATE, DROP and ALTER ending a transaction. However, in PostgreSQL you can perform DDL commands inside a transaction, and changes will take effect only when the transaction is committed.
134-1	33366-33369	The	
134-2	33370-33374	size	
134-3	33375-33377	of	
134-4	33378-33379	a	
134-5	33380-33384	BRIN	
134-6	33385-33390	index	
134-7	33391-33393	is	
134-8	33394-33398	also	
134-9	33399-33407	affected	
134-10	33408-33410	by	
134-11	33411-33426	pages_per_range	
134-12	33426-33427	.	
134-13	33428-33431	For	
134-14	33432-33439	example	
134-15	33439-33440	,	
134-16	33441-33442	a	
134-17	33443-33447	BRIN	
134-18	33448-33453	index	
134-19	33454-33458	with	
134-20	33459-33474	pages_per_range	
134-21	33474-33475	=	
134-22	33475-33476	2	
134-23	33477-33483	weighs	
134-24	33484-33488	56kb	
134-25	33488-33489	,	
134-26	33490-33495	which	
134-27	33496-33498	is	
134-28	33499-33503	only	
134-29	33504-33512	slightly	
134-30	33513-33519	bigger	
134-31	33520-33524	than	
134-32	33525-33529	48kb	
134-33	33529-33530	.	
134-34	33531-33535	Make	
134-35	33536-33543	Indexes	
134-36	33544-33545	"	
134-37	33545-33554	Invisible	
134-38	33554-33555	"	
134-39	33556-33566	PostgreSQL	
134-40	33567-33570	has	
134-41	33571-33572	a	
134-42	33573-33577	nice	
134-43	33578-33585	feature	
134-44	33586-33592	called	
134-45	33593-33606	transactional	
134-46	33607-33610	DDL	
134-47	33610-33611	.	
134-48	33612-33617	After	
134-49	33618-33623	years	
134-50	33624-33626	of	
134-51	33627-33632	using	
134-52	33633-33639	Oracle	
134-53	33639-33640	,	
134-54	33641-33642	I	
134-55	33643-33646	got	
134-56	33647-33651	used	
134-57	33652-33654	to	
134-58	33655-33658	DDL	
134-59	33659-33667	commands	
134-60	33668-33672	such	
134-61	33673-33675	as	
134-62	33676-33682	CREATE	
134-63	33682-33683	,	
134-64	33684-33688	DROP	
134-65	33689-33692	and	
134-66	33693-33698	ALTER	
134-67	33699-33705	ending	
134-68	33706-33707	a	
134-69	33708-33719	transaction	
134-70	33719-33720	.	
134-71	33721-33728	However	
134-72	33728-33729	,	
134-73	33730-33732	in	
134-74	33733-33743	PostgreSQL	
134-75	33744-33747	you	
134-76	33748-33751	can	
134-77	33752-33759	perform	
134-78	33760-33763	DDL	
134-79	33764-33772	commands	
134-80	33773-33779	inside	
134-81	33780-33781	a	
134-82	33782-33793	transaction	
134-83	33793-33794	,	
134-84	33795-33798	and	
134-85	33799-33806	changes	
134-86	33807-33811	will	
134-87	33812-33816	take	
134-88	33817-33823	effect	
134-89	33824-33828	only	
134-90	33829-33833	when	
134-91	33834-33837	the	
134-92	33838-33849	transaction	
134-93	33850-33852	is	
134-94	33853-33862	committed	
134-95	33862-33863	.	

#Text=As I recently discovered, using transactional DDL you can make indexes invisible! This comes in handy when you want to see what an execution plan looks like without some index. For example, in the sale_fact table from the previous section we created an index on sold_at. The execution plan for fetching sales made in July looked like this: db=# EXPLAIN db-# SELECT *
135-1	33864-33866	As	
135-2	33867-33868	I	
135-3	33869-33877	recently	
135-4	33878-33888	discovered	
135-5	33888-33889	,	
135-6	33890-33895	using	
135-7	33896-33909	transactional	
135-8	33910-33913	DDL	
135-9	33914-33917	you	
135-10	33918-33921	can	
135-11	33922-33926	make	
135-12	33927-33934	indexes	
135-13	33935-33944	invisible	
135-14	33944-33945	!	
135-15	33946-33950	This	
135-16	33951-33956	comes	
135-17	33957-33959	in	
135-18	33960-33965	handy	
135-19	33966-33970	when	
135-20	33971-33974	you	
135-21	33975-33979	want	
135-22	33980-33982	to	
135-23	33983-33986	see	
135-24	33987-33991	what	
135-25	33992-33994	an	
135-26	33995-34004	execution	
135-27	34005-34009	plan	
135-28	34010-34015	looks	
135-29	34016-34020	like	
135-30	34021-34028	without	
135-31	34029-34033	some	
135-32	34034-34039	index	
135-33	34039-34040	.	
135-34	34041-34044	For	
135-35	34045-34052	example	
135-36	34052-34053	,	
135-37	34054-34056	in	
135-38	34057-34060	the	
135-39	34061-34070	sale_fact	
135-40	34071-34076	table	
135-41	34077-34081	from	
135-42	34082-34085	the	
135-43	34086-34094	previous	
135-44	34095-34102	section	
135-45	34103-34105	we	
135-46	34106-34113	created	
135-47	34114-34116	an	
135-48	34117-34122	index	
135-49	34123-34125	on	
135-50	34126-34133	sold_at	
135-51	34133-34134	.	
135-52	34135-34138	The	
135-53	34139-34148	execution	
135-54	34149-34153	plan	
135-55	34154-34157	for	
135-56	34158-34166	fetching	
135-57	34167-34172	sales	
135-58	34173-34177	made	
135-59	34178-34180	in	
135-60	34181-34185	July	
135-61	34186-34192	looked	
135-62	34193-34197	like	
135-63	34198-34202	this	
135-64	34202-34203	:	
135-65	34204-34206	db	
135-66	34206-34207	=	
135-67	34207-34208	#	
135-68	34209-34216	EXPLAIN	
135-69	34217-34219	db	
135-70	34219-34220	-	
135-71	34220-34221	#	
135-72	34222-34228	SELECT	
135-73	34229-34230	*	

#Text=db-# FROM sale_fact db-# WHERE sold_at BETWEEN '2020-07-01' AND '2020-07-31'; QUERY PLAN
136-1	34231-34233	db	
136-2	34233-34234	-	
136-3	34234-34235	#	
136-4	34236-34240	FROM	
136-5	34241-34250	sale_fact	
136-6	34251-34253	db	
136-7	34253-34254	-	
136-8	34254-34255	#	
136-9	34256-34261	WHERE	
136-10	34262-34269	sold_at	
136-11	34270-34277	BETWEEN	
136-12	34278-34279	'	
136-13	34279-34283	2020	
136-14	34283-34284	-	
136-15	34284-34286	07	
136-16	34286-34287	-	
136-17	34287-34289	01	
136-18	34289-34290	'	
136-19	34291-34294	AND	
136-20	34295-34296	'	
136-21	34296-34300	2020	
136-22	34300-34301	-	
136-23	34301-34303	07	
136-24	34303-34304	-	
136-25	34304-34306	31	
136-26	34306-34307	'	
136-27	34307-34308	;	
136-28	34309-34314	QUERY	
136-29	34315-34319	PLAN	

#Text=-------------------------------------------------------------------------------------------- Index Scan using sale_fact_sold_at_ix on sale_fact (cost=0.42..182.80 rows=4319 width=41) Index Cond: ((sold_at >= '2020-07-01'::date) AND (sold_at <= '2020-07-31'::date))P
137-1	34320-34321	-	
137-2	34321-34322	-	
137-3	34322-34323	-	
137-4	34323-34324	-	
137-5	34324-34325	-	
137-6	34325-34326	-	
137-7	34326-34327	-	
137-8	34327-34328	-	
137-9	34328-34329	-	
137-10	34329-34330	-	
137-11	34330-34331	-	
137-12	34331-34332	-	
137-13	34332-34333	-	
137-14	34333-34334	-	
137-15	34334-34335	-	
137-16	34335-34336	-	
137-17	34336-34337	-	
137-18	34337-34338	-	
137-19	34338-34339	-	
137-20	34339-34340	-	
137-21	34340-34341	-	
137-22	34341-34342	-	
137-23	34342-34343	-	
137-24	34343-34344	-	
137-25	34344-34345	-	
137-26	34345-34346	-	
137-27	34346-34347	-	
137-28	34347-34348	-	
137-29	34348-34349	-	
137-30	34349-34350	-	
137-31	34350-34351	-	
137-32	34351-34352	-	
137-33	34352-34353	-	
137-34	34353-34354	-	
137-35	34354-34355	-	
137-36	34355-34356	-	
137-37	34356-34357	-	
137-38	34357-34358	-	
137-39	34358-34359	-	
137-40	34359-34360	-	
137-41	34360-34361	-	
137-42	34361-34362	-	
137-43	34362-34363	-	
137-44	34363-34364	-	
137-45	34364-34365	-	
137-46	34365-34366	-	
137-47	34366-34367	-	
137-48	34367-34368	-	
137-49	34368-34369	-	
137-50	34369-34370	-	
137-51	34370-34371	-	
137-52	34371-34372	-	
137-53	34372-34373	-	
137-54	34373-34374	-	
137-55	34374-34375	-	
137-56	34375-34376	-	
137-57	34376-34377	-	
137-58	34377-34378	-	
137-59	34378-34379	-	
137-60	34379-34380	-	
137-61	34380-34381	-	
137-62	34381-34382	-	
137-63	34382-34383	-	
137-64	34383-34384	-	
137-65	34384-34385	-	
137-66	34385-34386	-	
137-67	34386-34387	-	
137-68	34387-34388	-	
137-69	34388-34389	-	
137-70	34389-34390	-	
137-71	34390-34391	-	
137-72	34391-34392	-	
137-73	34392-34393	-	
137-74	34393-34394	-	
137-75	34394-34395	-	
137-76	34395-34396	-	
137-77	34396-34397	-	
137-78	34397-34398	-	
137-79	34398-34399	-	
137-80	34399-34400	-	
137-81	34400-34401	-	
137-82	34401-34402	-	
137-83	34402-34403	-	
137-84	34403-34404	-	
137-85	34404-34405	-	
137-86	34405-34406	-	
137-87	34406-34407	-	
137-88	34407-34408	-	
137-89	34408-34409	-	
137-90	34409-34410	-	
137-91	34410-34411	-	
137-92	34411-34412	-	
137-93	34413-34418	Index	
137-94	34419-34423	Scan	
137-95	34424-34429	using	
137-96	34430-34450	sale_fact_sold_at_ix	
137-97	34451-34453	on	
137-98	34454-34463	sale_fact	
137-99	34464-34465	(	
137-100	34465-34469	cost	
137-101	34469-34470	=	
137-102	34470-34474	0.42	
137-103	34474-34475	.	
137-104	34475-34482	.182.80	
137-105	34483-34487	rows	
137-106	34487-34488	=	
137-107	34488-34492	4319	
137-108	34493-34498	width	
137-109	34498-34499	=	
137-110	34499-34501	41	
137-111	34501-34502	)	
137-112	34503-34508	Index	
137-113	34509-34513	Cond	
137-114	34513-34514	:	
137-115	34515-34516	(	
137-116	34516-34517	(	
137-117	34517-34524	sold_at	
137-118	34525-34526	>	
137-119	34526-34527	=	
137-120	34528-34529	'	
137-121	34529-34533	2020	
137-122	34533-34534	-	
137-123	34534-34536	07	
137-124	34536-34537	-	
137-125	34537-34539	01	
137-126	34539-34540	'	
137-127	34540-34541	:	
137-128	34541-34542	:	
137-129	34542-34546	date	
137-130	34546-34547	)	
137-131	34548-34551	AND	
137-132	34552-34553	(	
137-133	34553-34560	sold_at	
137-134	34561-34562	<	
137-135	34562-34563	=	
137-136	34564-34565	'	
137-137	34565-34569	2020	
137-138	34569-34570	-	
137-139	34570-34572	07	
137-140	34572-34573	-	
137-141	34573-34575	31	
137-142	34575-34576	'	
137-143	34576-34577	:	
137-144	34577-34578	:	
137-145	34578-34582	date	
137-146	34582-34583	)	
137-147	34583-34584	)	
137-148	34584-34585	P	

#Text=To see what the execution plan would be if the index sale_fact_sold_at_ix did not exist, we can drop the index inside a transaction and immediately rollback: db=# BEGIN; BEGIN db=# DROP INDEX sale_fact_sold_at_ix; DROP INDEX db=# EXPLAIN db-# SELECT *
138-1	34586-34588	To	
138-2	34589-34592	see	
138-3	34593-34597	what	
138-4	34598-34601	the	
138-5	34602-34611	execution	
138-6	34612-34616	plan	
138-7	34617-34622	would	
138-8	34623-34625	be	
138-9	34626-34628	if	
138-10	34629-34632	the	
138-11	34633-34638	index	
138-12	34639-34659	sale_fact_sold_at_ix	
138-13	34660-34663	did	
138-14	34664-34667	not	
138-15	34668-34673	exist	
138-16	34673-34674	,	
138-17	34675-34677	we	
138-18	34678-34681	can	
138-19	34682-34686	drop	
138-20	34687-34690	the	
138-21	34691-34696	index	
138-22	34697-34703	inside	
138-23	34704-34705	a	
138-24	34706-34717	transaction	
138-25	34718-34721	and	
138-26	34722-34733	immediately	
138-27	34734-34742	rollback	
138-28	34742-34743	:	
138-29	34744-34746	db	
138-30	34746-34747	=	
138-31	34747-34748	#	
138-32	34749-34754	BEGIN	
138-33	34754-34755	;	
138-34	34756-34761	BEGIN	
138-35	34762-34764	db	
138-36	34764-34765	=	
138-37	34765-34766	#	
138-38	34767-34771	DROP	
138-39	34772-34777	INDEX	
138-40	34778-34798	sale_fact_sold_at_ix	
138-41	34798-34799	;	
138-42	34800-34804	DROP	
138-43	34805-34810	INDEX	
138-44	34811-34813	db	
138-45	34813-34814	=	
138-46	34814-34815	#	
138-47	34816-34823	EXPLAIN	
138-48	34824-34826	db	
138-49	34826-34827	-	
138-50	34827-34828	#	
138-51	34829-34835	SELECT	
138-52	34836-34837	*	

#Text=db-# FROM sale_fact db-# WHERE sold_at BETWEEN '2020-07-01' AND '2020-07-31'; QUERY PLAN
139-1	34838-34840	db	
139-2	34840-34841	-	
139-3	34841-34842	#	
139-4	34843-34847	FROM	
139-5	34848-34857	sale_fact	
139-6	34858-34860	db	
139-7	34860-34861	-	
139-8	34861-34862	#	
139-9	34863-34868	WHERE	
139-10	34869-34876	sold_at	
139-11	34877-34884	BETWEEN	
139-12	34885-34886	'	
139-13	34886-34890	2020	
139-14	34890-34891	-	
139-15	34891-34893	07	
139-16	34893-34894	-	
139-17	34894-34896	01	
139-18	34896-34897	'	
139-19	34898-34901	AND	
139-20	34902-34903	'	
139-21	34903-34907	2020	
139-22	34907-34908	-	
139-23	34908-34910	07	
139-24	34910-34911	-	
139-25	34911-34913	31	
139-26	34913-34914	'	
139-27	34914-34915	;	
139-28	34916-34921	QUERY	
139-29	34922-34926	PLAN	

#Text=--------------------------------------------------------------------------------- Seq Scan on sale_fact (cost=0.00..2435.00 rows=4319 width=41) Filter: ((sold_at >= '2020-07-01'::date) AND (sold_at <= '2020-07-31'::date))
140-1	34927-34928	-	
140-2	34928-34929	-	
140-3	34929-34930	-	
140-4	34930-34931	-	
140-5	34931-34932	-	
140-6	34932-34933	-	
140-7	34933-34934	-	
140-8	34934-34935	-	
140-9	34935-34936	-	
140-10	34936-34937	-	
140-11	34937-34938	-	
140-12	34938-34939	-	
140-13	34939-34940	-	
140-14	34940-34941	-	
140-15	34941-34942	-	
140-16	34942-34943	-	
140-17	34943-34944	-	
140-18	34944-34945	-	
140-19	34945-34946	-	
140-20	34946-34947	-	
140-21	34947-34948	-	
140-22	34948-34949	-	
140-23	34949-34950	-	
140-24	34950-34951	-	
140-25	34951-34952	-	
140-26	34952-34953	-	
140-27	34953-34954	-	
140-28	34954-34955	-	
140-29	34955-34956	-	
140-30	34956-34957	-	
140-31	34957-34958	-	
140-32	34958-34959	-	
140-33	34959-34960	-	
140-34	34960-34961	-	
140-35	34961-34962	-	
140-36	34962-34963	-	
140-37	34963-34964	-	
140-38	34964-34965	-	
140-39	34965-34966	-	
140-40	34966-34967	-	
140-41	34967-34968	-	
140-42	34968-34969	-	
140-43	34969-34970	-	
140-44	34970-34971	-	
140-45	34971-34972	-	
140-46	34972-34973	-	
140-47	34973-34974	-	
140-48	34974-34975	-	
140-49	34975-34976	-	
140-50	34976-34977	-	
140-51	34977-34978	-	
140-52	34978-34979	-	
140-53	34979-34980	-	
140-54	34980-34981	-	
140-55	34981-34982	-	
140-56	34982-34983	-	
140-57	34983-34984	-	
140-58	34984-34985	-	
140-59	34985-34986	-	
140-60	34986-34987	-	
140-61	34987-34988	-	
140-62	34988-34989	-	
140-63	34989-34990	-	
140-64	34990-34991	-	
140-65	34991-34992	-	
140-66	34992-34993	-	
140-67	34993-34994	-	
140-68	34994-34995	-	
140-69	34995-34996	-	
140-70	34996-34997	-	
140-71	34997-34998	-	
140-72	34998-34999	-	
140-73	34999-35000	-	
140-74	35000-35001	-	
140-75	35001-35002	-	
140-76	35002-35003	-	
140-77	35003-35004	-	
140-78	35004-35005	-	
140-79	35005-35006	-	
140-80	35006-35007	-	
140-81	35007-35008	-	
140-82	35009-35012	Seq	
140-83	35013-35017	Scan	
140-84	35018-35020	on	
140-85	35021-35030	sale_fact	
140-86	35031-35032	(	
140-87	35032-35036	cost	
140-88	35036-35037	=	
140-89	35037-35041	0.00	
140-90	35041-35042	.	
140-91	35042-35050	.2435.00	
140-92	35051-35055	rows	
140-93	35055-35056	=	
140-94	35056-35060	4319	
140-95	35061-35066	width	
140-96	35066-35067	=	
140-97	35067-35069	41	
140-98	35069-35070	)	
140-99	35071-35077	Filter	
140-100	35077-35078	:	
140-101	35079-35080	(	
140-102	35080-35081	(	
140-103	35081-35088	sold_at	
140-104	35089-35090	>	
140-105	35090-35091	=	
140-106	35092-35093	'	
140-107	35093-35097	2020	
140-108	35097-35098	-	
140-109	35098-35100	07	
140-110	35100-35101	-	
140-111	35101-35103	01	
140-112	35103-35104	'	
140-113	35104-35105	:	
140-114	35105-35106	:	
140-115	35106-35110	date	
140-116	35110-35111	)	
140-117	35112-35115	AND	
140-118	35116-35117	(	
140-119	35117-35124	sold_at	
140-120	35125-35126	<	
140-121	35126-35127	=	
140-122	35128-35129	'	
140-123	35129-35133	2020	
140-124	35133-35134	-	
140-125	35134-35136	07	
140-126	35136-35137	-	
140-127	35137-35139	31	
140-128	35139-35140	'	
140-129	35140-35141	:	
140-130	35141-35142	:	
140-131	35142-35146	date	
140-132	35146-35147	)	
140-133	35147-35148	)	

#Text=db=# ROLLBACK; ROLLBACK We first start a transaction using BEGIN. Then we drop the index and generate an execution plan. Notice that the execution plan now uses a full table scan, as if the index does not exist. At this point the transaction is still in progress, so the index is not dropped yet. To finish the transaction without dropping the index we rollback the transaction using the ROLLBACK command.
141-1	35149-35151	db	
141-2	35151-35152	=	
141-3	35152-35153	#	
141-4	35154-35162	ROLLBACK	
141-5	35162-35163	;	
141-6	35164-35172	ROLLBACK	
141-7	35173-35175	We	
141-8	35176-35181	first	
141-9	35182-35187	start	
141-10	35188-35189	a	
141-11	35190-35201	transaction	
141-12	35202-35207	using	
141-13	35208-35213	BEGIN	
141-14	35213-35214	.	
141-15	35215-35219	Then	
141-16	35220-35222	we	
141-17	35223-35227	drop	
141-18	35228-35231	the	
141-19	35232-35237	index	
141-20	35238-35241	and	
141-21	35242-35250	generate	
141-22	35251-35253	an	
141-23	35254-35263	execution	
141-24	35264-35268	plan	
141-25	35268-35269	.	
141-26	35270-35276	Notice	
141-27	35277-35281	that	
141-28	35282-35285	the	
141-29	35286-35295	execution	
141-30	35296-35300	plan	
141-31	35301-35304	now	
141-32	35305-35309	uses	
141-33	35310-35311	a	
141-34	35312-35316	full	
141-35	35317-35322	table	
141-36	35323-35327	scan	
141-37	35327-35328	,	
141-38	35329-35331	as	
141-39	35332-35334	if	
141-40	35335-35338	the	
141-41	35339-35344	index	
141-42	35345-35349	does	
141-43	35350-35353	not	
141-44	35354-35359	exist	
141-45	35359-35360	.	
141-46	35361-35363	At	
141-47	35364-35368	this	
141-48	35369-35374	point	
141-49	35375-35378	the	
141-50	35379-35390	transaction	
141-51	35391-35393	is	
141-52	35394-35399	still	
141-53	35400-35402	in	
141-54	35403-35411	progress	
141-55	35411-35412	,	
141-56	35413-35415	so	
141-57	35416-35419	the	
141-58	35420-35425	index	
141-59	35426-35428	is	
141-60	35429-35432	not	
141-61	35433-35440	dropped	
141-62	35441-35444	yet	
141-63	35444-35445	.	
141-64	35446-35448	To	
141-65	35449-35455	finish	
141-66	35456-35459	the	
141-67	35460-35471	transaction	
141-68	35472-35479	without	
141-69	35480-35488	dropping	
141-70	35489-35492	the	
141-71	35493-35498	index	
141-72	35499-35501	we	
141-73	35502-35510	rollback	
141-74	35511-35514	the	
141-75	35515-35526	transaction	
141-76	35527-35532	using	
141-77	35533-35536	the	
141-78	35537-35545	ROLLBACK	
141-79	35546-35553	command	
141-80	35553-35554	.	

#Text=Now, make sure the index still exists: db=# \\di+ sale_fact_sold_at_ix List of relations Schema | Name | Type | Owner | Table Size
142-1	35555-35558	Now	
142-2	35558-35559	,	
142-3	35560-35564	make	
142-4	35565-35569	sure	
142-5	35570-35573	the	
142-6	35574-35579	index	
142-7	35580-35585	still	
142-8	35586-35592	exists	
142-9	35592-35593	:	
142-10	35594-35596	db	
142-11	35596-35597	=	
142-12	35597-35598	#	
142-13	35599-35600	\	
142-14	35600-35602	di	
142-15	35602-35603	+	
142-16	35604-35624	sale_fact_sold_at_ix	
142-17	35625-35629	List	
142-18	35630-35632	of	
142-19	35633-35642	relations	
142-20	35643-35649	Schema	
142-21	35650-35651	|	
142-22	35652-35656	Name	
142-23	35657-35658	|	
142-24	35659-35663	Type	
142-25	35664-35665	|	
142-26	35666-35671	Owner	
142-27	35672-35673	|	
142-28	35674-35679	Table	
142-29	35680-35684	Size	

#Text=--------+----------------------+-------+-------+-----------+--------- public | sale_fact_sold_at_ix | index | haki | sale_fact | 2224 kB Other database that don't support transactional DDL provide other ways to achieve the same goal. For example, Oracle let's you mark an index as invisible, which will cause the optimizer to ignore it.
143-1	35685-35686	-	
143-2	35686-35687	-	
143-3	35687-35688	-	
143-4	35688-35689	-	
143-5	35689-35690	-	
143-6	35690-35691	-	
143-7	35691-35692	-	
143-8	35692-35693	-	
143-9	35693-35694	+	
143-10	35694-35695	-	
143-11	35695-35696	-	
143-12	35696-35697	-	
143-13	35697-35698	-	
143-14	35698-35699	-	
143-15	35699-35700	-	
143-16	35700-35701	-	
143-17	35701-35702	-	
143-18	35702-35703	-	
143-19	35703-35704	-	
143-20	35704-35705	-	
143-21	35705-35706	-	
143-22	35706-35707	-	
143-23	35707-35708	-	
143-24	35708-35709	-	
143-25	35709-35710	-	
143-26	35710-35711	-	
143-27	35711-35712	-	
143-28	35712-35713	-	
143-29	35713-35714	-	
143-30	35714-35715	-	
143-31	35715-35716	-	
143-32	35716-35717	+	
143-33	35717-35718	-	
143-34	35718-35719	-	
143-35	35719-35720	-	
143-36	35720-35721	-	
143-37	35721-35722	-	
143-38	35722-35723	-	
143-39	35723-35724	-	
143-40	35724-35725	+	
143-41	35725-35726	-	
143-42	35726-35727	-	
143-43	35727-35728	-	
143-44	35728-35729	-	
143-45	35729-35730	-	
143-46	35730-35731	-	
143-47	35731-35732	-	
143-48	35732-35733	+	
143-49	35733-35734	-	
143-50	35734-35735	-	
143-51	35735-35736	-	
143-52	35736-35737	-	
143-53	35737-35738	-	
143-54	35738-35739	-	
143-55	35739-35740	-	
143-56	35740-35741	-	
143-57	35741-35742	-	
143-58	35742-35743	-	
143-59	35743-35744	-	
143-60	35744-35745	+	
143-61	35745-35746	-	
143-62	35746-35747	-	
143-63	35747-35748	-	
143-64	35748-35749	-	
143-65	35749-35750	-	
143-66	35750-35751	-	
143-67	35751-35752	-	
143-68	35752-35753	-	
143-69	35753-35754	-	
143-70	35755-35761	public	
143-71	35762-35763	|	
143-72	35764-35784	sale_fact_sold_at_ix	
143-73	35785-35786	|	
143-74	35787-35792	index	
143-75	35793-35794	|	
143-76	35795-35799	haki	
143-77	35800-35801	|	
143-78	35802-35811	sale_fact	
143-79	35812-35813	|	
143-80	35814-35818	2224	
143-81	35819-35821	kB	
143-82	35822-35827	Other	
143-83	35828-35836	database	
143-84	35837-35841	that	
143-85	35842-35847	don't	
143-86	35848-35855	support	
143-87	35856-35869	transactional	
143-88	35870-35873	DDL	
143-89	35874-35881	provide	
143-90	35882-35887	other	
143-91	35888-35892	ways	
143-92	35893-35895	to	
143-93	35896-35903	achieve	
143-94	35904-35907	the	
143-95	35908-35912	same	
143-96	35913-35917	goal	
143-97	35917-35918	.	
143-98	35919-35922	For	
143-99	35923-35930	example	
143-100	35930-35931	,	
143-101	35932-35938	Oracle	
143-102	35939-35944	let's	
143-103	35945-35948	you	
143-104	35949-35953	mark	
143-105	35954-35956	an	
143-106	35957-35962	index	
143-107	35963-35965	as	
143-108	35966-35975	invisible	
143-109	35975-35976	,	
143-110	35977-35982	which	
143-111	35983-35987	will	
143-112	35988-35993	cause	
143-113	35994-35997	the	
143-114	35998-36007	optimizer	
143-115	36008-36010	to	
143-116	36011-36017	ignore	
143-117	36018-36020	it	
143-118	36020-36021	.	

#Text=CAUTION: Dropping an index inside a transaction will lock out concurrent selects, inserts, updates, and deletes on the table while the transaction is active. Use with caution in test environments, and avoid on production databases. Don't Schedule Long Running Processes at Round Hours It's a known fact among investors that weird things can happen when a stock's price reaches a nice round number such as 10$, 100$, 1000$. As the following article explains:
144-1	36022-36029	CAUTION	
144-2	36029-36030	:	
144-3	36031-36039	Dropping	
144-4	36040-36042	an	
144-5	36043-36048	index	
144-6	36049-36055	inside	
144-7	36056-36057	a	
144-8	36058-36069	transaction	
144-9	36070-36074	will	
144-10	36075-36079	lock	
144-11	36080-36083	out	
144-12	36084-36094	concurrent	
144-13	36095-36102	selects	
144-14	36102-36103	,	
144-15	36104-36111	inserts	
144-16	36111-36112	,	
144-17	36113-36120	updates	
144-18	36120-36121	,	
144-19	36122-36125	and	
144-20	36126-36133	deletes	
144-21	36134-36136	on	
144-22	36137-36140	the	
144-23	36141-36146	table	
144-24	36147-36152	while	
144-25	36153-36156	the	
144-26	36157-36168	transaction	
144-27	36169-36171	is	
144-28	36172-36178	active	
144-29	36178-36179	.	
144-30	36180-36183	Use	
144-31	36184-36188	with	
144-32	36189-36196	caution	
144-33	36197-36199	in	
144-34	36200-36204	test	
144-35	36205-36217	environments	
144-36	36217-36218	,	
144-37	36219-36222	and	
144-38	36223-36228	avoid	
144-39	36229-36231	on	
144-40	36232-36242	production	
144-41	36243-36252	databases	
144-42	36252-36253	.	
144-43	36254-36259	Don't	
144-44	36260-36268	Schedule	
144-45	36269-36273	Long	
144-46	36274-36281	Running	
144-47	36282-36291	Processes	
144-48	36292-36294	at	
144-49	36295-36300	Round	
144-50	36301-36306	Hours	
144-51	36307-36311	It's	
144-52	36312-36313	a	
144-53	36314-36319	known	
144-54	36320-36324	fact	
144-55	36325-36330	among	
144-56	36331-36340	investors	
144-57	36341-36345	that	
144-58	36346-36351	weird	
144-59	36352-36358	things	
144-60	36359-36362	can	
144-61	36363-36369	happen	
144-62	36370-36374	when	
144-63	36375-36376	a	
144-64	36377-36384	stock's	
144-65	36385-36390	price	
144-66	36391-36398	reaches	
144-67	36399-36400	a	
144-68	36401-36405	nice	
144-69	36406-36411	round	
144-70	36412-36418	number	
144-71	36419-36423	such	
144-72	36424-36426	as	
144-73	36427-36429	10	
144-74	36429-36430	$	
144-75	36430-36431	,	
144-76	36432-36435	100	
144-77	36435-36436	$	
144-78	36436-36437	,	
144-79	36438-36442	1000	
144-80	36442-36443	$	
144-81	36443-36444	.	
144-82	36445-36447	As	
144-83	36448-36451	the	
144-84	36452-36461	following	
144-85	36462-36469	article	
144-86	36470-36478	explains	
144-87	36478-36479	:	

#Text=[...] asset's price may have a difficult time moving beyond a round number, such as $50 or $100 per share. Most inexperienced traders tend to buy or sell assets when the price is at a whole number because they are more likely to feel that a stock is fairly valued at such levels. Developers in this sense are not all that different than the investors. When they need to schedule a long running process, they will usually schedule it at a round hour. Typical load on a system during the night
145-1	36480-36481	[	
145-2	36481-36482	.	
145-3	36482-36483	.	
145-4	36483-36484	.	
145-5	36484-36485	]	
145-6	36486-36493	asset's	
145-7	36494-36499	price	
145-8	36500-36503	may	
145-9	36504-36508	have	
145-10	36509-36510	a	
145-11	36511-36520	difficult	
145-12	36521-36525	time	
145-13	36526-36532	moving	
145-14	36533-36539	beyond	
145-15	36540-36541	a	
145-16	36542-36547	round	
145-17	36548-36554	number	
145-18	36554-36555	,	
145-19	36556-36560	such	
145-20	36561-36563	as	
145-21	36564-36567	$50	
145-22	36568-36570	or	
145-23	36571-36575	$100	
145-24	36576-36579	per	
145-25	36580-36585	share	
145-26	36585-36586	.	
145-27	36587-36591	Most	
145-28	36592-36605	inexperienced	
145-29	36606-36613	traders	
145-30	36614-36618	tend	
145-31	36619-36621	to	
145-32	36622-36625	buy	
145-33	36626-36628	or	
145-34	36629-36633	sell	
145-35	36634-36640	assets	
145-36	36641-36645	when	
145-37	36646-36649	the	
145-38	36650-36655	price	
145-39	36656-36658	is	
145-40	36659-36661	at	
145-41	36662-36663	a	
145-42	36664-36669	whole	
145-43	36670-36676	number	
145-44	36677-36684	because	
145-45	36685-36689	they	
145-46	36690-36693	are	
145-47	36694-36698	more	
145-48	36699-36705	likely	
145-49	36706-36708	to	
145-50	36709-36713	feel	
145-51	36714-36718	that	
145-52	36719-36720	a	
145-53	36721-36726	stock	
145-54	36727-36729	is	
145-55	36730-36736	fairly	
145-56	36737-36743	valued	
145-57	36744-36746	at	
145-58	36747-36751	such	
145-59	36752-36758	levels	
145-60	36758-36759	.	
145-61	36760-36770	Developers	
145-62	36771-36773	in	
145-63	36774-36778	this	
145-64	36779-36784	sense	
145-65	36785-36788	are	
145-66	36789-36792	not	
145-67	36793-36796	all	
145-68	36797-36801	that	
145-69	36802-36811	different	
145-70	36812-36816	than	
145-71	36817-36820	the	
145-72	36821-36830	investors	
145-73	36830-36831	.	
145-74	36832-36836	When	
145-75	36837-36841	they	
145-76	36842-36846	need	
145-77	36847-36849	to	
145-78	36850-36858	schedule	
145-79	36859-36860	a	
145-80	36861-36865	long	
145-81	36866-36873	running	
145-82	36874-36881	process	
145-83	36881-36882	,	
145-84	36883-36887	they	
145-85	36888-36892	will	
145-86	36893-36900	usually	
145-87	36901-36909	schedule	
145-88	36910-36912	it	
145-89	36913-36915	at	
145-90	36916-36917	a	
145-91	36918-36923	round	
145-92	36924-36928	hour	
145-93	36928-36929	.	
145-94	36930-36937	Typical	
145-95	36938-36942	load	
145-96	36943-36945	on	
145-97	36946-36947	a	
145-98	36948-36954	system	
145-99	36955-36961	during	
145-100	36962-36965	the	
145-101	36966-36971	night	

#Text=This tendency to schedule tasks at round hours can cause some unusual loads during these times. So, if you need to schedule some long running process, you have a better chance of finding a system at rest if you schedule at another time. Another good idea is to apply a random delay to the task's schedule, so it doesn't run at the same time every time. This way, even if another task is scheduled to run at the same time, it won't be a big problem. If you use systemd timer units to schedule your tasks, you can use the RandomizedDelaySec option for this.
146-1	36972-36976	This	
146-2	36977-36985	tendency	
146-3	36986-36988	to	
146-4	36989-36997	schedule	
146-5	36998-37003	tasks	
146-6	37004-37006	at	
146-7	37007-37012	round	
146-8	37013-37018	hours	
146-9	37019-37022	can	
146-10	37023-37028	cause	
146-11	37029-37033	some	
146-12	37034-37041	unusual	
146-13	37042-37047	loads	
146-14	37048-37054	during	
146-15	37055-37060	these	
146-16	37061-37066	times	
146-17	37066-37067	.	
146-18	37068-37070	So	
146-19	37070-37071	,	
146-20	37072-37074	if	
146-21	37075-37078	you	
146-22	37079-37083	need	
146-23	37084-37086	to	
146-24	37087-37095	schedule	
146-25	37096-37100	some	
146-26	37101-37105	long	
146-27	37106-37113	running	
146-28	37114-37121	process	
146-29	37121-37122	,	
146-30	37123-37126	you	
146-31	37127-37131	have	
146-32	37132-37133	a	
146-33	37134-37140	better	
146-34	37141-37147	chance	
146-35	37148-37150	of	
146-36	37151-37158	finding	
146-37	37159-37160	a	
146-38	37161-37167	system	
146-39	37168-37170	at	
146-40	37171-37175	rest	
146-41	37176-37178	if	
146-42	37179-37182	you	
146-43	37183-37191	schedule	
146-44	37192-37194	at	
146-45	37195-37202	another	
146-46	37203-37207	time	
146-47	37207-37208	.	
146-48	37209-37216	Another	
146-49	37217-37221	good	
146-50	37222-37226	idea	
146-51	37227-37229	is	
146-52	37230-37232	to	
146-53	37233-37238	apply	
146-54	37239-37240	a	
146-55	37241-37247	random	
146-56	37248-37253	delay	
146-57	37254-37256	to	
146-58	37257-37260	the	
146-59	37261-37267	task's	
146-60	37268-37276	schedule	
146-61	37276-37277	,	
146-62	37278-37280	so	
146-63	37281-37283	it	
146-64	37284-37291	doesn't	
146-65	37292-37295	run	
146-66	37296-37298	at	
146-67	37299-37302	the	
146-68	37303-37307	same	
146-69	37308-37312	time	
146-70	37313-37318	every	
146-71	37319-37323	time	
146-72	37323-37324	.	
146-73	37325-37329	This	
146-74	37330-37333	way	
146-75	37333-37334	,	
146-76	37335-37339	even	
146-77	37340-37342	if	
146-78	37343-37350	another	
146-79	37351-37355	task	
146-80	37356-37358	is	
146-81	37359-37368	scheduled	
146-82	37369-37371	to	
146-83	37372-37375	run	
146-84	37376-37378	at	
146-85	37379-37382	the	
146-86	37383-37387	same	
146-87	37388-37392	time	
146-88	37392-37393	,	
146-89	37394-37396	it	
146-90	37397-37402	won't	
146-91	37403-37405	be	
146-92	37406-37407	a	
146-93	37408-37411	big	
146-94	37412-37419	problem	
146-95	37419-37420	.	
146-96	37421-37423	If	
146-97	37424-37427	you	
146-98	37428-37431	use	
146-99	37432-37439	systemd	
146-100	37440-37445	timer	
146-101	37446-37451	units	
146-102	37452-37454	to	
146-103	37455-37463	schedule	
146-104	37464-37468	your	
146-105	37469-37474	tasks	
146-106	37474-37475	,	
146-107	37476-37479	you	
146-108	37480-37483	can	
146-109	37484-37487	use	
146-110	37488-37491	the	
146-111	37492-37510	RandomizedDelaySec	
146-112	37511-37517	option	
146-113	37518-37521	for	
146-114	37522-37526	this	
146-115	37526-37527	.	

#Text=Conclusion This article covers some trivial and non-trivial tips from my own experience. Some of these tips are easy to implement, and some require a deeper understanding of how the database works. Databases are the backbone of most modern systems, so taking some time to understand how they work is a good investment for any developer!
147-1	37528-37538	Conclusion	
147-2	37539-37543	This	
147-3	37544-37551	article	
147-4	37552-37558	covers	
147-5	37559-37563	some	
147-6	37564-37571	trivial	
147-7	37572-37575	and	
147-8	37576-37587	non-trivial	
147-9	37588-37592	tips	
147-10	37593-37597	from	
147-11	37598-37600	my	
147-12	37601-37604	own	
147-13	37605-37615	experience	
147-14	37615-37616	.	
147-15	37617-37621	Some	
147-16	37622-37624	of	
147-17	37625-37630	these	
147-18	37631-37635	tips	
147-19	37636-37639	are	
147-20	37640-37644	easy	
147-21	37645-37647	to	
147-22	37648-37657	implement	
147-23	37657-37658	,	
147-24	37659-37662	and	
147-25	37663-37667	some	
147-26	37668-37675	require	
147-27	37676-37677	a	
147-28	37678-37684	deeper	
147-29	37685-37698	understanding	
147-30	37699-37701	of	
147-31	37702-37705	how	
147-32	37706-37709	the	
147-33	37710-37718	database	
147-34	37719-37724	works	
147-35	37724-37725	.	
147-36	37726-37735	Databases	
147-37	37736-37739	are	
147-38	37740-37743	the	
147-39	37744-37752	backbone	
147-40	37753-37755	of	
147-41	37756-37760	most	
147-42	37761-37767	modern	
147-43	37768-37775	systems	
147-44	37775-37776	,	
147-45	37777-37779	so	
147-46	37780-37786	taking	
147-47	37787-37791	some	
147-48	37792-37796	time	
147-49	37797-37799	to	
147-50	37800-37810	understand	
147-51	37811-37814	how	
147-52	37815-37819	they	
147-53	37820-37824	work	
147-54	37825-37827	is	
147-55	37828-37829	a	
147-56	37830-37834	good	
147-57	37835-37845	investment	
147-58	37846-37849	for	
147-59	37850-37853	any	
147-60	37854-37863	developer	
147-61	37863-37864	!	

#Text=This article was reviewed by the great team at pgMustard Want me to send you an email when I publish something new? Share to show you care Email Twitter Facebook Reddit Share Similar articles 11 January 2021 PostgreSQL, Performance,
148-1	37865-37869	This	
148-2	37870-37877	article	
148-3	37878-37881	was	
148-4	37882-37890	reviewed	
148-5	37891-37893	by	
148-6	37894-37897	the	
148-7	37898-37903	great	
148-8	37904-37908	team	
148-9	37909-37911	at	
148-10	37912-37921	pgMustard	
148-11	37922-37926	Want	
148-12	37927-37929	me	
148-13	37930-37932	to	
148-14	37933-37937	send	
148-15	37938-37941	you	
148-16	37942-37944	an	
148-17	37945-37950	email	
148-18	37951-37955	when	
148-19	37956-37957	I	
148-20	37958-37965	publish	
148-21	37966-37975	something	
148-22	37976-37979	new	
148-23	37979-37980	?	
148-24	37981-37986	Share	
148-25	37987-37989	to	
148-26	37990-37994	show	
148-27	37995-37998	you	
148-28	37999-38003	care	
148-29	38004-38009	Email	
148-30	38010-38017	Twitter	
148-31	38018-38026	Facebook	
148-32	38027-38033	Reddit	
148-33	38034-38039	Share	
148-34	38040-38047	Similar	
148-35	38048-38056	articles	
148-36	38057-38059	11	
148-37	38060-38067	January	
148-38	38068-38072	2021	
148-39	38073-38083	PostgreSQL	
148-40	38083-38084	,	
148-41	38085-38096	Performance	
148-42	38096-38097	,	

#Text=SQL Re-Introducing Hash Indexes in PostgreSQL The Ugly Duckling of index types 20 October 2020 SQL, Performance, PostgreSQL The Surprising Impact of Medium-Size Texts on PostgreSQL Performance
149-1	38098-38101	SQL	
149-2	38102-38116	Re-Introducing	
149-3	38117-38121	Hash	
149-4	38122-38129	Indexes	
149-5	38130-38132	in	
149-6	38133-38143	PostgreSQL	
149-7	38144-38147	The	
149-8	38148-38152	Ugly	
149-9	38153-38161	Duckling	
149-10	38162-38164	of	
149-11	38165-38170	index	
149-12	38171-38176	types	
149-13	38177-38179	20	
149-14	38180-38187	October	
149-15	38188-38192	2020	
149-16	38193-38196	SQL	
149-17	38196-38197	,	
149-18	38198-38209	Performance	
149-19	38209-38210	,	
149-20	38211-38221	PostgreSQL	
149-21	38222-38225	The	
149-22	38226-38236	Surprising	
149-23	38237-38243	Impact	
149-24	38244-38246	of	
149-25	38247-38258	Medium-Size	
149-26	38259-38264	Texts	
149-27	38265-38267	on	
149-28	38268-38278	PostgreSQL	
149-29	38279-38290	Performance	

#Text=Why TOAST is the best thing since sliced bread 21 November 2019 PostgreSQL, SQL, Performance 12 Common Mistakes and Missed Optimization Opportunities in SQL Made by Developers and Non-Developers 22 December 2018 PostgreSQL,
150-1	38291-38294	Why	
150-2	38295-38300	TOAST	
150-3	38301-38303	is	
150-4	38304-38307	the	
150-5	38308-38312	best	
150-6	38313-38318	thing	
150-7	38319-38324	since	
150-8	38325-38331	sliced	
150-9	38332-38337	bread	
150-10	38338-38340	21	
150-11	38341-38349	November	
150-12	38350-38354	2019	
150-13	38355-38365	PostgreSQL	
150-14	38365-38366	,	
150-15	38367-38370	SQL	
150-16	38370-38371	,	
150-17	38372-38383	Performance	
150-18	38384-38386	12	
150-19	38387-38393	Common	
150-20	38394-38402	Mistakes	
150-21	38403-38406	and	
150-22	38407-38413	Missed	
150-23	38414-38426	Optimization	
150-24	38427-38440	Opportunities	
150-25	38441-38443	in	
150-26	38444-38447	SQL	
150-27	38448-38452	Made	
150-28	38453-38455	by	
150-29	38456-38466	Developers	
150-30	38467-38470	and	
150-31	38471-38485	Non-Developers	
150-32	38486-38488	22	
150-33	38489-38497	December	
150-34	38498-38502	2018	
150-35	38503-38513	PostgreSQL	
150-36	38513-38514	,	

#Text=SQL, Performance How We Solved a Storage Problem in PostgreSQL Without Adding a Single Byte of Storage A short story about a storage-heavy query and the silver bullet that solved the issue 17 September 2018 PostgreSQL,
151-1	38515-38518	SQL	
151-2	38518-38519	,	
151-3	38520-38531	Performance	
151-4	38532-38535	How	
151-5	38536-38538	We	
151-6	38539-38545	Solved	
151-7	38546-38547	a	
151-8	38548-38555	Storage	
151-9	38556-38563	Problem	
151-10	38564-38566	in	
151-11	38567-38577	PostgreSQL	
151-12	38578-38585	Without	
151-13	38586-38592	Adding	
151-14	38593-38594	a	
151-15	38595-38601	Single	
151-16	38602-38606	Byte	
151-17	38607-38609	of	
151-18	38610-38617	Storage	
151-19	38618-38619	A	
151-20	38620-38625	short	
151-21	38626-38631	story	
151-22	38632-38637	about	
151-23	38638-38639	a	
151-24	38640-38653	storage-heavy	
151-25	38654-38659	query	
151-26	38660-38663	and	
151-27	38664-38667	the	
151-28	38668-38674	silver	
151-29	38675-38681	bullet	
151-30	38682-38686	that	
151-31	38687-38693	solved	
151-32	38694-38697	the	
151-33	38698-38703	issue	
151-34	38704-38706	17	
151-35	38707-38716	September	
151-36	38717-38721	2018	
151-37	38722-38732	PostgreSQL	
151-38	38732-38733	,	
