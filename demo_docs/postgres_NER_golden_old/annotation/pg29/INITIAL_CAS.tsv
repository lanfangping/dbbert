#FORMAT=WebAnno TSV 3.3


#Text=OnGres | Boost your User-Defined Functions in PostgreSQL Resources Blog Services Professional Services Consulting Training Products StackGres PostgresqlCO.NF
1-1	0-6	OnGres	
1-2	7-8	|	
1-3	9-14	Boost	
1-4	15-19	your	
1-5	20-32	User-Defined	
1-6	33-42	Functions	
1-7	43-45	in	
1-8	46-56	PostgreSQL	
1-9	57-66	Resources	
1-10	67-71	Blog	
1-11	72-80	Services	
1-12	81-93	Professional	
1-13	94-102	Services	
1-14	103-113	Consulting	
1-15	114-122	Training	
1-16	123-131	Products	
1-17	132-141	StackGres	
1-18	142-157	PostgresqlCO.NF	

#Text=About Contact Post Boost your User-Defined Functions in PostgreSQL Emanuel Calvo Anthony Sotolongo Feb 5, 2021 · 9 min read postgresql performance Share this post
2-1	158-163	About	
2-2	164-171	Contact	
2-3	172-176	Post	
2-4	177-182	Boost	
2-5	183-187	your	
2-6	188-200	User-Defined	
2-7	201-210	Functions	
2-8	211-213	in	
2-9	214-224	PostgreSQL	
2-10	225-232	Emanuel	
2-11	233-238	Calvo	
2-12	239-246	Anthony	
2-13	247-256	Sotolongo	
2-14	257-260	Feb	
2-15	261-262	5	
2-16	262-263	,	
2-17	264-268	2021	
2-18	269-270	·	
2-19	271-272	9	
2-20	273-276	min	
2-21	277-281	read	
2-22	282-292	postgresql	
2-23	293-304	performance	
2-24	305-310	Share	
2-25	311-315	this	
2-26	316-320	post	

#Text=Emanuel Calvo Database Engineer Anthony Sotolongo Database Engineer Introduction
3-1	321-328	Emanuel	
3-2	329-334	Calvo	
3-3	335-343	Database	
3-4	344-352	Engineer	
3-5	353-360	Anthony	
3-6	361-370	Sotolongo	
3-7	371-379	Database	
3-8	380-388	Engineer	
3-9	389-401	Introduction	

#Text=Using the RDBMS only to store data is restricting the full potential of the database systems, which were designed for server-side processing and provide other options besides being a data container. Some of these options are stored procedures and functions that allow the user to write server-side code, using the principle of bringing computation to data, avoiding large datasets round trips and taking advantage of server resources. PostgreSQL allows programming inside the database since the beginning, with User Defined Functions (UDFs). These functions can be written in several languages like SQL, PL/pgsql, PL/Python, PL/Perl, and others. But the most common are the first two mentioned: SQL and PL/pgsql. However, there may be “anti-patterns” in your code within functions and they can affect performance. This blog will show the reader some simple tips, examples and explanations about increasing performance in server-side processing with User Defined Functions in PostgreSQL. It is also important to clarify that the intention of this post isn’t to discuss whether Business Logic should be placed, but only how you can take advantage of the resources of the database server. Avoid these antipatterns in your PL/pgsql’s code Use PL/pgsql functions for simple SQL statements
4-1	402-407	Using	
4-2	408-411	the	
4-3	412-417	RDBMS	
4-4	418-422	only	
4-5	423-425	to	
4-6	426-431	store	
4-7	432-436	data	
4-8	437-439	is	
4-9	440-451	restricting	
4-10	452-455	the	
4-11	456-460	full	
4-12	461-470	potential	
4-13	471-473	of	
4-14	474-477	the	
4-15	478-486	database	
4-16	487-494	systems	
4-17	494-495	,	
4-18	496-501	which	
4-19	502-506	were	
4-20	507-515	designed	
4-21	516-519	for	
4-22	520-531	server-side	
4-23	532-542	processing	
4-24	543-546	and	
4-25	547-554	provide	
4-26	555-560	other	
4-27	561-568	options	
4-28	569-576	besides	
4-29	577-582	being	
4-30	583-584	a	
4-31	585-589	data	
4-32	590-599	container	
4-33	599-600	.	
4-34	601-605	Some	
4-35	606-608	of	
4-36	609-614	these	
4-37	615-622	options	
4-38	623-626	are	
4-39	627-633	stored	
4-40	634-644	procedures	
4-41	645-648	and	
4-42	649-658	functions	
4-43	659-663	that	
4-44	664-669	allow	
4-45	670-673	the	
4-46	674-678	user	
4-47	679-681	to	
4-48	682-687	write	
4-49	688-699	server-side	
4-50	700-704	code	
4-51	704-705	,	
4-52	706-711	using	
4-53	712-715	the	
4-54	716-725	principle	
4-55	726-728	of	
4-56	729-737	bringing	
4-57	738-749	computation	
4-58	750-752	to	
4-59	753-757	data	
4-60	757-758	,	
4-61	759-767	avoiding	
4-62	768-773	large	
4-63	774-782	datasets	
4-64	783-788	round	
4-65	789-794	trips	
4-66	795-798	and	
4-67	799-805	taking	
4-68	806-815	advantage	
4-69	816-818	of	
4-70	819-825	server	
4-71	826-835	resources	
4-72	835-836	.	
4-73	837-847	PostgreSQL	
4-74	848-854	allows	
4-75	855-866	programming	
4-76	867-873	inside	
4-77	874-877	the	
4-78	878-886	database	
4-79	887-892	since	
4-80	893-896	the	
4-81	897-906	beginning	
4-82	906-907	,	
4-83	908-912	with	
4-84	913-917	User	
4-85	918-925	Defined	
4-86	926-935	Functions	
4-87	936-937	(	
4-88	937-941	UDFs	
4-89	941-942	)	
4-90	942-943	.	
4-91	944-949	These	
4-92	950-959	functions	
4-93	960-963	can	
4-94	964-966	be	
4-95	967-974	written	
4-96	975-977	in	
4-97	978-985	several	
4-98	986-995	languages	
4-99	996-1000	like	
4-100	1001-1004	SQL	
4-101	1004-1005	,	
4-102	1006-1008	PL	
4-103	1008-1009	/	
4-104	1009-1014	pgsql	
4-105	1014-1015	,	
4-106	1016-1018	PL	
4-107	1018-1019	/	
4-108	1019-1025	Python	
4-109	1025-1026	,	
4-110	1027-1029	PL	
4-111	1029-1030	/	
4-112	1030-1034	Perl	
4-113	1034-1035	,	
4-114	1036-1039	and	
4-115	1040-1046	others	
4-116	1046-1047	.	
4-117	1048-1051	But	
4-118	1052-1055	the	
4-119	1056-1060	most	
4-120	1061-1067	common	
4-121	1068-1071	are	
4-122	1072-1075	the	
4-123	1076-1081	first	
4-124	1082-1085	two	
4-125	1086-1095	mentioned	
4-126	1095-1096	:	
4-127	1097-1100	SQL	
4-128	1101-1104	and	
4-129	1105-1107	PL	
4-130	1107-1108	/	
4-131	1108-1113	pgsql	
4-132	1113-1114	.	
4-133	1115-1122	However	
4-134	1122-1123	,	
4-135	1124-1129	there	
4-136	1130-1133	may	
4-137	1134-1136	be	
4-138	1137-1138	“	
4-139	1138-1151	anti-patterns	
4-140	1151-1152	”	
4-141	1153-1155	in	
4-142	1156-1160	your	
4-143	1161-1165	code	
4-144	1166-1172	within	
4-145	1173-1182	functions	
4-146	1183-1186	and	
4-147	1187-1191	they	
4-148	1192-1195	can	
4-149	1196-1202	affect	
4-150	1203-1214	performance	
4-151	1214-1215	.	
4-152	1216-1220	This	
4-153	1221-1225	blog	
4-154	1226-1230	will	
4-155	1231-1235	show	
4-156	1236-1239	the	
4-157	1240-1246	reader	
4-158	1247-1251	some	
4-159	1252-1258	simple	
4-160	1259-1263	tips	
4-161	1263-1264	,	
4-162	1265-1273	examples	
4-163	1274-1277	and	
4-164	1278-1290	explanations	
4-165	1291-1296	about	
4-166	1297-1307	increasing	
4-167	1308-1319	performance	
4-168	1320-1322	in	
4-169	1323-1334	server-side	
4-170	1335-1345	processing	
4-171	1346-1350	with	
4-172	1351-1355	User	
4-173	1356-1363	Defined	
4-174	1364-1373	Functions	
4-175	1374-1376	in	
4-176	1377-1387	PostgreSQL	
4-177	1387-1388	.	
4-178	1389-1391	It	
4-179	1392-1394	is	
4-180	1395-1399	also	
4-181	1400-1409	important	
4-182	1410-1412	to	
4-183	1413-1420	clarify	
4-184	1421-1425	that	
4-185	1426-1429	the	
4-186	1430-1439	intention	
4-187	1440-1442	of	
4-188	1443-1447	this	
4-189	1448-1452	post	
4-190	1453-1456	isn	
4-191	1456-1457	’	
4-192	1457-1458	t	
4-193	1459-1461	to	
4-194	1462-1469	discuss	
4-195	1470-1477	whether	
4-196	1478-1486	Business	
4-197	1487-1492	Logic	
4-198	1493-1499	should	
4-199	1500-1502	be	
4-200	1503-1509	placed	
4-201	1509-1510	,	
4-202	1511-1514	but	
4-203	1515-1519	only	
4-204	1520-1523	how	
4-205	1524-1527	you	
4-206	1528-1531	can	
4-207	1532-1536	take	
4-208	1537-1546	advantage	
4-209	1547-1549	of	
4-210	1550-1553	the	
4-211	1554-1563	resources	
4-212	1564-1566	of	
4-213	1567-1570	the	
4-214	1571-1579	database	
4-215	1580-1586	server	
4-216	1586-1587	.	
4-217	1588-1593	Avoid	
4-218	1594-1599	these	
4-219	1600-1612	antipatterns	
4-220	1613-1615	in	
4-221	1616-1620	your	
4-222	1621-1623	PL	
4-223	1623-1624	/	
4-224	1624-1629	pgsql	
4-225	1629-1630	’	
4-226	1630-1631	s	
4-227	1632-1636	code	
4-228	1637-1640	Use	
4-229	1641-1643	PL	
4-230	1643-1644	/	
4-231	1644-1649	pgsql	
4-232	1650-1659	functions	
4-233	1660-1663	for	
4-234	1664-1670	simple	
4-235	1671-1674	SQL	
4-236	1675-1685	statements	

#Text=SQL functions, in certain conditions, can have their function bodies inlined into the main query directly. This can be a performance advantage because the function code can be analyzed by the planner, which can apply some optimizations. When can I apply this pattern? When you have a query or group of simple queries that do not require intermediate analysis/process before returning the result. On the other hand, writing these simple SQL sentences in PL/pgsql requires overhead for the PL/pgsql compiler. Example: 1- CREATE OR REPLACE FUNCTION hemisphere_sql (character varying) RETURNS character varying LANGUAGE sql AS $$ SELECT
5-1	1686-1689	SQL	
5-2	1690-1699	functions	
5-3	1699-1700	,	
5-4	1701-1703	in	
5-5	1704-1711	certain	
5-6	1712-1722	conditions	
5-7	1722-1723	,	
5-8	1724-1727	can	
5-9	1728-1732	have	
5-10	1733-1738	their	
5-11	1739-1747	function	
5-12	1748-1754	bodies	
5-13	1755-1762	inlined	
5-14	1763-1767	into	
5-15	1768-1771	the	
5-16	1772-1776	main	
5-17	1777-1782	query	
5-18	1783-1791	directly	
5-19	1791-1792	.	
5-20	1793-1797	This	
5-21	1798-1801	can	
5-22	1802-1804	be	
5-23	1805-1806	a	
5-24	1807-1818	performance	
5-25	1819-1828	advantage	
5-26	1829-1836	because	
5-27	1837-1840	the	
5-28	1841-1849	function	
5-29	1850-1854	code	
5-30	1855-1858	can	
5-31	1859-1861	be	
5-32	1862-1870	analyzed	
5-33	1871-1873	by	
5-34	1874-1877	the	
5-35	1878-1885	planner	
5-36	1885-1886	,	
5-37	1887-1892	which	
5-38	1893-1896	can	
5-39	1897-1902	apply	
5-40	1903-1907	some	
5-41	1908-1921	optimizations	
5-42	1921-1922	.	
5-43	1923-1927	When	
5-44	1928-1931	can	
5-45	1932-1933	I	
5-46	1934-1939	apply	
5-47	1940-1944	this	
5-48	1945-1952	pattern	
5-49	1952-1953	?	
5-50	1954-1958	When	
5-51	1959-1962	you	
5-52	1963-1967	have	
5-53	1968-1969	a	
5-54	1970-1975	query	
5-55	1976-1978	or	
5-56	1979-1984	group	
5-57	1985-1987	of	
5-58	1988-1994	simple	
5-59	1995-2002	queries	
5-60	2003-2007	that	
5-61	2008-2010	do	
5-62	2011-2014	not	
5-63	2015-2022	require	
5-64	2023-2035	intermediate	
5-65	2036-2044	analysis	
5-66	2044-2045	/	
5-67	2045-2052	process	
5-68	2053-2059	before	
5-69	2060-2069	returning	
5-70	2070-2073	the	
5-71	2074-2080	result	
5-72	2080-2081	.	
5-73	2082-2084	On	
5-74	2085-2088	the	
5-75	2089-2094	other	
5-76	2095-2099	hand	
5-77	2099-2100	,	
5-78	2101-2108	writing	
5-79	2109-2114	these	
5-80	2115-2121	simple	
5-81	2122-2125	SQL	
5-82	2126-2135	sentences	
5-83	2136-2138	in	
5-84	2139-2141	PL	
5-85	2141-2142	/	
5-86	2142-2147	pgsql	
5-87	2148-2156	requires	
5-88	2157-2165	overhead	
5-89	2166-2169	for	
5-90	2170-2173	the	
5-91	2174-2176	PL	
5-92	2176-2177	/	
5-93	2177-2182	pgsql	
5-94	2183-2191	compiler	
5-95	2191-2192	.	
5-96	2193-2200	Example	
5-97	2200-2201	:	
5-98	2202-2203	1	
5-99	2203-2204	-	
5-100	2205-2211	CREATE	
5-101	2212-2214	OR	
5-102	2215-2222	REPLACE	
5-103	2223-2231	FUNCTION	
5-104	2232-2246	hemisphere_sql	
5-105	2247-2248	(	
5-106	2248-2257	character	
5-107	2258-2265	varying	
5-108	2265-2266	)	
5-109	2267-2274	RETURNS	
5-110	2275-2284	character	
5-111	2285-2292	varying	
5-112	2293-2301	LANGUAGE	
5-113	2302-2305	sql	
5-114	2306-2308	AS	
5-115	2309-2310	$	
5-116	2310-2311	$	
5-117	2312-2318	SELECT	

#Text=CASE WHEN $1 IN ('UK', 'Germany', 'Japan', 'US', 'China', 'Canada', 'Russia', 'France') THEN 'North' WHEN $1 IN ('South Africa', 'Australia', 'Chile') THEN 'South' ELSE 'unknown' END $$;
6-1	2319-2323	CASE	
6-2	2324-2328	WHEN	
6-3	2329-2331	$1	
6-4	2332-2334	IN	
6-5	2335-2336	(	
6-6	2336-2337	'	
6-7	2337-2339	UK	
6-8	2339-2340	'	
6-9	2340-2341	,	
6-10	2342-2343	'	
6-11	2343-2350	Germany	
6-12	2350-2351	'	
6-13	2351-2352	,	
6-14	2353-2354	'	
6-15	2354-2359	Japan	
6-16	2359-2360	'	
6-17	2360-2361	,	
6-18	2362-2363	'	
6-19	2363-2365	US	
6-20	2365-2366	'	
6-21	2366-2367	,	
6-22	2368-2369	'	
6-23	2369-2374	China	
6-24	2374-2375	'	
6-25	2375-2376	,	
6-26	2377-2378	'	
6-27	2378-2384	Canada	
6-28	2384-2385	'	
6-29	2385-2386	,	
6-30	2387-2388	'	
6-31	2388-2394	Russia	
6-32	2394-2395	'	
6-33	2395-2396	,	
6-34	2397-2398	'	
6-35	2398-2404	France	
6-36	2404-2405	'	
6-37	2405-2406	)	
6-38	2407-2411	THEN	
6-39	2412-2413	'	
6-40	2413-2418	North	
6-41	2418-2419	'	
6-42	2420-2424	WHEN	
6-43	2425-2427	$1	
6-44	2428-2430	IN	
6-45	2431-2432	(	
6-46	2432-2433	'	
6-47	2433-2438	South	
6-48	2439-2445	Africa	
6-49	2445-2446	'	
6-50	2446-2447	,	
6-51	2448-2449	'	
6-52	2449-2458	Australia	
6-53	2458-2459	'	
6-54	2459-2460	,	
6-55	2461-2462	'	
6-56	2462-2467	Chile	
6-57	2467-2468	'	
6-58	2468-2469	)	
6-59	2470-2474	THEN	
6-60	2475-2476	'	
6-61	2476-2481	South	
6-62	2481-2482	'	
6-63	2483-2487	ELSE	
6-64	2488-2489	'	
6-65	2489-2496	unknown	
6-66	2496-2497	'	
6-67	2498-2501	END	
6-68	2502-2503	$	
6-69	2503-2504	$	
6-70	2504-2505	;	

#Text=2- CREATE OR REPLACE FUNCTION hemisphere_plpgsql (character varying) RETURNS character varying LANGUAGE plpgsql AS $$ DECLARE result character varying; BEGIN result:= ( SELECT
7-1	2506-2507	2	
7-2	2507-2508	-	
7-3	2509-2515	CREATE	
7-4	2516-2518	OR	
7-5	2519-2526	REPLACE	
7-6	2527-2535	FUNCTION	
7-7	2536-2554	hemisphere_plpgsql	
7-8	2555-2556	(	
7-9	2556-2565	character	
7-10	2566-2573	varying	
7-11	2573-2574	)	
7-12	2575-2582	RETURNS	
7-13	2583-2592	character	
7-14	2593-2600	varying	
7-15	2601-2609	LANGUAGE	
7-16	2610-2617	plpgsql	
7-17	2618-2620	AS	
7-18	2621-2622	$	
7-19	2622-2623	$	
7-20	2624-2631	DECLARE	
7-21	2632-2638	result	
7-22	2639-2648	character	
7-23	2649-2656	varying	
7-24	2656-2657	;	
7-25	2658-2663	BEGIN	
7-26	2664-2670	result	
7-27	2670-2671	:	
7-28	2671-2672	=	
7-29	2673-2674	(	
7-30	2675-2681	SELECT	

#Text=CASE WHEN $1 IN ('UK', 'Germany', 'Japan', 'US', 'China', 'Canada', 'Russia', 'France') THEN 'North' WHEN $1 IN ('South Africa', 'Australia', 'Chile') THEN 'South' ELSE 'unknown' END); RETURN result; END;
8-1	2682-2686	CASE	
8-2	2687-2691	WHEN	
8-3	2692-2694	$1	
8-4	2695-2697	IN	
8-5	2698-2699	(	
8-6	2699-2700	'	
8-7	2700-2702	UK	
8-8	2702-2703	'	
8-9	2703-2704	,	
8-10	2705-2706	'	
8-11	2706-2713	Germany	
8-12	2713-2714	'	
8-13	2714-2715	,	
8-14	2716-2717	'	
8-15	2717-2722	Japan	
8-16	2722-2723	'	
8-17	2723-2724	,	
8-18	2725-2726	'	
8-19	2726-2728	US	
8-20	2728-2729	'	
8-21	2729-2730	,	
8-22	2731-2732	'	
8-23	2732-2737	China	
8-24	2737-2738	'	
8-25	2738-2739	,	
8-26	2740-2741	'	
8-27	2741-2747	Canada	
8-28	2747-2748	'	
8-29	2748-2749	,	
8-30	2750-2751	'	
8-31	2751-2757	Russia	
8-32	2757-2758	'	
8-33	2758-2759	,	
8-34	2760-2761	'	
8-35	2761-2767	France	
8-36	2767-2768	'	
8-37	2768-2769	)	
8-38	2770-2774	THEN	
8-39	2775-2776	'	
8-40	2776-2781	North	
8-41	2781-2782	'	
8-42	2783-2787	WHEN	
8-43	2788-2790	$1	
8-44	2791-2793	IN	
8-45	2794-2795	(	
8-46	2795-2796	'	
8-47	2796-2801	South	
8-48	2802-2808	Africa	
8-49	2808-2809	'	
8-50	2809-2810	,	
8-51	2811-2812	'	
8-52	2812-2821	Australia	
8-53	2821-2822	'	
8-54	2822-2823	,	
8-55	2824-2825	'	
8-56	2825-2830	Chile	
8-57	2830-2831	'	
8-58	2831-2832	)	
8-59	2833-2837	THEN	
8-60	2838-2839	'	
8-61	2839-2844	South	
8-62	2844-2845	'	
8-63	2846-2850	ELSE	
8-64	2851-2852	'	
8-65	2852-2859	unknown	
8-66	2859-2860	'	
8-67	2861-2864	END	
8-68	2864-2865	)	
8-69	2865-2866	;	
8-70	2867-2873	RETURN	
8-71	2874-2880	result	
8-72	2880-2881	;	
8-73	2882-2885	END	
8-74	2885-2886	;	

#Text=$$; 1- EXPLAIN (ANALYZE,VERBOSE ) SELECT hemisphere_sql(country) FROM customers; Seq Scan on public.customers
9-1	2887-2888	$	
9-2	2888-2889	$	
9-3	2889-2890	;	
9-4	2891-2892	1	
9-5	2892-2893	-	
9-6	2894-2901	EXPLAIN	
9-7	2902-2903	(	
9-8	2903-2910	ANALYZE	
9-9	2910-2911	,	
9-10	2911-2918	VERBOSE	
9-11	2919-2920	)	
9-12	2921-2927	SELECT	
9-13	2928-2942	hemisphere_sql	
9-14	2942-2943	(	
9-15	2943-2950	country	
9-16	2950-2951	)	
9-17	2952-2956	FROM	
9-18	2957-2966	customers	
9-19	2966-2967	;	
9-20	2968-2971	Seq	
9-21	2972-2976	Scan	
9-22	2977-2979	on	
9-23	2980-2996	public.customers	

#Text=(cost=0.00..963.00 rows=20000 width=32) (actual time=0.039..29.309 rows=20000 loops=1) Output: CASE WHEN ((country)::text = ANY ('{UK,Germany,Japan,US,China,Canada,Russia,France}'::text[])) THEN 'North'::text WHEN ((country)::text = ANY ('{"South Africa",Australia,Chile}'::text[])) THEN 'South'::text ELSE 'unknown'::text END
10-1	2997-2998	(	
10-2	2998-3002	cost	
10-3	3002-3003	=	
10-4	3003-3007	0.00	
10-5	3007-3008	.	
10-6	3008-3015	.963.00	
10-7	3016-3020	rows	
10-8	3020-3021	=	
10-9	3021-3026	20000	
10-10	3027-3032	width	
10-11	3032-3033	=	
10-12	3033-3035	32	
10-13	3035-3036	)	
10-14	3037-3038	(	
10-15	3038-3044	actual	
10-16	3045-3049	time	
10-17	3049-3050	=	
10-18	3050-3055	0.039	
10-19	3055-3056	.	
10-20	3056-3063	.29.309	
10-21	3064-3068	rows	
10-22	3068-3069	=	
10-23	3069-3074	20000	
10-24	3075-3080	loops	
10-25	3080-3081	=	
10-26	3081-3082	1	
10-27	3082-3083	)	
10-28	3084-3090	Output	
10-29	3090-3091	:	
10-30	3092-3096	CASE	
10-31	3097-3101	WHEN	
10-32	3102-3103	(	
10-33	3103-3104	(	
10-34	3104-3111	country	
10-35	3111-3112	)	
10-36	3112-3113	:	
10-37	3113-3114	:	
10-38	3114-3118	text	
10-39	3119-3120	=	
10-40	3121-3124	ANY	
10-41	3125-3126	(	
10-42	3126-3127	'	
10-43	3127-3128	{	
10-44	3128-3130	UK	
10-45	3130-3131	,	
10-46	3131-3138	Germany	
10-47	3138-3139	,	
10-48	3139-3144	Japan	
10-49	3144-3145	,	
10-50	3145-3147	US	
10-51	3147-3148	,	
10-52	3148-3153	China	
10-53	3153-3154	,	
10-54	3154-3160	Canada	
10-55	3160-3161	,	
10-56	3161-3167	Russia	
10-57	3167-3168	,	
10-58	3168-3174	France	
10-59	3174-3175	}	
10-60	3175-3176	'	
10-61	3176-3177	:	
10-62	3177-3178	:	
10-63	3178-3182	text	
10-64	3182-3183	[	
10-65	3183-3184	]	
10-66	3184-3185	)	
10-67	3185-3186	)	
10-68	3187-3191	THEN	
10-69	3192-3193	'	
10-70	3193-3198	North	
10-71	3198-3199	'	
10-72	3199-3200	:	
10-73	3200-3201	:	
10-74	3201-3205	text	
10-75	3206-3210	WHEN	
10-76	3211-3212	(	
10-77	3212-3213	(	
10-78	3213-3220	country	
10-79	3220-3221	)	
10-80	3221-3222	:	
10-81	3222-3223	:	
10-82	3223-3227	text	
10-83	3228-3229	=	
10-84	3230-3233	ANY	
10-85	3234-3235	(	
10-86	3235-3236	'	
10-87	3236-3237	{	
10-88	3237-3238	"	
10-89	3238-3243	South	
10-90	3244-3250	Africa	
10-91	3250-3251	"	
10-92	3251-3252	,	
10-93	3252-3261	Australia	
10-94	3261-3262	,	
10-95	3262-3267	Chile	
10-96	3267-3268	}	
10-97	3268-3269	'	
10-98	3269-3270	:	
10-99	3270-3271	:	
10-100	3271-3275	text	
10-101	3275-3276	[	
10-102	3276-3277	]	
10-103	3277-3278	)	
10-104	3278-3279	)	
10-105	3280-3284	THEN	
10-106	3285-3286	'	
10-107	3286-3291	South	
10-108	3291-3292	'	
10-109	3292-3293	:	
10-110	3293-3294	:	
10-111	3294-3298	text	
10-112	3299-3303	ELSE	
10-113	3304-3305	'	
10-114	3305-3312	unknown	
10-115	3312-3313	'	
10-116	3313-3314	:	
10-117	3314-3315	:	
10-118	3315-3319	text	
10-119	3320-3323	END	

#Text=Planning Time: 0.458 ms Execution Time: 32.306 ms 2-EXPLAIN (ANALYZE,VERBOSE ) SELECT hemisphere_plpgsql(country) FROM customers; Seq Scan on public.customers
11-1	3324-3332	Planning	
11-2	3333-3337	Time	
11-3	3337-3338	:	
11-4	3339-3344	0.458	
11-5	3345-3347	ms	
11-6	3348-3357	Execution	
11-7	3358-3362	Time	
11-8	3362-3363	:	
11-9	3364-3370	32.306	
11-10	3371-3373	ms	
11-11	3374-3375	2	
11-12	3375-3376	-	
11-13	3376-3383	EXPLAIN	
11-14	3384-3385	(	
11-15	3385-3392	ANALYZE	
11-16	3392-3393	,	
11-17	3393-3400	VERBOSE	
11-18	3401-3402	)	
11-19	3403-3409	SELECT	
11-20	3410-3428	hemisphere_plpgsql	
11-21	3428-3429	(	
11-22	3429-3436	country	
11-23	3436-3437	)	
11-24	3438-3442	FROM	
11-25	3443-3452	customers	
11-26	3452-3453	;	
11-27	3454-3457	Seq	
11-28	3458-3462	Scan	
11-29	3463-3465	on	
11-30	3466-3482	public.customers	

#Text=(cost=0.00..5688.00 rows=20000 width=32) (actual time=0.654..174.685 rows=20000 loops=1) Output: hemisphere_plpgsql(country) Planning Time: 0.082 ms Execution Time: 175.972 ms As we can see in the outputs of the explains commands, on first EXPLAIN,
12-1	3483-3484	(	
12-2	3484-3488	cost	
12-3	3488-3489	=	
12-4	3489-3493	0.00	
12-5	3493-3494	.	
12-6	3494-3502	.5688.00	
12-7	3503-3507	rows	
12-8	3507-3508	=	
12-9	3508-3513	20000	
12-10	3514-3519	width	
12-11	3519-3520	=	
12-12	3520-3522	32	
12-13	3522-3523	)	
12-14	3524-3525	(	
12-15	3525-3531	actual	
12-16	3532-3536	time	
12-17	3536-3537	=	
12-18	3537-3542	0.654	
12-19	3542-3543	.	
12-20	3543-3551	.174.685	
12-21	3552-3556	rows	
12-22	3556-3557	=	
12-23	3557-3562	20000	
12-24	3563-3568	loops	
12-25	3568-3569	=	
12-26	3569-3570	1	
12-27	3570-3571	)	
12-28	3572-3578	Output	
12-29	3578-3579	:	
12-30	3580-3598	hemisphere_plpgsql	
12-31	3598-3599	(	
12-32	3599-3606	country	
12-33	3606-3607	)	
12-34	3608-3616	Planning	
12-35	3617-3621	Time	
12-36	3621-3622	:	
12-37	3623-3628	0.082	
12-38	3629-3631	ms	
12-39	3632-3641	Execution	
12-40	3642-3646	Time	
12-41	3646-3647	:	
12-42	3648-3655	175.972	
12-43	3656-3658	ms	
12-44	3659-3661	As	
12-45	3662-3664	we	
12-46	3665-3668	can	
12-47	3669-3672	see	
12-48	3673-3675	in	
12-49	3676-3679	the	
12-50	3680-3687	outputs	
12-51	3688-3690	of	
12-52	3691-3694	the	
12-53	3695-3703	explains	
12-54	3704-3712	commands	
12-55	3712-3713	,	
12-56	3714-3716	on	
12-57	3717-3722	first	
12-58	3723-3730	EXPLAIN	
12-59	3730-3731	,	

#Text=output tag has the SQL code that belongs to SQL function, which means that this code is inlined into the calling query, rather than call the function, as the second EXPLAIN, this can improve the performance of our queries. Unnecessary usage of SELECT INTO clause
13-1	3732-3738	output	
13-2	3739-3742	tag	
13-3	3743-3746	has	
13-4	3747-3750	the	
13-5	3751-3754	SQL	
13-6	3755-3759	code	
13-7	3760-3764	that	
13-8	3765-3772	belongs	
13-9	3773-3775	to	
13-10	3776-3779	SQL	
13-11	3780-3788	function	
13-12	3788-3789	,	
13-13	3790-3795	which	
13-14	3796-3801	means	
13-15	3802-3806	that	
13-16	3807-3811	this	
13-17	3812-3816	code	
13-18	3817-3819	is	
13-19	3820-3827	inlined	
13-20	3828-3832	into	
13-21	3833-3836	the	
13-22	3837-3844	calling	
13-23	3845-3850	query	
13-24	3850-3851	,	
13-25	3852-3858	rather	
13-26	3859-3863	than	
13-27	3864-3868	call	
13-28	3869-3872	the	
13-29	3873-3881	function	
13-30	3881-3882	,	
13-31	3883-3885	as	
13-32	3886-3889	the	
13-33	3890-3896	second	
13-34	3897-3904	EXPLAIN	
13-35	3904-3905	,	
13-36	3906-3910	this	
13-37	3911-3914	can	
13-38	3915-3922	improve	
13-39	3923-3926	the	
13-40	3927-3938	performance	
13-41	3939-3941	of	
13-42	3942-3945	our	
13-43	3946-3953	queries	
13-44	3953-3954	.	
13-45	3955-3966	Unnecessary	
13-46	3967-3972	usage	
13-47	3973-3975	of	
13-48	3976-3982	SELECT	
13-49	3983-3987	INTO	
13-50	3988-3994	clause	

#Text=Inside the PL/pgsql function, it is a bit more costly to assign a value using SELECT INTO than a simple assignment using :=. When can I apply this? When the := operator can replace the INTO clause. Example: 1- CREATE OR REPLACE FUNCTION simple () RETURNS void
14-1	3995-4001	Inside	
14-2	4002-4005	the	
14-3	4006-4008	PL	
14-4	4008-4009	/	
14-5	4009-4014	pgsql	
14-6	4015-4023	function	
14-7	4023-4024	,	
14-8	4025-4027	it	
14-9	4028-4030	is	
14-10	4031-4032	a	
14-11	4033-4036	bit	
14-12	4037-4041	more	
14-13	4042-4048	costly	
14-14	4049-4051	to	
14-15	4052-4058	assign	
14-16	4059-4060	a	
14-17	4061-4066	value	
14-18	4067-4072	using	
14-19	4073-4079	SELECT	
14-20	4080-4084	INTO	
14-21	4085-4089	than	
14-22	4090-4091	a	
14-23	4092-4098	simple	
14-24	4099-4109	assignment	
14-25	4110-4115	using	
14-26	4116-4117	:	
14-27	4117-4118	=	
14-28	4118-4119	.	
14-29	4120-4124	When	
14-30	4125-4128	can	
14-31	4129-4130	I	
14-32	4131-4136	apply	
14-33	4137-4141	this	
14-34	4141-4142	?	
14-35	4143-4147	When	
14-36	4148-4151	the	
14-37	4152-4153	:	
14-38	4153-4154	=	
14-39	4155-4163	operator	
14-40	4164-4167	can	
14-41	4168-4175	replace	
14-42	4176-4179	the	
14-43	4180-4184	INTO	
14-44	4185-4191	clause	
14-45	4191-4192	.	
14-46	4193-4200	Example	
14-47	4200-4201	:	
14-48	4202-4203	1	
14-49	4203-4204	-	
14-50	4205-4211	CREATE	
14-51	4212-4214	OR	
14-52	4215-4222	REPLACE	
14-53	4223-4231	FUNCTION	
14-54	4232-4238	simple	
14-55	4239-4240	(	
14-56	4240-4241	)	
14-57	4242-4249	RETURNS	
14-58	4250-4254	void	

#Text=AS $$ DECLARE s int DEFAULT 0; BEGIN FOR i IN 1..10000 LOOP s := s + 1; END LOOP; END;
15-1	4255-4257	AS	
15-2	4258-4259	$	
15-3	4259-4260	$	
15-4	4261-4268	DECLARE	
15-5	4269-4270	s	
15-6	4271-4274	int	
15-7	4275-4282	DEFAULT	
15-8	4283-4284	0	
15-9	4284-4285	;	
15-10	4286-4291	BEGIN	
15-11	4292-4295	FOR	
15-12	4296-4297	i	
15-13	4298-4300	IN	
15-14	4301-4302	1	
15-15	4302-4303	.	
15-16	4303-4309	.10000	
15-17	4310-4314	LOOP	
15-18	4315-4316	s	
15-19	4317-4318	:	
15-20	4318-4319	=	
15-21	4320-4321	s	
15-22	4322-4323	+	
15-23	4324-4325	1	
15-24	4325-4326	;	
15-25	4327-4330	END	
15-26	4331-4335	LOOP	
15-27	4335-4336	;	
15-28	4337-4340	END	
15-29	4340-4341	;	

#Text=LANGUAGE plpgsql; 2- CREATE OR REPLACE FUNCTION using_select () RETURNS void AS $$ DECLARE s int DEFAULT 0; BEGIN FOR i IN 1..10000 LOOP
16-1	4342-4350	LANGUAGE	
16-2	4351-4358	plpgsql	
16-3	4358-4359	;	
16-4	4360-4361	2	
16-5	4361-4362	-	
16-6	4363-4369	CREATE	
16-7	4370-4372	OR	
16-8	4373-4380	REPLACE	
16-9	4381-4389	FUNCTION	
16-10	4390-4402	using_select	
16-11	4403-4404	(	
16-12	4404-4405	)	
16-13	4406-4413	RETURNS	
16-14	4414-4418	void	
16-15	4419-4421	AS	
16-16	4422-4423	$	
16-17	4423-4424	$	
16-18	4425-4432	DECLARE	
16-19	4433-4434	s	
16-20	4435-4438	int	
16-21	4439-4446	DEFAULT	
16-22	4447-4448	0	
16-23	4448-4449	;	
16-24	4450-4455	BEGIN	
16-25	4456-4459	FOR	
16-26	4460-4461	i	
16-27	4462-4464	IN	
16-28	4465-4466	1	
16-29	4466-4467	.	
16-30	4467-4473	.10000	
16-31	4474-4478	LOOP	

#Text=SELECT s + 1 INTO s; END LOOP; END; LANGUAGE plpgsql; 1-SELECT simple(); Time: 16.980 ms 2-SELECT using_select();
17-1	4479-4485	SELECT	
17-2	4486-4487	s	
17-3	4488-4489	+	
17-4	4490-4491	1	
17-5	4492-4496	INTO	
17-6	4497-4498	s	
17-7	4498-4499	;	
17-8	4500-4503	END	
17-9	4504-4508	LOOP	
17-10	4508-4509	;	
17-11	4510-4513	END	
17-12	4513-4514	;	
17-13	4515-4523	LANGUAGE	
17-14	4524-4531	plpgsql	
17-15	4531-4532	;	
17-16	4533-4534	1	
17-17	4534-4535	-	
17-18	4535-4541	SELECT	
17-19	4542-4548	simple	
17-20	4548-4549	(	
17-21	4549-4550	)	
17-22	4550-4551	;	
17-23	4552-4556	Time	
17-24	4556-4557	:	
17-25	4558-4564	16.980	
17-26	4565-4567	ms	
17-27	4568-4569	2	
17-28	4569-4570	-	
17-29	4570-4576	SELECT	
17-30	4577-4589	using_select	
17-31	4589-4590	(	
17-32	4590-4591	)	
17-33	4591-4592	;	

#Text=Time: 86.931 ms Overusing RAISE clause RAISE clause can be useful to debug and show some information about the code, but it carries or has an extra load within the functions. Only use it if necessary in the production environments. Example:
18-1	4593-4597	Time	
18-2	4597-4598	:	
18-3	4599-4605	86.931	
18-4	4606-4608	ms	
18-5	4609-4618	Overusing	
18-6	4619-4624	RAISE	
18-7	4625-4631	clause	
18-8	4632-4637	RAISE	
18-9	4638-4644	clause	
18-10	4645-4648	can	
18-11	4649-4651	be	
18-12	4652-4658	useful	
18-13	4659-4661	to	
18-14	4662-4667	debug	
18-15	4668-4671	and	
18-16	4672-4676	show	
18-17	4677-4681	some	
18-18	4682-4693	information	
18-19	4694-4699	about	
18-20	4700-4703	the	
18-21	4704-4708	code	
18-22	4708-4709	,	
18-23	4710-4713	but	
18-24	4714-4716	it	
18-25	4717-4724	carries	
18-26	4725-4727	or	
18-27	4728-4731	has	
18-28	4732-4734	an	
18-29	4735-4740	extra	
18-30	4741-4745	load	
18-31	4746-4752	within	
18-32	4753-4756	the	
18-33	4757-4766	functions	
18-34	4766-4767	.	
18-35	4768-4772	Only	
18-36	4773-4776	use	
18-37	4777-4779	it	
18-38	4780-4782	if	
18-39	4783-4792	necessary	
18-40	4793-4795	in	
18-41	4796-4799	the	
18-42	4800-4810	production	
18-43	4811-4823	environments	
18-44	4823-4824	.	
18-45	4825-4832	Example	
18-46	4832-4833	:	

#Text=1- CREATE OR REPLACE FUNCTION some_sum (val int, cnt int) RETURNS int AS $$ DECLARE i int; result int:= 0; BEGIN FOR i IN 1.. $2 LOOP result:= result + $1;
19-1	4834-4835	1	
19-2	4835-4836	-	
19-3	4837-4843	CREATE	
19-4	4844-4846	OR	
19-5	4847-4854	REPLACE	
19-6	4855-4863	FUNCTION	
19-7	4864-4872	some_sum	
19-8	4873-4874	(	
19-9	4874-4877	val	
19-10	4878-4881	int	
19-11	4881-4882	,	
19-12	4883-4886	cnt	
19-13	4887-4890	int	
19-14	4890-4891	)	
19-15	4892-4899	RETURNS	
19-16	4900-4903	int	
19-17	4904-4906	AS	
19-18	4907-4908	$	
19-19	4908-4909	$	
19-20	4910-4917	DECLARE	
19-21	4918-4919	i	
19-22	4920-4923	int	
19-23	4923-4924	;	
19-24	4925-4931	result	
19-25	4932-4935	int	
19-26	4935-4936	:	
19-27	4936-4937	=	
19-28	4938-4939	0	
19-29	4939-4940	;	
19-30	4941-4946	BEGIN	
19-31	4947-4950	FOR	
19-32	4951-4952	i	
19-33	4953-4955	IN	
19-34	4956-4957	1	
19-35	4957-4958	.	
19-36	4958-4959	.	
19-37	4960-4962	$2	
19-38	4963-4967	LOOP	
19-39	4968-4974	result	
19-40	4974-4975	:	
19-41	4975-4976	=	
19-42	4977-4983	result	
19-43	4984-4985	+	
19-44	4986-4988	$1	
19-45	4988-4989	;	

#Text=END LOOP; RAISE notice 'Final value of result: %', result; RETURN result; END; LANGUAGE plpgsql; 2- CREATE OR REPLACE FUNCTION some_sum_raise (val int, cnt int)
20-1	4990-4993	END	
20-2	4994-4998	LOOP	
20-3	4998-4999	;	
20-4	5000-5005	RAISE	
20-5	5006-5012	notice	
20-6	5013-5014	'	
20-7	5014-5019	Final	
20-8	5020-5025	value	
20-9	5026-5028	of	
20-10	5029-5035	result	
20-11	5035-5036	:	
20-12	5037-5038	%	
20-13	5038-5039	'	
20-14	5039-5040	,	
20-15	5041-5047	result	
20-16	5047-5048	;	
20-17	5049-5055	RETURN	
20-18	5056-5062	result	
20-19	5062-5063	;	
20-20	5064-5067	END	
20-21	5067-5068	;	
20-22	5069-5077	LANGUAGE	
20-23	5078-5085	plpgsql	
20-24	5085-5086	;	
20-25	5087-5088	2	
20-26	5088-5089	-	
20-27	5090-5096	CREATE	
20-28	5097-5099	OR	
20-29	5100-5107	REPLACE	
20-30	5108-5116	FUNCTION	
20-31	5117-5131	some_sum_raise	
20-32	5132-5133	(	
20-33	5133-5136	val	
20-34	5137-5140	int	
20-35	5140-5141	,	
20-36	5142-5145	cnt	
20-37	5146-5149	int	
20-38	5149-5150	)	

#Text=RETURNS int AS $$ DECLARE i int; result int:= 0; BEGIN FOR i IN 1.. $2 LOOP result:= result + $1;
21-1	5151-5158	RETURNS	
21-2	5159-5162	int	
21-3	5163-5165	AS	
21-4	5166-5167	$	
21-5	5167-5168	$	
21-6	5169-5176	DECLARE	
21-7	5177-5178	i	
21-8	5179-5182	int	
21-9	5182-5183	;	
21-10	5184-5190	result	
21-11	5191-5194	int	
21-12	5194-5195	:	
21-13	5195-5196	=	
21-14	5197-5198	0	
21-15	5198-5199	;	
21-16	5200-5205	BEGIN	
21-17	5206-5209	FOR	
21-18	5210-5211	i	
21-19	5212-5214	IN	
21-20	5215-5216	1	
21-21	5216-5217	.	
21-22	5217-5218	.	
21-23	5219-5221	$2	
21-24	5222-5226	LOOP	
21-25	5227-5233	result	
21-26	5233-5234	:	
21-27	5234-5235	=	
21-28	5236-5242	result	
21-29	5243-5244	+	
21-30	5245-5247	$1	
21-31	5247-5248	;	

#Text=RAISE notice 'Temporary value of result: %', result; END LOOP; RAISE notice 'Final value of result: %', result; RETURN result; END; LANGUAGE plpgsql; 1- SELECT
22-1	5249-5254	RAISE	
22-2	5255-5261	notice	
22-3	5262-5263	'	
22-4	5263-5272	Temporary	
22-5	5273-5278	value	
22-6	5279-5281	of	
22-7	5282-5288	result	
22-8	5288-5289	:	
22-9	5290-5291	%	
22-10	5291-5292	'	
22-11	5292-5293	,	
22-12	5294-5300	result	
22-13	5300-5301	;	
22-14	5302-5305	END	
22-15	5306-5310	LOOP	
22-16	5310-5311	;	
22-17	5312-5317	RAISE	
22-18	5318-5324	notice	
22-19	5325-5326	'	
22-20	5326-5331	Final	
22-21	5332-5337	value	
22-22	5338-5340	of	
22-23	5341-5347	result	
22-24	5347-5348	:	
22-25	5349-5350	%	
22-26	5350-5351	'	
22-27	5351-5352	,	
22-28	5353-5359	result	
22-29	5359-5360	;	
22-30	5361-5367	RETURN	
22-31	5368-5374	result	
22-32	5374-5375	;	
22-33	5376-5379	END	
22-34	5379-5380	;	
22-35	5381-5389	LANGUAGE	
22-36	5390-5397	plpgsql	
22-37	5397-5398	;	
22-38	5399-5400	1	
22-39	5400-5401	-	
22-40	5402-5408	SELECT	

#Text=some_sum(3,100); NOTICE: Final value of result: 300 Time: 1.843 ms 2- SELECT some_sum_raise(3,100); NOTICE: Temporary value of result: 3 ...
23-1	5409-5417	some_sum	
23-2	5417-5418	(	
23-3	5418-5423	3,100	
23-4	5423-5424	)	
23-5	5424-5425	;	
23-6	5426-5432	NOTICE	
23-7	5432-5433	:	
23-8	5434-5439	Final	
23-9	5440-5445	value	
23-10	5446-5448	of	
23-11	5449-5455	result	
23-12	5455-5456	:	
23-13	5457-5460	300	
23-14	5461-5465	Time	
23-15	5465-5466	:	
23-16	5467-5472	1.843	
23-17	5473-5475	ms	
23-18	5476-5477	2	
23-19	5477-5478	-	
23-20	5479-5485	SELECT	
23-21	5486-5500	some_sum_raise	
23-22	5500-5501	(	
23-23	5501-5506	3,100	
23-24	5506-5507	)	
23-25	5507-5508	;	
23-26	5509-5515	NOTICE	
23-27	5515-5516	:	
23-28	5517-5526	Temporary	
23-29	5527-5532	value	
23-30	5533-5535	of	
23-31	5536-5542	result	
23-32	5542-5543	:	
23-33	5544-5545	3	
23-34	5546-5547	.	
23-35	5547-5548	.	
23-36	5548-5549	.	

#Text=NOTICE: Temporary value of result: 300 NOTICE: Final value of result: 300 Time: 8.578 ms Overusing the high-level programming coding style for SQL activities
24-1	5550-5556	NOTICE	
24-2	5556-5557	:	
24-3	5558-5567	Temporary	
24-4	5568-5573	value	
24-5	5574-5576	of	
24-6	5577-5583	result	
24-7	5583-5584	:	
24-8	5585-5588	300	
24-9	5589-5595	NOTICE	
24-10	5595-5596	:	
24-11	5597-5602	Final	
24-12	5603-5608	value	
24-13	5609-5611	of	
24-14	5612-5618	result	
24-15	5618-5619	:	
24-16	5620-5623	300	
24-17	5624-5628	Time	
24-18	5628-5629	:	
24-19	5630-5635	8.578	
24-20	5636-5638	ms	
24-21	5639-5648	Overusing	
24-22	5649-5652	the	
24-23	5653-5663	high-level	
24-24	5664-5675	programming	
24-25	5676-5682	coding	
24-26	5683-5688	style	
24-27	5689-5692	for	
24-28	5693-5696	SQL	
24-29	5697-5707	activities	

#Text=Even programmers who come from high-level programming are unaware of the benefits of SQL, and ADVANCED SQL a language that can speed up the performance considerably by avoiding unnecessary loops. For example iterating on a FOR LOOP and doing a select within can be replaced by a single query using the LATERAL clause, which essentially is like a SQL for each loop 1- CREATE OR REPLACE FUNCTION oldest_orders_by_customer (int) RETURNS SETOF t_oldest_orders_by_customer AS $$ DECLARE
25-1	5708-5712	Even	
25-2	5713-5724	programmers	
25-3	5725-5728	who	
25-4	5729-5733	come	
25-5	5734-5738	from	
25-6	5739-5749	high-level	
25-7	5750-5761	programming	
25-8	5762-5765	are	
25-9	5766-5773	unaware	
25-10	5774-5776	of	
25-11	5777-5780	the	
25-12	5781-5789	benefits	
25-13	5790-5792	of	
25-14	5793-5796	SQL	
25-15	5796-5797	,	
25-16	5798-5801	and	
25-17	5802-5810	ADVANCED	
25-18	5811-5814	SQL	
25-19	5815-5816	a	
25-20	5817-5825	language	
25-21	5826-5830	that	
25-22	5831-5834	can	
25-23	5835-5840	speed	
25-24	5841-5843	up	
25-25	5844-5847	the	
25-26	5848-5859	performance	
25-27	5860-5872	considerably	
25-28	5873-5875	by	
25-29	5876-5884	avoiding	
25-30	5885-5896	unnecessary	
25-31	5897-5902	loops	
25-32	5902-5903	.	
25-33	5904-5907	For	
25-34	5908-5915	example	
25-35	5916-5925	iterating	
25-36	5926-5928	on	
25-37	5929-5930	a	
25-38	5931-5934	FOR	
25-39	5935-5939	LOOP	
25-40	5940-5943	and	
25-41	5944-5949	doing	
25-42	5950-5951	a	
25-43	5952-5958	select	
25-44	5959-5965	within	
25-45	5966-5969	can	
25-46	5970-5972	be	
25-47	5973-5981	replaced	
25-48	5982-5984	by	
25-49	5985-5986	a	
25-50	5987-5993	single	
25-51	5994-5999	query	
25-52	6000-6005	using	
25-53	6006-6009	the	
25-54	6010-6017	LATERAL	
25-55	6018-6024	clause	
25-56	6024-6025	,	
25-57	6026-6031	which	
25-58	6032-6043	essentially	
25-59	6044-6046	is	
25-60	6047-6051	like	
25-61	6052-6053	a	
25-62	6054-6057	SQL	
25-63	6058-6061	for	
25-64	6062-6066	each	
25-65	6067-6071	loop	
25-66	6072-6073	1	
25-67	6073-6074	-	
25-68	6075-6081	CREATE	
25-69	6082-6084	OR	
25-70	6085-6092	REPLACE	
25-71	6093-6101	FUNCTION	
25-72	6102-6127	oldest_orders_by_customer	
25-73	6128-6129	(	
25-74	6129-6132	int	
25-75	6132-6133	)	
25-76	6134-6141	RETURNS	
25-77	6142-6147	SETOF	
25-78	6148-6175	t_oldest_orders_by_customer	
25-79	6176-6178	AS	
25-80	6179-6180	$	
25-81	6180-6181	$	
25-82	6182-6189	DECLARE	

#Text=c customers; result record; BEGIN FOR c IN SELECT * FROM customers c2 WHERE age > $1 loop SELECT c.firstname,o.orderid, o.orderdate , o.totalamount into result
26-1	6190-6191	c	
26-2	6192-6201	customers	
26-3	6201-6202	;	
26-4	6203-6209	result	
26-5	6210-6216	record	
26-6	6216-6217	;	
26-7	6218-6223	BEGIN	
26-8	6224-6227	FOR	
26-9	6228-6229	c	
26-10	6230-6232	IN	
26-11	6233-6239	SELECT	
26-12	6240-6241	*	
26-13	6242-6246	FROM	
26-14	6247-6256	customers	
26-15	6257-6259	c2	
26-16	6260-6265	WHERE	
26-17	6266-6269	age	
26-18	6270-6271	>	
26-19	6272-6274	$1	
26-20	6275-6279	loop	
26-21	6280-6286	SELECT	
26-22	6287-6298	c.firstname	
26-23	6298-6299	,	
26-24	6299-6308	o.orderid	
26-25	6308-6309	,	
26-26	6310-6321	o.orderdate	
26-27	6322-6323	,	
26-28	6324-6337	o.totalamount	
26-29	6338-6342	into	
26-30	6343-6349	result	

#Text=FROM orders o WHERE o.customerid = c.customerid ORDER BY o.orderdate DESC LIMIT 1; IF result is not null THEN RETURN NEXT result; END IF; END LOOP;
27-1	6350-6354	FROM	
27-2	6355-6361	orders	
27-3	6362-6363	o	
27-4	6364-6369	WHERE	
27-5	6370-6382	o.customerid	
27-6	6383-6384	=	
27-7	6385-6397	c.customerid	
27-8	6398-6403	ORDER	
27-9	6404-6406	BY	
27-10	6407-6418	o.orderdate	
27-11	6419-6423	DESC	
27-12	6424-6429	LIMIT	
27-13	6430-6431	1	
27-14	6431-6432	;	
27-15	6433-6435	IF	
27-16	6436-6442	result	
27-17	6443-6445	is	
27-18	6446-6449	not	
27-19	6450-6454	null	
27-20	6455-6459	THEN	
27-21	6460-6466	RETURN	
27-22	6467-6471	NEXT	
27-23	6472-6478	result	
27-24	6478-6479	;	
27-25	6480-6483	END	
27-26	6484-6486	IF	
27-27	6486-6487	;	
27-28	6488-6491	END	
27-29	6492-6496	LOOP	
27-30	6496-6497	;	

#Text=RETURN; END; LANGUAGE plpgsql; 2- CREATE OR REPLACE FUNCTION oldest_orders_by_customer_lateral (int) RETURNS SETOF t_oldest_orders_by_customer
28-1	6498-6504	RETURN	
28-2	6504-6505	;	
28-3	6506-6509	END	
28-4	6509-6510	;	
28-5	6511-6519	LANGUAGE	
28-6	6520-6527	plpgsql	
28-7	6527-6528	;	
28-8	6529-6530	2	
28-9	6530-6531	-	
28-10	6532-6538	CREATE	
28-11	6539-6541	OR	
28-12	6542-6549	REPLACE	
28-13	6550-6558	FUNCTION	
28-14	6559-6592	oldest_orders_by_customer_lateral	
28-15	6593-6594	(	
28-16	6594-6597	int	
28-17	6597-6598	)	
28-18	6599-6606	RETURNS	
28-19	6607-6612	SETOF	
28-20	6613-6640	t_oldest_orders_by_customer	

#Text=BEGIN RETURN QUERY SELECT customer_sub.firstname , o_sub.* FROM (SELECT * FROM customers c2 WHERE age > $1) customer_sub,
29-1	6641-6646	BEGIN	
29-2	6647-6653	RETURN	
29-3	6654-6659	QUERY	
29-4	6660-6666	SELECT	
29-5	6667-6689	customer_sub.firstname	
29-6	6690-6691	,	
29-7	6692-6697	o_sub	
29-8	6697-6698	.	
29-9	6698-6699	*	
29-10	6700-6704	FROM	
29-11	6705-6706	(	
29-12	6706-6712	SELECT	
29-13	6713-6714	*	
29-14	6715-6719	FROM	
29-15	6720-6729	customers	
29-16	6730-6732	c2	
29-17	6733-6738	WHERE	
29-18	6739-6742	age	
29-19	6743-6744	>	
29-20	6745-6747	$1	
29-21	6747-6748	)	
29-22	6749-6761	customer_sub	
29-23	6761-6762	,	

#Text=LATERAL (SELECT o.orderid, o.orderdate , o.totalamount FROM orders o WHERE o.customerid = customer_sub.customerid ORDER BY o.orderdate DESC LIMIT 1) o_sub; END; LANGUAGE plpgsql;
30-1	6763-6770	LATERAL	
30-2	6771-6772	(	
30-3	6772-6778	SELECT	
30-4	6779-6788	o.orderid	
30-5	6788-6789	,	
30-6	6790-6801	o.orderdate	
30-7	6802-6803	,	
30-8	6804-6817	o.totalamount	
30-9	6818-6822	FROM	
30-10	6823-6829	orders	
30-11	6830-6831	o	
30-12	6832-6837	WHERE	
30-13	6838-6850	o.customerid	
30-14	6851-6852	=	
30-15	6853-6876	customer_sub.customerid	
30-16	6877-6882	ORDER	
30-17	6883-6885	BY	
30-18	6886-6897	o.orderdate	
30-19	6898-6902	DESC	
30-20	6903-6908	LIMIT	
30-21	6909-6910	1	
30-22	6910-6911	)	
30-23	6912-6917	o_sub	
30-24	6917-6918	;	
30-25	6919-6922	END	
30-26	6922-6923	;	
30-27	6924-6932	LANGUAGE	
30-28	6933-6940	plpgsql	
30-29	6940-6941	;	

#Text=1- SELECT * FROM oldest_orders_by_customer(80); Time: 89.296 ms 2- SELECT * FROM oldest_orders_by_customer_lateral(80); Time: 45.230 ms Using functions properties The definition of functions has some properties that can help with function performance, for example:
31-1	6942-6943	1	
31-2	6943-6944	-	
31-3	6945-6951	SELECT	
31-4	6952-6953	*	
31-5	6954-6958	FROM	
31-6	6959-6984	oldest_orders_by_customer	
31-7	6984-6985	(	
31-8	6985-6987	80	
31-9	6987-6988	)	
31-10	6988-6989	;	
31-11	6990-6994	Time	
31-12	6994-6995	:	
31-13	6996-7002	89.296	
31-14	7003-7005	ms	
31-15	7006-7007	2	
31-16	7007-7008	-	
31-17	7009-7015	SELECT	
31-18	7016-7017	*	
31-19	7018-7022	FROM	
31-20	7023-7056	oldest_orders_by_customer_lateral	
31-21	7056-7057	(	
31-22	7057-7059	80	
31-23	7059-7060	)	
31-24	7060-7061	;	
31-25	7062-7066	Time	
31-26	7066-7067	:	
31-27	7068-7074	45.230	
31-28	7075-7077	ms	
31-29	7078-7083	Using	
31-30	7084-7093	functions	
31-31	7094-7104	properties	
31-32	7105-7108	The	
31-33	7109-7119	definition	
31-34	7120-7122	of	
31-35	7123-7132	functions	
31-36	7133-7136	has	
31-37	7137-7141	some	
31-38	7142-7152	properties	
31-39	7153-7157	that	
31-40	7158-7161	can	
31-41	7162-7166	help	
31-42	7167-7171	with	
31-43	7172-7180	function	
31-44	7181-7192	performance	
31-45	7192-7193	,	
31-46	7194-7197	for	
31-47	7198-7205	example	
31-48	7205-7206	:	

#Text=1: Use PARALLEL SAFE whenever possible The planner cannot determine automatically if a function is parallel safe, but under certain conditions parallel mode can boost performance significantly if you process a large dataset. The number of workers that the planner will use is limited by the parameters max_parallel_workers_per_gather, which in turn are taken from the pool of processes established by max_worker_processes, limited by max_parallel_workers, the maximum number of concurrent queries to execute with parallelism
32-1	7207-7208	1	
32-2	7208-7209	:	
32-3	7210-7213	Use	
32-4	7214-7222	PARALLEL	
32-5	7223-7227	SAFE	
32-6	7228-7236	whenever	
32-7	7237-7245	possible	
32-8	7246-7249	The	
32-9	7250-7257	planner	
32-10	7258-7264	cannot	
32-11	7265-7274	determine	
32-12	7275-7288	automatically	
32-13	7289-7291	if	
32-14	7292-7293	a	
32-15	7294-7302	function	
32-16	7303-7305	is	
32-17	7306-7314	parallel	
32-18	7315-7319	safe	
32-19	7319-7320	,	
32-20	7321-7324	but	
32-21	7325-7330	under	
32-22	7331-7338	certain	
32-23	7339-7349	conditions	
32-24	7350-7358	parallel	
32-25	7359-7363	mode	
32-26	7364-7367	can	
32-27	7368-7373	boost	
32-28	7374-7385	performance	
32-29	7386-7399	significantly	
32-30	7400-7402	if	
32-31	7403-7406	you	
32-32	7407-7414	process	
32-33	7415-7416	a	
32-34	7417-7422	large	
32-35	7423-7430	dataset	
32-36	7430-7431	.	
32-37	7432-7435	The	
32-38	7436-7442	number	
32-39	7443-7445	of	
32-40	7446-7453	workers	
32-41	7454-7458	that	
32-42	7459-7462	the	
32-43	7463-7470	planner	
32-44	7471-7475	will	
32-45	7476-7479	use	
32-46	7480-7482	is	
32-47	7483-7490	limited	
32-48	7491-7493	by	
32-49	7494-7497	the	
32-50	7498-7508	parameters	
32-51	7509-7540	max_parallel_workers_per_gather	
32-52	7540-7541	,	
32-53	7542-7547	which	
32-54	7548-7550	in	
32-55	7551-7555	turn	
32-56	7556-7559	are	
32-57	7560-7565	taken	
32-58	7566-7570	from	
32-59	7571-7574	the	
32-60	7575-7579	pool	
32-61	7580-7582	of	
32-62	7583-7592	processes	
32-63	7593-7604	established	
32-64	7605-7607	by	
32-65	7608-7628	max_worker_processes	
32-66	7628-7629	,	
32-67	7630-7637	limited	
32-68	7638-7640	by	
32-69	7641-7661	max_parallel_workers	
32-70	7661-7662	,	
32-71	7663-7666	the	
32-72	7667-7674	maximum	
32-73	7675-7681	number	
32-74	7682-7684	of	
32-75	7685-7695	concurrent	
32-76	7696-7703	queries	
32-77	7704-7706	to	
32-78	7707-7714	execute	
32-79	7715-7719	with	
32-80	7720-7731	parallelism	

#Text=is determined by the following formula, as long as max_worker_processes<= server cores: #Q_concurrent_par = max_worker_processes /max_parallel_workers_per_gather (integer division) When is it safe to use PARALLEL in a function? As long as your code does not perform the following, you should be ready to use it:
33-1	7732-7734	is	
33-2	7735-7745	determined	
33-3	7746-7748	by	
33-4	7749-7752	the	
33-5	7753-7762	following	
33-6	7763-7770	formula	
33-7	7770-7771	,	
33-8	7772-7774	as	
33-9	7775-7779	long	
33-10	7780-7782	as	
33-11	7783-7803	max_worker_processes	
33-12	7803-7804	<	
33-13	7804-7805	=	
33-14	7806-7812	server	
33-15	7813-7818	cores	
33-16	7818-7819	:	
33-17	7820-7821	#	
33-18	7821-7837	Q_concurrent_par	
33-19	7838-7839	=	
33-20	7840-7860	max_worker_processes	
33-21	7861-7862	/	
33-22	7862-7893	max_parallel_workers_per_gather	
33-23	7894-7895	(	
33-24	7895-7902	integer	
33-25	7903-7911	division	
33-26	7911-7912	)	
33-27	7913-7917	When	
33-28	7918-7920	is	
33-29	7921-7923	it	
33-30	7924-7928	safe	
33-31	7929-7931	to	
33-32	7932-7935	use	
33-33	7936-7944	PARALLEL	
33-34	7945-7947	in	
33-35	7948-7949	a	
33-36	7950-7958	function	
33-37	7958-7959	?	
33-38	7960-7962	As	
33-39	7963-7967	long	
33-40	7968-7970	as	
33-41	7971-7975	your	
33-42	7976-7980	code	
33-43	7981-7985	does	
33-44	7986-7989	not	
33-45	7990-7997	perform	
33-46	7998-8001	the	
33-47	8002-8011	following	
33-48	8011-8012	,	
33-49	8013-8016	you	
33-50	8017-8023	should	
33-51	8024-8026	be	
33-52	8027-8032	ready	
33-53	8033-8035	to	
33-54	8036-8039	use	
33-55	8040-8042	it	
33-56	8042-8043	:	

#Text=Writes to the database. Access sequences. Change the transaction state. Makes persistent changes to settings. Access temporary tables. Use cursors. Defines prepared statements Example: 1- CREATE OR REPLACE FUNCTION pair_div_4 (i int) RETURNS boolean
34-1	8044-8050	Writes	
34-2	8051-8053	to	
34-3	8054-8057	the	
34-4	8058-8066	database	
34-5	8066-8067	.	
34-6	8068-8074	Access	
34-7	8075-8084	sequences	
34-8	8084-8085	.	
34-9	8086-8092	Change	
34-10	8093-8096	the	
34-11	8097-8108	transaction	
34-12	8109-8114	state	
34-13	8114-8115	.	
34-14	8116-8121	Makes	
34-15	8122-8132	persistent	
34-16	8133-8140	changes	
34-17	8141-8143	to	
34-18	8144-8152	settings	
34-19	8152-8153	.	
34-20	8154-8160	Access	
34-21	8161-8170	temporary	
34-22	8171-8177	tables	
34-23	8177-8178	.	
34-24	8179-8182	Use	
34-25	8183-8190	cursors	
34-26	8190-8191	.	
34-27	8192-8199	Defines	
34-28	8200-8208	prepared	
34-29	8209-8219	statements	
34-30	8220-8227	Example	
34-31	8227-8228	:	
34-32	8229-8230	1	
34-33	8230-8231	-	
34-34	8232-8238	CREATE	
34-35	8239-8241	OR	
34-36	8242-8249	REPLACE	
34-37	8250-8258	FUNCTION	
34-38	8259-8267	pair_div	
34-39	8267-8268	_	
34-40	8268-8269	4	
34-41	8270-8271	(	
34-42	8271-8272	i	
34-43	8273-8276	int	
34-44	8276-8277	)	
34-45	8278-8285	RETURNS	
34-46	8286-8293	boolean	

#Text=AS $$ BEGIN IF $1%2 = 0 AND $1%4 = 0 THEN RETURN TRUE; END IF; RETURN FALSE; END; LANGUAGE plpgsql;
35-1	8294-8296	AS	
35-2	8297-8298	$	
35-3	8298-8299	$	
35-4	8300-8305	BEGIN	
35-5	8306-8308	IF	
35-6	8309-8312	$1%	
35-7	8312-8313	2	
35-8	8314-8315	=	
35-9	8316-8317	0	
35-10	8318-8321	AND	
35-11	8322-8325	$1%	
35-12	8325-8326	4	
35-13	8327-8328	=	
35-14	8329-8330	0	
35-15	8331-8335	THEN	
35-16	8336-8342	RETURN	
35-17	8343-8347	TRUE	
35-18	8347-8348	;	
35-19	8349-8352	END	
35-20	8353-8355	IF	
35-21	8355-8356	;	
35-22	8357-8363	RETURN	
35-23	8364-8369	FALSE	
35-24	8369-8370	;	
35-25	8371-8374	END	
35-26	8374-8375	;	
35-27	8376-8384	LANGUAGE	
35-28	8385-8392	plpgsql	
35-29	8392-8393	;	

#Text=2- CREATE OR REPLACE FUNCTION pair_div_4_ps (i int) RETURNS boolean AS $$ BEGIN IF $1%2 = 0 AND $1%4 = 0 THEN RETURN TRUE; END IF; RETURN FALSE; END;
36-1	8394-8395	2	
36-2	8395-8396	-	
36-3	8397-8403	CREATE	
36-4	8404-8406	OR	
36-5	8407-8414	REPLACE	
36-6	8415-8423	FUNCTION	
36-7	8424-8432	pair_div	
36-8	8432-8433	_	
36-9	8433-8434	4	
36-10	8434-8435	_	
36-11	8435-8437	ps	
36-12	8438-8439	(	
36-13	8439-8440	i	
36-14	8441-8444	int	
36-15	8444-8445	)	
36-16	8446-8453	RETURNS	
36-17	8454-8461	boolean	
36-18	8462-8464	AS	
36-19	8465-8466	$	
36-20	8466-8467	$	
36-21	8468-8473	BEGIN	
36-22	8474-8476	IF	
36-23	8477-8480	$1%	
36-24	8480-8481	2	
36-25	8482-8483	=	
36-26	8484-8485	0	
36-27	8486-8489	AND	
36-28	8490-8493	$1%	
36-29	8493-8494	4	
36-30	8495-8496	=	
36-31	8497-8498	0	
36-32	8499-8503	THEN	
36-33	8504-8510	RETURN	
36-34	8511-8515	TRUE	
36-35	8515-8516	;	
36-36	8517-8520	END	
36-37	8521-8523	IF	
36-38	8523-8524	;	
36-39	8525-8531	RETURN	
36-40	8532-8537	FALSE	
36-41	8537-8538	;	
36-42	8539-8542	END	
36-43	8542-8543	;	

#Text=LANGUAGE plpgsql PARALLEL SAFE; 1- EXPLAIN ANALYZE SELECT * from trade where pair_div_4 (id); Seq Scan on trade
37-1	8544-8552	LANGUAGE	
37-2	8553-8560	plpgsql	
37-3	8561-8569	PARALLEL	
37-4	8570-8574	SAFE	
37-5	8574-8575	;	
37-6	8576-8577	1	
37-7	8577-8578	-	
37-8	8579-8586	EXPLAIN	
37-9	8587-8594	ANALYZE	
37-10	8595-8601	SELECT	
37-11	8602-8603	*	
37-12	8604-8608	from	
37-13	8609-8614	trade	
37-14	8615-8620	where	
37-15	8621-8629	pair_div	
37-16	8629-8630	_	
37-17	8630-8631	4	
37-18	8632-8633	(	
37-19	8633-8635	id	
37-20	8635-8636	)	
37-21	8636-8637	;	
37-22	8638-8641	Seq	
37-23	8642-8646	Scan	
37-24	8647-8649	on	
37-25	8650-8655	trade	

#Text=(cost=0.00..448684.86 rows=563520 width=16) (actual time=0.323..2459.553 rows=422640 loops=1) Filter: pair_div_4(id) Rows Removed by Filter: 1267921 Planning Time: 0.070 ms Execution Time: 2471.796 ms 2- explain analyze
38-1	8656-8657	(	
38-2	8657-8661	cost	
38-3	8661-8662	=	
38-4	8662-8666	0.00	
38-5	8666-8667	.	
38-6	8667-8677	.448684.86	
38-7	8678-8682	rows	
38-8	8682-8683	=	
38-9	8683-8689	563520	
38-10	8690-8695	width	
38-11	8695-8696	=	
38-12	8696-8698	16	
38-13	8698-8699	)	
38-14	8700-8701	(	
38-15	8701-8707	actual	
38-16	8708-8712	time	
38-17	8712-8713	=	
38-18	8713-8718	0.323	
38-19	8718-8719	.	
38-20	8719-8728	.2459.553	
38-21	8729-8733	rows	
38-22	8733-8734	=	
38-23	8734-8740	422640	
38-24	8741-8746	loops	
38-25	8746-8747	=	
38-26	8747-8748	1	
38-27	8748-8749	)	
38-28	8750-8756	Filter	
38-29	8756-8757	:	
38-30	8758-8766	pair_div	
38-31	8766-8767	_	
38-32	8767-8768	4	
38-33	8768-8769	(	
38-34	8769-8771	id	
38-35	8771-8772	)	
38-36	8773-8777	Rows	
38-37	8778-8785	Removed	
38-38	8786-8788	by	
38-39	8789-8795	Filter	
38-40	8795-8796	:	
38-41	8797-8804	1267921	
38-42	8805-8813	Planning	
38-43	8814-8818	Time	
38-44	8818-8819	:	
38-45	8820-8825	0.070	
38-46	8826-8828	ms	
38-47	8829-8838	Execution	
38-48	8839-8843	Time	
38-49	8843-8844	:	
38-50	8845-8853	2471.796	
38-51	8854-8856	ms	
38-52	8857-8858	2	
38-53	8858-8859	-	
38-54	8860-8867	explain	
38-55	8868-8875	analyze	

#Text=select * from trade where pair_div_4_ps (id); Gather (cost=1000.00..249635.11 rows=563520 width=16) (actual time=0.883..1386.856 rows=422640 loops=1) Workers Planned: 2 Workers Launched: 2
39-1	8876-8882	select	
39-2	8883-8884	*	
39-3	8885-8889	from	
39-4	8890-8895	trade	
39-5	8896-8901	where	
39-6	8902-8910	pair_div	
39-7	8910-8911	_	
39-8	8911-8912	4	
39-9	8912-8913	_	
39-10	8913-8915	ps	
39-11	8916-8917	(	
39-12	8917-8919	id	
39-13	8919-8920	)	
39-14	8920-8921	;	
39-15	8922-8928	Gather	
39-16	8929-8930	(	
39-17	8930-8934	cost	
39-18	8934-8935	=	
39-19	8935-8942	1000.00	
39-20	8942-8943	.	
39-21	8943-8953	.249635.11	
39-22	8954-8958	rows	
39-23	8958-8959	=	
39-24	8959-8965	563520	
39-25	8966-8971	width	
39-26	8971-8972	=	
39-27	8972-8974	16	
39-28	8974-8975	)	
39-29	8976-8977	(	
39-30	8977-8983	actual	
39-31	8984-8988	time	
39-32	8988-8989	=	
39-33	8989-8994	0.883	
39-34	8994-8995	.	
39-35	8995-9004	.1386.856	
39-36	9005-9009	rows	
39-37	9009-9010	=	
39-38	9010-9016	422640	
39-39	9017-9022	loops	
39-40	9022-9023	=	
39-41	9023-9024	1	
39-42	9024-9025	)	
39-43	9026-9033	Workers	
39-44	9034-9041	Planned	
39-45	9041-9042	:	
39-46	9043-9044	2	
39-47	9045-9052	Workers	
39-48	9053-9061	Launched	
39-49	9061-9062	:	
39-50	9063-9064	2	

#Text=Parallel Seq Scan on trade (cost=0.00..192283.11 rows=234800 width=16) (actual time=0.868..1301.220 rows=140880 loops=3) Filter: pair_div_4_ps(id)
40-1	9065-9073	Parallel	
40-2	9074-9077	Seq	
40-3	9078-9082	Scan	
40-4	9083-9085	on	
40-5	9086-9091	trade	
40-6	9092-9093	(	
40-7	9093-9097	cost	
40-8	9097-9098	=	
40-9	9098-9102	0.00	
40-10	9102-9103	.	
40-11	9103-9113	.192283.11	
40-12	9114-9118	rows	
40-13	9118-9119	=	
40-14	9119-9125	234800	
40-15	9126-9131	width	
40-16	9131-9132	=	
40-17	9132-9134	16	
40-18	9134-9135	)	
40-19	9136-9137	(	
40-20	9137-9143	actual	
40-21	9144-9148	time	
40-22	9148-9149	=	
40-23	9149-9154	0.868	
40-24	9154-9155	.	
40-25	9155-9164	.1301.220	
40-26	9165-9169	rows	
40-27	9169-9170	=	
40-28	9170-9176	140880	
40-29	9177-9182	loops	
40-30	9182-9183	=	
40-31	9183-9184	3	
40-32	9184-9185	)	
40-33	9186-9192	Filter	
40-34	9192-9193	:	
40-35	9194-9202	pair_div	
40-36	9202-9203	_	
40-37	9203-9204	4	
40-38	9204-9205	_	
40-39	9205-9207	ps	
40-40	9207-9208	(	
40-41	9208-9210	id	
40-42	9210-9211	)	

#Text=Rows Removed by Filter: 422640 Planning Time: 0.138 ms Execution Time: 1405.412 ms As shown in the outputs of the explains, on the second EXPLAIN, Workers Launched
41-1	9212-9216	Rows	
41-2	9217-9224	Removed	
41-3	9225-9227	by	
41-4	9228-9234	Filter	
41-5	9234-9235	:	
41-6	9236-9242	422640	
41-7	9243-9251	Planning	
41-8	9252-9256	Time	
41-9	9256-9257	:	
41-10	9258-9263	0.138	
41-11	9264-9266	ms	
41-12	9267-9276	Execution	
41-13	9277-9281	Time	
41-14	9281-9282	:	
41-15	9283-9291	1405.412	
41-16	9292-9294	ms	
41-17	9295-9297	As	
41-18	9298-9303	shown	
41-19	9304-9306	in	
41-20	9307-9310	the	
41-21	9311-9318	outputs	
41-22	9319-9321	of	
41-23	9322-9325	the	
41-24	9326-9334	explains	
41-25	9334-9335	,	
41-26	9336-9338	on	
41-27	9339-9342	the	
41-28	9343-9349	second	
41-29	9350-9357	EXPLAIN	
41-30	9357-9358	,	
41-31	9359-9366	Workers	
41-32	9367-9375	Launched	

#Text=tag has value 2, this means that this query used 2 workers to execute, and the first EXPLAIN was executed without parallelisms 2: Use IMMUTABLE when it is possible The IMMUTABLE option informs the query optimizer about the behavior of the function and can apply some optimization. Any call to the function with all-constant arguments can be immediately replaced with the function value. To mark a function as IMMUTABLE you need to comply with the following:
42-1	9376-9379	tag	
42-2	9380-9383	has	
42-3	9384-9389	value	
42-4	9390-9391	2	
42-5	9391-9392	,	
42-6	9393-9397	this	
42-7	9398-9403	means	
42-8	9404-9408	that	
42-9	9409-9413	this	
42-10	9414-9419	query	
42-11	9420-9424	used	
42-12	9425-9426	2	
42-13	9427-9434	workers	
42-14	9435-9437	to	
42-15	9438-9445	execute	
42-16	9445-9446	,	
42-17	9447-9450	and	
42-18	9451-9454	the	
42-19	9455-9460	first	
42-20	9461-9468	EXPLAIN	
42-21	9469-9472	was	
42-22	9473-9481	executed	
42-23	9482-9489	without	
42-24	9490-9502	parallelisms	
42-25	9503-9504	2	
42-26	9504-9505	:	
42-27	9506-9509	Use	
42-28	9510-9519	IMMUTABLE	
42-29	9520-9524	when	
42-30	9525-9527	it	
42-31	9528-9530	is	
42-32	9531-9539	possible	
42-33	9540-9543	The	
42-34	9544-9553	IMMUTABLE	
42-35	9554-9560	option	
42-36	9561-9568	informs	
42-37	9569-9572	the	
42-38	9573-9578	query	
42-39	9579-9588	optimizer	
42-40	9589-9594	about	
42-41	9595-9598	the	
42-42	9599-9607	behavior	
42-43	9608-9610	of	
42-44	9611-9614	the	
42-45	9615-9623	function	
42-46	9624-9627	and	
42-47	9628-9631	can	
42-48	9632-9637	apply	
42-49	9638-9642	some	
42-50	9643-9655	optimization	
42-51	9655-9656	.	
42-52	9657-9660	Any	
42-53	9661-9665	call	
42-54	9666-9668	to	
42-55	9669-9672	the	
42-56	9673-9681	function	
42-57	9682-9686	with	
42-58	9687-9699	all-constant	
42-59	9700-9709	arguments	
42-60	9710-9713	can	
42-61	9714-9716	be	
42-62	9717-9728	immediately	
42-63	9729-9737	replaced	
42-64	9738-9742	with	
42-65	9743-9746	the	
42-66	9747-9755	function	
42-67	9756-9761	value	
42-68	9761-9762	.	
42-69	9763-9765	To	
42-70	9766-9770	mark	
42-71	9771-9772	a	
42-72	9773-9781	function	
42-73	9782-9784	as	
42-74	9785-9794	IMMUTABLE	
42-75	9795-9798	you	
42-76	9799-9803	need	
42-77	9804-9806	to	
42-78	9807-9813	comply	
42-79	9814-9818	with	
42-80	9819-9822	the	
42-81	9823-9832	following	
42-82	9832-9833	:	

#Text=You cannot modify the database (state) and always returns the same result for the same argument values; Do not search in the databases or use information that is not directly present in its argument list values. Example: 1- CREATE OR REPLACE FUNCTION get_date (date) RETURNS int AS $$ DECLARE
43-1	9834-9837	You	
43-2	9838-9844	cannot	
43-3	9845-9851	modify	
43-4	9852-9855	the	
43-5	9856-9864	database	
43-6	9865-9866	(	
43-7	9866-9871	state	
43-8	9871-9872	)	
43-9	9873-9876	and	
43-10	9877-9883	always	
43-11	9884-9891	returns	
43-12	9892-9895	the	
43-13	9896-9900	same	
43-14	9901-9907	result	
43-15	9908-9911	for	
43-16	9912-9915	the	
43-17	9916-9920	same	
43-18	9921-9929	argument	
43-19	9930-9936	values	
43-20	9936-9937	;	
43-21	9938-9940	Do	
43-22	9941-9944	not	
43-23	9945-9951	search	
43-24	9952-9954	in	
43-25	9955-9958	the	
43-26	9959-9968	databases	
43-27	9969-9971	or	
43-28	9972-9975	use	
43-29	9976-9987	information	
43-30	9988-9992	that	
43-31	9993-9995	is	
43-32	9996-9999	not	
43-33	10000-10008	directly	
43-34	10009-10016	present	
43-35	10017-10019	in	
43-36	10020-10023	its	
43-37	10024-10032	argument	
43-38	10033-10037	list	
43-39	10038-10044	values	
43-40	10044-10045	.	
43-41	10046-10053	Example	
43-42	10053-10054	:	
43-43	10055-10056	1	
43-44	10056-10057	-	
43-45	10058-10064	CREATE	
43-46	10065-10067	OR	
43-47	10068-10075	REPLACE	
43-48	10076-10084	FUNCTION	
43-49	10085-10093	get_date	
43-50	10094-10095	(	
43-51	10095-10099	date	
43-52	10099-10100	)	
43-53	10101-10108	RETURNS	
43-54	10109-10112	int	
43-55	10113-10115	AS	
43-56	10116-10117	$	
43-57	10117-10118	$	
43-58	10119-10126	DECLARE	

#Text=i int; result int:= 0; BEGIN RETURN extract (day from $1); END; LANGUAGE plpgsql; 2- CREATE OR REPLACE FUNCTION get_date_i (date) RETURNS int
44-1	10127-10128	i	
44-2	10129-10132	int	
44-3	10132-10133	;	
44-4	10134-10140	result	
44-5	10141-10144	int	
44-6	10144-10145	:	
44-7	10145-10146	=	
44-8	10147-10148	0	
44-9	10148-10149	;	
44-10	10150-10155	BEGIN	
44-11	10156-10162	RETURN	
44-12	10163-10170	extract	
44-13	10171-10172	(	
44-14	10172-10175	day	
44-15	10176-10180	from	
44-16	10181-10183	$1	
44-17	10183-10184	)	
44-18	10184-10185	;	
44-19	10186-10189	END	
44-20	10189-10190	;	
44-21	10191-10199	LANGUAGE	
44-22	10200-10207	plpgsql	
44-23	10207-10208	;	
44-24	10209-10210	2	
44-25	10210-10211	-	
44-26	10212-10218	CREATE	
44-27	10219-10221	OR	
44-28	10222-10229	REPLACE	
44-29	10230-10238	FUNCTION	
44-30	10239-10249	get_date_i	
44-31	10250-10251	(	
44-32	10251-10255	date	
44-33	10255-10256	)	
44-34	10257-10264	RETURNS	
44-35	10265-10268	int	

#Text=AS $$ DECLARE i int; result int:= 0; BEGIN RETURN extract (day from $1); END; LANGUAGE plpgsql IMMUTABLE;
45-1	10269-10271	AS	
45-2	10272-10273	$	
45-3	10273-10274	$	
45-4	10275-10282	DECLARE	
45-5	10283-10284	i	
45-6	10285-10288	int	
45-7	10288-10289	;	
45-8	10290-10296	result	
45-9	10297-10300	int	
45-10	10300-10301	:	
45-11	10301-10302	=	
45-12	10303-10304	0	
45-13	10304-10305	;	
45-14	10306-10311	BEGIN	
45-15	10312-10318	RETURN	
45-16	10319-10326	extract	
45-17	10327-10328	(	
45-18	10328-10331	day	
45-19	10332-10336	from	
45-20	10337-10339	$1	
45-21	10339-10340	)	
45-22	10340-10341	;	
45-23	10342-10345	END	
45-24	10345-10346	;	
45-25	10347-10355	LANGUAGE	
45-26	10356-10363	plpgsql	
45-27	10364-10373	IMMUTABLE	
45-28	10373-10374	;	

#Text=1- SELECT 1 from trade where id=get_date(current_date); Time: 2557.521 ms (00:02.558) 2- SELECT 1 from trade where id=get_date_i(current_date);;
46-1	10375-10376	1	
46-2	10376-10377	-	
46-3	10378-10384	SELECT	
46-4	10385-10386	1	
46-5	10387-10391	from	
46-6	10392-10397	trade	
46-7	10398-10403	where	
46-8	10404-10406	id	
46-9	10406-10407	=	
46-10	10407-10415	get_date	
46-11	10415-10416	(	
46-12	10416-10428	current_date	
46-13	10428-10429	)	
46-14	10429-10430	;	
46-15	10431-10435	Time	
46-16	10435-10436	:	
46-17	10437-10445	2557.521	
46-18	10446-10448	ms	
46-19	10449-10450	(	
46-20	10450-10452	00	
46-21	10452-10453	:	
46-22	10453-10459	02.558	
46-23	10459-10460	)	
46-24	10461-10462	2	
46-25	10462-10463	-	
46-26	10464-10470	SELECT	
46-27	10471-10472	1	
46-28	10473-10477	from	
46-29	10478-10483	trade	
46-30	10484-10489	where	
46-31	10490-10492	id	
46-32	10492-10493	=	
46-33	10493-10503	get_date_i	
46-34	10503-10504	(	
46-35	10504-10516	current_date	
46-36	10516-10517	)	
46-37	10517-10518	;	
46-38	10518-10519	;	

#Text=Time: 2208.848 ms (00:02.209) Monitoring performance of functions PostgreSQL allows the user to track the
47-1	10520-10524	Time	
47-2	10524-10525	:	
47-3	10526-10534	2208.848	
47-4	10535-10537	ms	
47-5	10538-10539	(	
47-6	10539-10541	00	
47-7	10541-10542	:	
47-8	10542-10548	02.209	
47-9	10548-10549	)	
47-10	10550-10560	Monitoring	
47-11	10561-10572	performance	
47-12	10573-10575	of	
47-13	10576-10585	functions	
47-14	10586-10596	PostgreSQL	
47-15	10597-10603	allows	
47-16	10604-10607	the	
47-17	10608-10612	user	
47-18	10613-10615	to	
47-19	10616-10621	track	
47-20	10622-10625	the	

#Text=performance of functions in the database. For example, we can see the performance stats using the view pg_stat_user_functions, as long as you configure the parameter named track_functions, that allows tracking function call counts and time spent. To simplify the configuration we can leverage the option that gives us postgresqlcon.nf to share a configuration file, download it and apply it to your server. Specifically, to track function performance, select the download format alter_system, apply the modification to your server, and reload the configuration using select pg_reload_conf(). This allows us to detect which functions are working as expected or are slow.
48-1	10626-10637	performance	
48-2	10638-10640	of	
48-3	10641-10650	functions	
48-4	10651-10653	in	
48-5	10654-10657	the	
48-6	10658-10666	database	
48-7	10666-10667	.	
48-8	10668-10671	For	
48-9	10672-10679	example	
48-10	10679-10680	,	
48-11	10681-10683	we	
48-12	10684-10687	can	
48-13	10688-10691	see	
48-14	10692-10695	the	
48-15	10696-10707	performance	
48-16	10708-10713	stats	
48-17	10714-10719	using	
48-18	10720-10723	the	
48-19	10724-10728	view	
48-20	10729-10751	pg_stat_user_functions	
48-21	10751-10752	,	
48-22	10753-10755	as	
48-23	10756-10760	long	
48-24	10761-10763	as	
48-25	10764-10767	you	
48-26	10768-10777	configure	
48-27	10778-10781	the	
48-28	10782-10791	parameter	
48-29	10792-10797	named	
48-30	10798-10813	track_functions	
48-31	10813-10814	,	
48-32	10815-10819	that	
48-33	10820-10826	allows	
48-34	10827-10835	tracking	
48-35	10836-10844	function	
48-36	10845-10849	call	
48-37	10850-10856	counts	
48-38	10857-10860	and	
48-39	10861-10865	time	
48-40	10866-10871	spent	
48-41	10871-10872	.	
48-42	10873-10875	To	
48-43	10876-10884	simplify	
48-44	10885-10888	the	
48-45	10889-10902	configuration	
48-46	10903-10905	we	
48-47	10906-10909	can	
48-48	10910-10918	leverage	
48-49	10919-10922	the	
48-50	10923-10929	option	
48-51	10930-10934	that	
48-52	10935-10940	gives	
48-53	10941-10943	us	
48-54	10944-10960	postgresqlcon.nf	
48-55	10961-10963	to	
48-56	10964-10969	share	
48-57	10970-10971	a	
48-58	10972-10985	configuration	
48-59	10986-10990	file	
48-60	10990-10991	,	
48-61	10992-11000	download	
48-62	11001-11003	it	
48-63	11004-11007	and	
48-64	11008-11013	apply	
48-65	11014-11016	it	
48-66	11017-11019	to	
48-67	11020-11024	your	
48-68	11025-11031	server	
48-69	11031-11032	.	
48-70	11033-11045	Specifically	
48-71	11045-11046	,	
48-72	11047-11049	to	
48-73	11050-11055	track	
48-74	11056-11064	function	
48-75	11065-11076	performance	
48-76	11076-11077	,	
48-77	11078-11084	select	
48-78	11085-11088	the	
48-79	11089-11097	download	
48-80	11098-11104	format	
48-81	11105-11117	alter_system	
48-82	11117-11118	,	
48-83	11119-11124	apply	
48-84	11125-11128	the	
48-85	11129-11141	modification	
48-86	11142-11144	to	
48-87	11145-11149	your	
48-88	11150-11156	server	
48-89	11156-11157	,	
48-90	11158-11161	and	
48-91	11162-11168	reload	
48-92	11169-11172	the	
48-93	11173-11186	configuration	
48-94	11187-11192	using	
48-95	11193-11199	select	
48-96	11200-11214	pg_reload_conf	
48-97	11214-11215	(	
48-98	11215-11216	)	
48-99	11216-11217	.	
48-100	11218-11222	This	
48-101	11223-11229	allows	
48-102	11230-11232	us	
48-103	11233-11235	to	
48-104	11236-11242	detect	
48-105	11243-11248	which	
48-106	11249-11258	functions	
48-107	11259-11262	are	
48-108	11263-11270	working	
48-109	11271-11273	as	
48-110	11274-11282	expected	
48-111	11283-11285	or	
48-112	11286-11289	are	
48-113	11290-11294	slow	
48-114	11294-11295	.	

#Text=For example, to use this view you can write a query like this: select schemaname||'.'||funcname func_name, calls, total_time, round((total_time/calls)::numeric,2) as mean_time, self_time from pg_catalog.pg_stat_user_functions;
49-1	11296-11299	For	
49-2	11300-11307	example	
49-3	11307-11308	,	
49-4	11309-11311	to	
49-5	11312-11315	use	
49-6	11316-11320	this	
49-7	11321-11325	view	
49-8	11326-11329	you	
49-9	11330-11333	can	
49-10	11334-11339	write	
49-11	11340-11341	a	
49-12	11342-11347	query	
49-13	11348-11352	like	
49-14	11353-11357	this	
49-15	11357-11358	:	
49-16	11359-11365	select	
49-17	11366-11376	schemaname	
49-18	11376-11377	|	
49-19	11377-11378	|	
49-20	11378-11379	'	
49-21	11379-11380	.	
49-22	11380-11381	'	
49-23	11381-11382	|	
49-24	11382-11383	|	
49-25	11383-11391	funcname	
49-26	11392-11401	func_name	
49-27	11401-11402	,	
49-28	11403-11408	calls	
49-29	11408-11409	,	
49-30	11410-11420	total_time	
49-31	11420-11421	,	
49-32	11422-11427	round	
49-33	11427-11428	(	
49-34	11428-11429	(	
49-35	11429-11439	total_time	
49-36	11439-11440	/	
49-37	11440-11445	calls	
49-38	11445-11446	)	
49-39	11446-11447	:	
49-40	11447-11448	:	
49-41	11448-11455	numeric	
49-42	11455-11456	,	
49-43	11456-11457	2	
49-44	11457-11458	)	
49-45	11459-11461	as	
49-46	11462-11471	mean_time	
49-47	11471-11472	,	
49-48	11473-11482	self_time	
49-49	11483-11487	from	
49-50	11488-11521	pg_catalog.pg_stat_user_functions	
49-51	11521-11522	;	

#Text=func_name | calls | total_time | mean_time | self_time ---------------------------+-------+------------+-----------+-----------
50-1	11523-11532	func_name	
50-2	11533-11534	|	
50-3	11535-11540	calls	
50-4	11541-11542	|	
50-5	11543-11553	total_time	
50-6	11554-11555	|	
50-7	11556-11565	mean_time	
50-8	11566-11567	|	
50-9	11568-11577	self_time	
50-10	11578-11579	-	
50-11	11579-11580	-	
50-12	11580-11581	-	
50-13	11581-11582	-	
50-14	11582-11583	-	
50-15	11583-11584	-	
50-16	11584-11585	-	
50-17	11585-11586	-	
50-18	11586-11587	-	
50-19	11587-11588	-	
50-20	11588-11589	-	
50-21	11589-11590	-	
50-22	11590-11591	-	
50-23	11591-11592	-	
50-24	11592-11593	-	
50-25	11593-11594	-	
50-26	11594-11595	-	
50-27	11595-11596	-	
50-28	11596-11597	-	
50-29	11597-11598	-	
50-30	11598-11599	-	
50-31	11599-11600	-	
50-32	11600-11601	-	
50-33	11601-11602	-	
50-34	11602-11603	-	
50-35	11603-11604	-	
50-36	11604-11605	-	
50-37	11605-11606	+	
50-38	11606-11607	-	
50-39	11607-11608	-	
50-40	11608-11609	-	
50-41	11609-11610	-	
50-42	11610-11611	-	
50-43	11611-11612	-	
50-44	11612-11613	-	
50-45	11613-11614	+	
50-46	11614-11615	-	
50-47	11615-11616	-	
50-48	11616-11617	-	
50-49	11617-11618	-	
50-50	11618-11619	-	
50-51	11619-11620	-	
50-52	11620-11621	-	
50-53	11621-11622	-	
50-54	11622-11623	-	
50-55	11623-11624	-	
50-56	11624-11625	-	
50-57	11625-11626	-	
50-58	11626-11627	+	
50-59	11627-11628	-	
50-60	11628-11629	-	
50-61	11629-11630	-	
50-62	11630-11631	-	
50-63	11631-11632	-	
50-64	11632-11633	-	
50-65	11633-11634	-	
50-66	11634-11635	-	
50-67	11635-11636	-	
50-68	11636-11637	-	
50-69	11637-11638	-	
50-70	11638-11639	+	
50-71	11639-11640	-	
50-72	11640-11641	-	
50-73	11641-11642	-	
50-74	11642-11643	-	
50-75	11643-11644	-	
50-76	11644-11645	-	
50-77	11645-11646	-	
50-78	11646-11647	-	
50-79	11647-11648	-	
50-80	11648-11649	-	
50-81	11649-11650	-	

#Text=public.f_plpgsql 2 | 93.908 | 46.95 | 93.908 public.auditoria_clientes | 2684 | 593.705 | 0.22 | 593.705
51-1	11651-11667	public.f_plpgsql	
51-2	11668-11669	2	
51-3	11670-11671	|	
51-4	11672-11678	93.908	
51-5	11679-11680	|	
51-6	11681-11686	46.95	
51-7	11687-11688	|	
51-8	11689-11695	93.908	
51-9	11696-11721	public.auditoria_clientes	
51-10	11722-11723	|	
51-11	11724-11728	2684	
51-12	11729-11730	|	
51-13	11731-11738	593.705	
51-14	11739-11740	|	
51-15	11741-11745	0.22	
51-16	11746-11747	|	
51-17	11748-11755	593.705	

#Text=public.prc_clientes 2 | 1.447 | 0.72 | 0.387 public.max_pro_min 3 | 1.589 | 0.53 | 1.589 public.registro_ddl
52-1	11756-11775	public.prc_clientes	
52-2	11776-11777	2	
52-3	11778-11779	|	
52-4	11780-11785	1.447	
52-5	11786-11787	|	
52-6	11788-11792	0.72	
52-7	11793-11794	|	
52-8	11795-11800	0.387	
52-9	11801-11819	public.max_pro_min	
52-10	11820-11821	3	
52-11	11822-11823	|	
52-12	11824-11829	1.589	
52-13	11830-11831	|	
52-14	11832-11836	0.53	
52-15	11837-11838	|	
52-16	11839-11844	1.589	
52-17	11845-11864	public.registro_ddl	

#Text=17 | 39.217 | 2.31 | 39.217 public.registro_ddl_drop 2 | 422.386 | 211.19 | 422.386 calls: Number of times this function has been called
53-1	11865-11867	17	
53-2	11868-11869	|	
53-3	11870-11876	39.217	
53-4	11877-11878	|	
53-5	11879-11883	2.31	
53-6	11884-11885	|	
53-7	11886-11892	39.217	
53-8	11893-11917	public.registro_ddl_drop	
53-9	11918-11919	2	
53-10	11920-11921	|	
53-11	11922-11929	422.386	
53-12	11930-11931	|	
53-13	11932-11938	211.19	
53-14	11939-11940	|	
53-15	11941-11948	422.386	
53-16	11949-11954	calls	
53-17	11954-11955	:	
53-18	11956-11962	Number	
53-19	11963-11965	of	
53-20	11966-11971	times	
53-21	11972-11976	this	
53-22	11977-11985	function	
53-23	11986-11989	has	
53-24	11990-11994	been	
53-25	11995-12001	called	

#Text=total_time: Time(ms) spent in this function and all other functions called by it inside their code mean_time: AVG Time(ms) spent in this function and all other functions called by it inside their code self_time: Time(ms) spent in this function itself, without including other functions called by it Conclusions
54-1	12002-12012	total_time	
54-2	12012-12013	:	
54-3	12014-12018	Time	
54-4	12018-12019	(	
54-5	12019-12021	ms	
54-6	12021-12022	)	
54-7	12023-12028	spent	
54-8	12029-12031	in	
54-9	12032-12036	this	
54-10	12037-12045	function	
54-11	12046-12049	and	
54-12	12050-12053	all	
54-13	12054-12059	other	
54-14	12060-12069	functions	
54-15	12070-12076	called	
54-16	12077-12079	by	
54-17	12080-12082	it	
54-18	12083-12089	inside	
54-19	12090-12095	their	
54-20	12096-12100	code	
54-21	12101-12110	mean_time	
54-22	12110-12111	:	
54-23	12112-12115	AVG	
54-24	12116-12120	Time	
54-25	12120-12121	(	
54-26	12121-12123	ms	
54-27	12123-12124	)	
54-28	12125-12130	spent	
54-29	12131-12133	in	
54-30	12134-12138	this	
54-31	12139-12147	function	
54-32	12148-12151	and	
54-33	12152-12155	all	
54-34	12156-12161	other	
54-35	12162-12171	functions	
54-36	12172-12178	called	
54-37	12179-12181	by	
54-38	12182-12184	it	
54-39	12185-12191	inside	
54-40	12192-12197	their	
54-41	12198-12202	code	
54-42	12203-12212	self_time	
54-43	12212-12213	:	
54-44	12214-12218	Time	
54-45	12218-12219	(	
54-46	12219-12221	ms	
54-47	12221-12222	)	
54-48	12223-12228	spent	
54-49	12229-12231	in	
54-50	12232-12236	this	
54-51	12237-12245	function	
54-52	12246-12252	itself	
54-53	12252-12253	,	
54-54	12254-12261	without	
54-55	12262-12271	including	
54-56	12272-12277	other	
54-57	12278-12287	functions	
54-58	12288-12294	called	
54-59	12295-12297	by	
54-60	12298-12300	it	
54-61	12301-12312	Conclusions	

#Text=The tips and examples shown above have shown us that sometimes with minimum changes written in our code in PostgreSQL’s functions we can get some performance benefits. These tips are not exclusive, whenever possible these can be combined to achieve an improvement. e.g.: PARALLEL SAFE and avoid overusing the RAISE clause. If you know any other tips or examples please feel free to share them with us. Also, we can monitor our function’s performance by issuing a simple change in PostgreSQL’s configuration. Comments Please enable JavaScript to view the comments powered by Disqus.
55-1	12313-12316	The	
55-2	12317-12321	tips	
55-3	12322-12325	and	
55-4	12326-12334	examples	
55-5	12335-12340	shown	
55-6	12341-12346	above	
55-7	12347-12351	have	
55-8	12352-12357	shown	
55-9	12358-12360	us	
55-10	12361-12365	that	
55-11	12366-12375	sometimes	
55-12	12376-12380	with	
55-13	12381-12388	minimum	
55-14	12389-12396	changes	
55-15	12397-12404	written	
55-16	12405-12407	in	
55-17	12408-12411	our	
55-18	12412-12416	code	
55-19	12417-12419	in	
55-20	12420-12430	PostgreSQL	
55-21	12430-12431	’	
55-22	12431-12432	s	
55-23	12433-12442	functions	
55-24	12443-12445	we	
55-25	12446-12449	can	
55-26	12450-12453	get	
55-27	12454-12458	some	
55-28	12459-12470	performance	
55-29	12471-12479	benefits	
55-30	12479-12480	.	
55-31	12481-12486	These	
55-32	12487-12491	tips	
55-33	12492-12495	are	
55-34	12496-12499	not	
55-35	12500-12509	exclusive	
55-36	12509-12510	,	
55-37	12511-12519	whenever	
55-38	12520-12528	possible	
55-39	12529-12534	these	
55-40	12535-12538	can	
55-41	12539-12541	be	
55-42	12542-12550	combined	
55-43	12551-12553	to	
55-44	12554-12561	achieve	
55-45	12562-12564	an	
55-46	12565-12576	improvement	
55-47	12576-12577	.	
55-48	12578-12581	e.g	
55-49	12581-12582	.	
55-50	12582-12583	:	
55-51	12584-12592	PARALLEL	
55-52	12593-12597	SAFE	
55-53	12598-12601	and	
55-54	12602-12607	avoid	
55-55	12608-12617	overusing	
55-56	12618-12621	the	
55-57	12622-12627	RAISE	
55-58	12628-12634	clause	
55-59	12634-12635	.	
55-60	12636-12638	If	
55-61	12639-12642	you	
55-62	12643-12647	know	
55-63	12648-12651	any	
55-64	12652-12657	other	
55-65	12658-12662	tips	
55-66	12663-12665	or	
55-67	12666-12674	examples	
55-68	12675-12681	please	
55-69	12682-12686	feel	
55-70	12687-12691	free	
55-71	12692-12694	to	
55-72	12695-12700	share	
55-73	12701-12705	them	
55-74	12706-12710	with	
55-75	12711-12713	us	
55-76	12713-12714	.	
55-77	12715-12719	Also	
55-78	12719-12720	,	
55-79	12721-12723	we	
55-80	12724-12727	can	
55-81	12728-12735	monitor	
55-82	12736-12739	our	
55-83	12740-12748	function	
55-84	12748-12749	’	
55-85	12749-12750	s	
55-86	12751-12762	performance	
55-87	12763-12765	by	
55-88	12766-12773	issuing	
55-89	12774-12775	a	
55-90	12776-12782	simple	
55-91	12783-12789	change	
55-92	12790-12792	in	
55-93	12793-12803	PostgreSQL	
55-94	12803-12804	’	
55-95	12804-12805	s	
55-96	12806-12819	configuration	
55-97	12819-12820	.	
55-98	12821-12829	Comments	
55-99	12830-12836	Please	
55-100	12837-12843	enable	
55-101	12844-12854	JavaScript	
55-102	12855-12857	to	
55-103	12858-12862	view	
55-104	12863-12866	the	
55-105	12867-12875	comments	
55-106	12876-12883	powered	
55-107	12884-12886	by	
55-108	12887-12893	Disqus	
55-109	12893-12894	.	

#Text=comments powered by Disqus More Posts You may also likethis related content 63-Node EKS Cluster running on a Single Instance with Firecracker Álvaro Hernández Jan 13, 2021 · 7 min read
56-1	12895-12903	comments	
56-2	12904-12911	powered	
56-3	12912-12914	by	
56-4	12915-12921	Disqus	
56-5	12922-12926	More	
56-6	12927-12932	Posts	
56-7	12933-12936	You	
56-8	12937-12940	may	
56-9	12941-12945	also	
56-10	12946-12954	likethis	
56-11	12955-12962	related	
56-12	12963-12970	content	
56-13	12971-12973	63	
56-14	12973-12974	-	
56-15	12974-12978	Node	
56-16	12979-12982	EKS	
56-17	12983-12990	Cluster	
56-18	12991-12998	running	
56-19	12999-13001	on	
56-20	13002-13003	a	
56-21	13004-13010	Single	
56-22	13011-13019	Instance	
56-23	13020-13024	with	
56-24	13025-13036	Firecracker	
56-25	13037-13043	Álvaro	
56-26	13044-13053	Hernández	
56-27	13054-13057	Jan	
56-28	13058-13060	13	
56-29	13060-13061	,	
56-30	13062-13066	2021	
56-31	13067-13068	·	
56-32	13069-13070	7	
56-33	13071-13074	min	
56-34	13075-13079	read	

#Text=63-Node EKS Cluster running on a Single Instance with Firecracker This blog post is a part of a series of posts devoted to Firecracker automation. Currently it consists of the following posts: Read post Repository, Tuning Guide and API for your postgresql.conf Álvaro Hernández Dec 18, 2020 · 3 min read
57-1	13080-13082	63	
57-2	13082-13083	-	
57-3	13083-13087	Node	
57-4	13088-13091	EKS	
57-5	13092-13099	Cluster	
57-6	13100-13107	running	
57-7	13108-13110	on	
57-8	13111-13112	a	
57-9	13113-13119	Single	
57-10	13120-13128	Instance	
57-11	13129-13133	with	
57-12	13134-13145	Firecracker	
57-13	13146-13150	This	
57-14	13151-13155	blog	
57-15	13156-13160	post	
57-16	13161-13163	is	
57-17	13164-13165	a	
57-18	13166-13170	part	
57-19	13171-13173	of	
57-20	13174-13175	a	
57-21	13176-13182	series	
57-22	13183-13185	of	
57-23	13186-13191	posts	
57-24	13192-13199	devoted	
57-25	13200-13202	to	
57-26	13203-13214	Firecracker	
57-27	13215-13225	automation	
57-28	13225-13226	.	
57-29	13227-13236	Currently	
57-30	13237-13239	it	
57-31	13240-13248	consists	
57-32	13249-13251	of	
57-33	13252-13255	the	
57-34	13256-13265	following	
57-35	13266-13271	posts	
57-36	13271-13272	:	
57-37	13273-13277	Read	
57-38	13278-13282	post	
57-39	13283-13293	Repository	
57-40	13293-13294	,	
57-41	13295-13301	Tuning	
57-42	13302-13307	Guide	
57-43	13308-13311	and	
57-44	13312-13315	API	
57-45	13316-13319	for	
57-46	13320-13324	your	
57-47	13325-13340	postgresql.conf	
57-48	13341-13347	Álvaro	
57-49	13348-13357	Hernández	
57-50	13358-13361	Dec	
57-51	13362-13364	18	
57-52	13364-13365	,	
57-53	13366-13370	2020	
57-54	13371-13372	·	
57-55	13373-13374	3	
57-56	13375-13378	min	
57-57	13379-13383	read	

#Text=Repository, Tuning Guide and API for your postgresql.conf postgresqlco.nf (aka postgresqlCO.NF, or simply &ldquo;CONF&rdquo;) was born a little bit more than two years ago. CONF&rsquo;s main goal was to help Postgres users find more and easier help to understand and tune their postgresql. Read post Free 1GB Postgres Database on AWS CloudShell Álvaro Hernández Dec 17, 2020 · 5 min read
58-1	13384-13394	Repository	
58-2	13394-13395	,	
58-3	13396-13402	Tuning	
58-4	13403-13408	Guide	
58-5	13409-13412	and	
58-6	13413-13416	API	
58-7	13417-13420	for	
58-8	13421-13425	your	
58-9	13426-13441	postgresql.conf	
58-10	13442-13457	postgresqlco.nf	
58-11	13458-13459	(	
58-12	13459-13462	aka	
58-13	13463-13478	postgresqlCO.NF	
58-14	13478-13479	,	
58-15	13480-13482	or	
58-16	13483-13489	simply	
58-17	13490-13491	&	
58-18	13491-13496	ldquo	
58-19	13496-13497	;	
58-20	13497-13501	CONF	
58-21	13501-13502	&	
58-22	13502-13507	rdquo	
58-23	13507-13508	;	
58-24	13508-13509	)	
58-25	13510-13513	was	
58-26	13514-13518	born	
58-27	13519-13520	a	
58-28	13521-13527	little	
58-29	13528-13531	bit	
58-30	13532-13536	more	
58-31	13537-13541	than	
58-32	13542-13545	two	
58-33	13546-13551	years	
58-34	13552-13555	ago	
58-35	13555-13556	.	
58-36	13557-13561	CONF	
58-37	13561-13562	&	
58-38	13562-13567	rsquo	
58-39	13567-13568	;	
58-40	13568-13569	s	
58-41	13570-13574	main	
58-42	13575-13579	goal	
58-43	13580-13583	was	
58-44	13584-13586	to	
58-45	13587-13591	help	
58-46	13592-13600	Postgres	
58-47	13601-13606	users	
58-48	13607-13611	find	
58-49	13612-13616	more	
58-50	13617-13620	and	
58-51	13621-13627	easier	
58-52	13628-13632	help	
58-53	13633-13635	to	
58-54	13636-13646	understand	
58-55	13647-13650	and	
58-56	13651-13655	tune	
58-57	13656-13661	their	
58-58	13662-13672	postgresql	
58-59	13672-13673	.	
58-60	13674-13678	Read	
58-61	13679-13683	post	
58-62	13684-13688	Free	
58-63	13689-13692	1GB	
58-64	13693-13701	Postgres	
58-65	13702-13710	Database	
58-66	13711-13713	on	
58-67	13714-13717	AWS	
58-68	13718-13728	CloudShell	
58-69	13729-13735	Álvaro	
58-70	13736-13745	Hernández	
58-71	13746-13749	Dec	
58-72	13750-13752	17	
58-73	13752-13753	,	
58-74	13754-13758	2020	
58-75	13759-13760	·	
58-76	13761-13762	5	
58-77	13763-13766	min	
58-78	13767-13771	read	

#Text=Free 1GB Postgres Database on AWS CloudShell TL;DR AWS CloudShell is a CLI embedded in the AWS Web Console. It is meant to make it easier to run the AWS CLI, SDK and other scripts from your web browser, without having to install anything locally or having to deal with local credential and profiles management. Read post About OnGres We like open source, we develop open source software, and we are very active and well known at Postgres community. We build very innovative projects in Postgres ecosystem and are the founders of Fundación PostgreSQL. Contact us
59-1	13772-13776	Free	
59-2	13777-13780	1GB	
59-3	13781-13789	Postgres	
59-4	13790-13798	Database	
59-5	13799-13801	on	
59-6	13802-13805	AWS	
59-7	13806-13816	CloudShell	
59-8	13817-13819	TL	
59-9	13819-13820	;	
59-10	13820-13822	DR	
59-11	13823-13826	AWS	
59-12	13827-13837	CloudShell	
59-13	13838-13840	is	
59-14	13841-13842	a	
59-15	13843-13846	CLI	
59-16	13847-13855	embedded	
59-17	13856-13858	in	
59-18	13859-13862	the	
59-19	13863-13866	AWS	
59-20	13867-13870	Web	
59-21	13871-13878	Console	
59-22	13878-13879	.	
59-23	13880-13882	It	
59-24	13883-13885	is	
59-25	13886-13891	meant	
59-26	13892-13894	to	
59-27	13895-13899	make	
59-28	13900-13902	it	
59-29	13903-13909	easier	
59-30	13910-13912	to	
59-31	13913-13916	run	
59-32	13917-13920	the	
59-33	13921-13924	AWS	
59-34	13925-13928	CLI	
59-35	13928-13929	,	
59-36	13930-13933	SDK	
59-37	13934-13937	and	
59-38	13938-13943	other	
59-39	13944-13951	scripts	
59-40	13952-13956	from	
59-41	13957-13961	your	
59-42	13962-13965	web	
59-43	13966-13973	browser	
59-44	13973-13974	,	
59-45	13975-13982	without	
59-46	13983-13989	having	
59-47	13990-13992	to	
59-48	13993-14000	install	
59-49	14001-14009	anything	
59-50	14010-14017	locally	
59-51	14018-14020	or	
59-52	14021-14027	having	
59-53	14028-14030	to	
59-54	14031-14035	deal	
59-55	14036-14040	with	
59-56	14041-14046	local	
59-57	14047-14057	credential	
59-58	14058-14061	and	
59-59	14062-14070	profiles	
59-60	14071-14081	management	
59-61	14081-14082	.	
59-62	14083-14087	Read	
59-63	14088-14092	post	
59-64	14093-14098	About	
59-65	14099-14105	OnGres	
59-66	14106-14108	We	
59-67	14109-14113	like	
59-68	14114-14118	open	
59-69	14119-14125	source	
59-70	14125-14126	,	
59-71	14127-14129	we	
59-72	14130-14137	develop	
59-73	14138-14142	open	
59-74	14143-14149	source	
59-75	14150-14158	software	
59-76	14158-14159	,	
59-77	14160-14163	and	
59-78	14164-14166	we	
59-79	14167-14170	are	
59-80	14171-14175	very	
59-81	14176-14182	active	
59-82	14183-14186	and	
59-83	14187-14191	well	
59-84	14192-14197	known	
59-85	14198-14200	at	
59-86	14201-14209	Postgres	
59-87	14210-14219	community	
59-88	14219-14220	.	
59-89	14221-14223	We	
59-90	14224-14229	build	
59-91	14230-14234	very	
59-92	14235-14245	innovative	
59-93	14246-14254	projects	
59-94	14255-14257	in	
59-95	14258-14266	Postgres	
59-96	14267-14276	ecosystem	
59-97	14277-14280	and	
59-98	14281-14284	are	
59-99	14285-14288	the	
59-100	14289-14297	founders	
59-101	14298-14300	of	
59-102	14301-14310	Fundación	
59-103	14311-14321	PostgreSQL	
59-104	14321-14322	.	
59-105	14323-14330	Contact	
59-106	14331-14333	us	

#Text=We are currently working on more awesome stuff Subscribe to our newsletter to be up to date! -None- Newsletter Contact Form Careers StackGres I accept the OnGres Privacy Policy and agree to receive news and promotions every now and then Resources
60-1	14334-14336	We	
60-2	14337-14340	are	
60-3	14341-14350	currently	
60-4	14351-14358	working	
60-5	14359-14361	on	
60-6	14362-14366	more	
60-7	14367-14374	awesome	
60-8	14375-14380	stuff	
60-9	14381-14390	Subscribe	
60-10	14391-14393	to	
60-11	14394-14397	our	
60-12	14398-14408	newsletter	
60-13	14409-14411	to	
60-14	14412-14414	be	
60-15	14415-14417	up	
60-16	14418-14420	to	
60-17	14421-14425	date	
60-18	14425-14426	!	
60-19	14427-14428	-	
60-20	14428-14432	None	
60-21	14432-14433	-	
60-22	14434-14444	Newsletter	
60-23	14445-14452	Contact	
60-24	14453-14457	Form	
60-25	14458-14465	Careers	
60-26	14466-14475	StackGres	
60-27	14476-14477	I	
60-28	14478-14484	accept	
60-29	14485-14488	the	
60-30	14489-14495	OnGres	
60-31	14496-14503	Privacy	
60-32	14504-14510	Policy	
60-33	14511-14514	and	
60-34	14515-14520	agree	
60-35	14521-14523	to	
60-36	14524-14531	receive	
60-37	14532-14536	news	
60-38	14537-14540	and	
60-39	14541-14551	promotions	
60-40	14552-14557	every	
60-41	14558-14561	now	
60-42	14562-14565	and	
60-43	14566-14570	then	
60-44	14571-14580	Resources	

#Text=Blog Services Professional Services Consulting Training Products StackGres PostgreSQLCO.NF Company Team Careers Contact //Language English © 2021 OnGres Inc.
61-1	14581-14585	Blog	
61-2	14586-14594	Services	
61-3	14595-14607	Professional	
61-4	14608-14616	Services	
61-5	14617-14627	Consulting	
61-6	14628-14636	Training	
61-7	14637-14645	Products	
61-8	14646-14655	StackGres	
61-9	14656-14671	PostgreSQLCO.NF	
61-10	14672-14679	Company	
61-11	14680-14684	Team	
61-12	14685-14692	Careers	
61-13	14693-14700	Contact	
61-14	14701-14702	/	
61-15	14702-14703	/	
61-16	14703-14711	Language	
61-17	14712-14719	English	
61-18	14720-14721	©	
61-19	14722-14726	2021	
61-20	14727-14733	OnGres	
61-21	14734-14737	Inc	
61-22	14737-14738	.	
