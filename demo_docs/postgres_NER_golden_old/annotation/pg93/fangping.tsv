#FORMAT=WebAnno TSV 3.3


#Text=Troubleshoot Performance Issues Using Flight Recorder Previous Next JavaScript must be enabled to correctly display this content Troubleshooting Guide General Java Troubleshooting Troubleshoot Performance Issues Using Flight Recorder 4 Troubleshoot Performance Issues Using Flight Recorder
1-1	0-12	Troubleshoot	
1-2	13-24	Performance	
1-3	25-31	Issues	
1-4	32-37	Using	
1-5	38-44	Flight	
1-6	45-53	Recorder	
1-7	54-62	Previous	
1-8	63-67	Next	
1-9	68-78	JavaScript	
1-10	79-83	must	
1-11	84-86	be	
1-12	87-94	enabled	
1-13	95-97	to	
1-14	98-107	correctly	
1-15	108-115	display	
1-16	116-120	this	
1-17	121-128	content	
1-18	129-144	Troubleshooting	
1-19	145-150	Guide	
1-20	151-158	General	
1-21	159-163	Java	
1-22	164-179	Troubleshooting	
1-23	180-192	Troubleshoot	
1-24	193-204	Performance	
1-25	205-211	Issues	
1-26	212-217	Using	
1-27	218-224	Flight	
1-28	225-233	Recorder	
1-29	234-235	4	
1-30	236-248	Troubleshoot	
1-31	249-260	Performance	
1-32	261-267	Issues	
1-33	268-273	Using	
1-34	274-280	Flight	
1-35	281-289	Recorder	

#Text=Identify performance issues with a Java application and debug these issues using flight recordings. To learn more about creating a recording with Flight Recorder in JMC, see Use JMC to Start a Flight Recording. The data provided by Flight Recorder helps you investigate performance issues. No other tool gives as much profiling data without skewing the results with its own performance overhead. This chapter provides information about performance issues that you can identify and debug using data from Flight Recorder.
2-1	290-298	Identify	
2-2	299-310	performance	
2-3	311-317	issues	
2-4	318-322	with	
2-5	323-324	a	
2-6	325-329	Java	
2-7	330-341	application	
2-8	342-345	and	
2-9	346-351	debug	
2-10	352-357	these	
2-11	358-364	issues	
2-12	365-370	using	
2-13	371-377	flight	
2-14	378-388	recordings	
2-15	388-389	.	
2-16	390-392	To	
2-17	393-398	learn	
2-18	399-403	more	
2-19	404-409	about	
2-20	410-418	creating	
2-21	419-420	a	
2-22	421-430	recording	
2-23	431-435	with	
2-24	436-442	Flight	
2-25	443-451	Recorder	
2-26	452-454	in	
2-27	455-458	JMC	
2-28	458-459	,	
2-29	460-463	see	
2-30	464-467	Use	
2-31	468-471	JMC	
2-32	472-474	to	
2-33	475-480	Start	
2-34	481-482	a	
2-35	483-489	Flight	
2-36	490-499	Recording	
2-37	499-500	.	
2-38	501-504	The	
2-39	505-509	data	
2-40	510-518	provided	
2-41	519-521	by	
2-42	522-528	Flight	
2-43	529-537	Recorder	
2-44	538-543	helps	
2-45	544-547	you	
2-46	548-559	investigate	
2-47	560-571	performance	
2-48	572-578	issues	
2-49	578-579	.	
2-50	580-582	No	
2-51	583-588	other	
2-52	589-593	tool	
2-53	594-599	gives	
2-54	600-602	as	
2-55	603-607	much	
2-56	608-617	profiling	
2-57	618-622	data	
2-58	623-630	without	
2-59	631-638	skewing	
2-60	639-642	the	
2-61	643-650	results	
2-62	651-655	with	
2-63	656-659	its	
2-64	660-663	own	
2-65	664-675	performance	
2-66	676-684	overhead	
2-67	684-685	.	
2-68	686-690	This	
2-69	691-698	chapter	
2-70	699-707	provides	
2-71	708-719	information	
2-72	720-725	about	
2-73	726-737	performance	
2-74	738-744	issues	
2-75	745-749	that	
2-76	750-753	you	
2-77	754-757	can	
2-78	758-766	identify	
2-79	767-770	and	
2-80	771-776	debug	
2-81	777-782	using	
2-82	783-787	data	
2-83	788-792	from	
2-84	793-799	Flight	
2-85	800-808	Recorder	
2-86	808-809	.	

#Text=This chapter contains the following sections: Flight Recorder Overhead Find Bottlenecks Garbage Collection Performance Synchronization Performance I/O Performance Code Execution Performance Flight Recorder Overhead
3-1	810-814	This	
3-2	815-822	chapter	
3-3	823-831	contains	
3-4	832-835	the	
3-5	836-845	following	
3-6	846-854	sections	
3-7	854-855	:	
3-8	856-862	Flight	
3-9	863-871	Recorder	
3-10	872-880	Overhead	
3-11	881-885	Find	
3-12	886-897	Bottlenecks	
3-13	898-905	Garbage	
3-14	906-916	Collection	
3-15	917-928	Performance	
3-16	929-944	Synchronization	
3-17	945-956	Performance	
3-18	957-958	I	
3-19	958-959	/	
3-20	959-960	O	
3-21	961-972	Performance	
3-22	973-977	Code	
3-23	978-987	Execution	
3-24	988-999	Performance	
3-25	1000-1006	Flight	
3-26	1007-1015	Recorder	
3-27	1016-1024	Overhead	

#Text=When you measure performance, it is important to consider any performance overhead added by Flight Recorder. The overhead will differ depending on the application. If you have any performance tests set up, you can measure if there is any noticeable overhead on your application. The overhead for recording a standard time fixed recording (profiling recording) using the default settings is less than two percent for most applications. Running with a standard continuous recording generally has no measurable performance effect.
4-1	1025-1029	When	
4-2	1030-1033	you	
4-3	1034-1041	measure	
4-4	1042-1053	performance	
4-5	1053-1054	,	
4-6	1055-1057	it	
4-7	1058-1060	is	
4-8	1061-1070	important	
4-9	1071-1073	to	
4-10	1074-1082	consider	
4-11	1083-1086	any	
4-12	1087-1098	performance	
4-13	1099-1107	overhead	
4-14	1108-1113	added	
4-15	1114-1116	by	
4-16	1117-1123	Flight	
4-17	1124-1132	Recorder	
4-18	1132-1133	.	
4-19	1134-1137	The	
4-20	1138-1146	overhead	
4-21	1147-1151	will	
4-22	1152-1158	differ	
4-23	1159-1168	depending	
4-24	1169-1171	on	
4-25	1172-1175	the	
4-26	1176-1187	application	
4-27	1187-1188	.	
4-28	1189-1191	If	
4-29	1192-1195	you	
4-30	1196-1200	have	
4-31	1201-1204	any	
4-32	1205-1216	performance	
4-33	1217-1222	tests	
4-34	1223-1226	set	
4-35	1227-1229	up	
4-36	1229-1230	,	
4-37	1231-1234	you	
4-38	1235-1238	can	
4-39	1239-1246	measure	
4-40	1247-1249	if	
4-41	1250-1255	there	
4-42	1256-1258	is	
4-43	1259-1262	any	
4-44	1263-1273	noticeable	
4-45	1274-1282	overhead	
4-46	1283-1285	on	
4-47	1286-1290	your	
4-48	1291-1302	application	
4-49	1302-1303	.	
4-50	1304-1307	The	
4-51	1308-1316	overhead	
4-52	1317-1320	for	
4-53	1321-1330	recording	
4-54	1331-1332	a	
4-55	1333-1341	standard	
4-56	1342-1346	time	
4-57	1347-1352	fixed	
4-58	1353-1362	recording	
4-59	1363-1364	(	
4-60	1364-1373	profiling	
4-61	1374-1383	recording	
4-62	1383-1384	)	
4-63	1385-1390	using	
4-64	1391-1394	the	
4-65	1395-1402	default	
4-66	1403-1411	settings	
4-67	1412-1414	is	
4-68	1415-1419	less	
4-69	1420-1424	than	
4-70	1425-1428	two	
4-71	1429-1436	percent	
4-72	1437-1440	for	
4-73	1441-1445	most	
4-74	1446-1458	applications	
4-75	1458-1459	.	
4-76	1460-1467	Running	
4-77	1468-1472	with	
4-78	1473-1474	a	
4-79	1475-1483	standard	
4-80	1484-1494	continuous	
4-81	1495-1504	recording	
4-82	1505-1514	generally	
4-83	1515-1518	has	
4-84	1519-1521	no	
4-85	1522-1532	measurable	
4-86	1533-1544	performance	
4-87	1545-1551	effect	
4-88	1551-1552	.	

#Text=Using Heap Statistics event, which is disabled by default, can cause significant performance overhead. This is because enabling Heap Statistics triggers an old garbage collection at the beginning and the at end of the test run. These old GCs give some extra pause times to the application, so if you are measuring latency or if your environment is sensitive to pause times, do not run with Heap Statistics enabled. Heap Statistics are useful when debugging memory leaks or when investigating the live set of the application. For more information, see Use JDK Mission Control to Debug Memory Leak. Note:For performance profiling use cases, heap statistics may not be necessary. Find Bottlenecks Different applications have different bottlenecks. Waiting for I/O or networking, synchronization between threads, CPU usage or garbage collection times can cause bottlenecks in an application. It is possible that an application has more than one bottleneck.
5-1	1553-1558	Using	
5-2	1559-1563	Heap	
5-3	1564-1574	Statistics	
5-4	1575-1580	event	
5-5	1580-1581	,	
5-6	1582-1587	which	
5-7	1588-1590	is	
5-8	1591-1599	disabled	
5-9	1600-1602	by	
5-10	1603-1610	default	
5-11	1610-1611	,	
5-12	1612-1615	can	
5-13	1616-1621	cause	
5-14	1622-1633	significant	
5-15	1634-1645	performance	
5-16	1646-1654	overhead	
5-17	1654-1655	.	
5-18	1656-1660	This	
5-19	1661-1663	is	
5-20	1664-1671	because	
5-21	1672-1680	enabling	
5-22	1681-1685	Heap	
5-23	1686-1696	Statistics	
5-24	1697-1705	triggers	
5-25	1706-1708	an	
5-26	1709-1712	old	
5-27	1713-1720	garbage	
5-28	1721-1731	collection	
5-29	1732-1734	at	
5-30	1735-1738	the	
5-31	1739-1748	beginning	
5-32	1749-1752	and	
5-33	1753-1756	the	
5-34	1757-1759	at	
5-35	1760-1763	end	
5-36	1764-1766	of	
5-37	1767-1770	the	
5-38	1771-1775	test	
5-39	1776-1779	run	
5-40	1779-1780	.	
5-41	1781-1786	These	
5-42	1787-1790	old	
5-43	1791-1794	GCs	
5-44	1795-1799	give	
5-45	1800-1804	some	
5-46	1805-1810	extra	
5-47	1811-1816	pause	
5-48	1817-1822	times	
5-49	1823-1825	to	
5-50	1826-1829	the	
5-51	1830-1841	application	
5-52	1841-1842	,	
5-53	1843-1845	so	
5-54	1846-1848	if	
5-55	1849-1852	you	
5-56	1853-1856	are	
5-57	1857-1866	measuring	
5-58	1867-1874	latency	
5-59	1875-1877	or	
5-60	1878-1880	if	
5-61	1881-1885	your	
5-62	1886-1897	environment	
5-63	1898-1900	is	
5-64	1901-1910	sensitive	
5-65	1911-1913	to	
5-66	1914-1919	pause	
5-67	1920-1925	times	
5-68	1925-1926	,	
5-69	1927-1929	do	
5-70	1930-1933	not	
5-71	1934-1937	run	
5-72	1938-1942	with	
5-73	1943-1947	Heap	
5-74	1948-1958	Statistics	
5-75	1959-1966	enabled	
5-76	1966-1967	.	
5-77	1968-1972	Heap	
5-78	1973-1983	Statistics	
5-79	1984-1987	are	
5-80	1988-1994	useful	
5-81	1995-1999	when	
5-82	2000-2009	debugging	
5-83	2010-2016	memory	
5-84	2017-2022	leaks	
5-85	2023-2025	or	
5-86	2026-2030	when	
5-87	2031-2044	investigating	
5-88	2045-2048	the	
5-89	2049-2053	live	
5-90	2054-2057	set	
5-91	2058-2060	of	
5-92	2061-2064	the	
5-93	2065-2076	application	
5-94	2076-2077	.	
5-95	2078-2081	For	
5-96	2082-2086	more	
5-97	2087-2098	information	
5-98	2098-2099	,	
5-99	2100-2103	see	
5-100	2104-2107	Use	
5-101	2108-2111	JDK	
5-102	2112-2119	Mission	
5-103	2120-2127	Control	
5-104	2128-2130	to	
5-105	2131-2136	Debug	
5-106	2137-2143	Memory	
5-107	2144-2148	Leak	
5-108	2148-2149	.	
5-109	2150-2154	Note	
5-110	2154-2155	:	
5-111	2155-2158	For	
5-112	2159-2170	performance	
5-113	2171-2180	profiling	
5-114	2181-2184	use	
5-115	2185-2190	cases	
5-116	2190-2191	,	
5-117	2192-2196	heap	
5-118	2197-2207	statistics	
5-119	2208-2211	may	
5-120	2212-2215	not	
5-121	2216-2218	be	
5-122	2219-2228	necessary	
5-123	2228-2229	.	
5-124	2230-2234	Find	
5-125	2235-2246	Bottlenecks	
5-126	2247-2256	Different	
5-127	2257-2269	applications	
5-128	2270-2274	have	
5-129	2275-2284	different	
5-130	2285-2296	bottlenecks	
5-131	2296-2297	.	
5-132	2298-2305	Waiting	
5-133	2306-2309	for	
5-134	2310-2311	I	
5-135	2311-2312	/	
5-136	2312-2313	O	
5-137	2314-2316	or	
5-138	2317-2327	networking	
5-139	2327-2328	,	
5-140	2329-2344	synchronization	
5-141	2345-2352	between	
5-142	2353-2360	threads	
5-143	2360-2361	,	
5-144	2362-2365	CPU	
5-145	2366-2371	usage	
5-146	2372-2374	or	
5-147	2375-2382	garbage	
5-148	2383-2393	collection	
5-149	2394-2399	times	
5-150	2400-2403	can	
5-151	2404-2409	cause	
5-152	2410-2421	bottlenecks	
5-153	2422-2424	in	
5-154	2425-2427	an	
5-155	2428-2439	application	
5-156	2439-2440	.	
5-157	2441-2443	It	
5-158	2444-2446	is	
5-159	2447-2455	possible	
5-160	2456-2460	that	
5-161	2461-2463	an	
5-162	2464-2475	application	
5-163	2476-2479	has	
5-164	2480-2484	more	
5-165	2485-2489	than	
5-166	2490-2493	one	
5-167	2494-2504	bottleneck	
5-168	2504-2505	.	

#Text=Topics: Use JDK Mission Control to Find Bottlenecks Use the jfr Tool to Find Bottlenecks Use JDK Mission Control to Find Bottlenecks You can use JMC to find application bottlenecks.
6-1	2506-2512	Topics	
6-2	2512-2513	:	
6-3	2514-2517	Use	
6-4	2518-2521	JDK	
6-5	2522-2529	Mission	
6-6	2530-2537	Control	
6-7	2538-2540	to	
6-8	2541-2545	Find	
6-9	2546-2557	Bottlenecks	
6-10	2558-2561	Use	
6-11	2562-2565	the	
6-12	2566-2569	jfr	
6-13	2570-2574	Tool	
6-14	2575-2577	to	
6-15	2578-2582	Find	
6-16	2583-2594	Bottlenecks	
6-17	2595-2598	Use	
6-18	2599-2602	JDK	
6-19	2603-2610	Mission	
6-20	2611-2618	Control	
6-21	2619-2621	to	
6-22	2622-2626	Find	
6-23	2627-2638	Bottlenecks	
6-24	2639-2642	You	
6-25	2643-2646	can	
6-26	2647-2650	use	
6-27	2651-2654	JMC	
6-28	2655-2657	to	
6-29	2658-2662	find	
6-30	2663-2674	application	
6-31	2675-2686	bottlenecks	
6-32	2686-2687	.	

#Text=One way to find out the application bottlenecks is to analyze the Automated Analysis Results page. This page provides comprehensive automatic analysis of flight recording data. Open the Threads page in the Java Application page. The Threads page contains the following information: A graph that plots live thread usage by the application over time. A table with all live threads used by the application.
7-1	2688-2691	One	
7-2	2692-2695	way	
7-3	2696-2698	to	
7-4	2699-2703	find	
7-5	2704-2707	out	
7-6	2708-2711	the	
7-7	2712-2723	application	
7-8	2724-2735	bottlenecks	
7-9	2736-2738	is	
7-10	2739-2741	to	
7-11	2742-2749	analyze	
7-12	2750-2753	the	
7-13	2754-2763	Automated	
7-14	2764-2772	Analysis	
7-15	2773-2780	Results	
7-16	2781-2785	page	
7-17	2785-2786	.	
7-18	2787-2791	This	
7-19	2792-2796	page	
7-20	2797-2805	provides	
7-21	2806-2819	comprehensive	
7-22	2820-2829	automatic	
7-23	2830-2838	analysis	
7-24	2839-2841	of	
7-25	2842-2848	flight	
7-26	2849-2858	recording	
7-27	2859-2863	data	
7-28	2863-2864	.	
7-29	2865-2869	Open	
7-30	2870-2873	the	
7-31	2874-2881	Threads	
7-32	2882-2886	page	
7-33	2887-2889	in	
7-34	2890-2893	the	
7-35	2894-2898	Java	
7-36	2899-2910	Application	
7-37	2911-2915	page	
7-38	2915-2916	.	
7-39	2917-2920	The	
7-40	2921-2928	Threads	
7-41	2929-2933	page	
7-42	2934-2942	contains	
7-43	2943-2946	the	
7-44	2947-2956	following	
7-45	2957-2968	information	
7-46	2968-2969	:	
7-47	2970-2971	A	
7-48	2972-2977	graph	
7-49	2978-2982	that	
7-50	2983-2988	plots	
7-51	2989-2993	live	
7-52	2994-3000	thread	
7-53	3001-3006	usage	
7-54	3007-3009	by	
7-55	3010-3013	the	
7-56	3014-3025	application	
7-57	3026-3030	over	
7-58	3031-3035	time	
7-59	3035-3036	.	
7-60	3037-3038	A	
7-61	3039-3044	table	
7-62	3045-3049	with	
7-63	3050-3053	all	
7-64	3054-3058	live	
7-65	3059-3066	threads	
7-66	3067-3071	used	
7-67	3072-3074	by	
7-68	3075-3078	the	
7-69	3079-3090	application	
7-70	3090-3091	.	

#Text=Stack traces for selected threads. Here is a sample figure of a recording, which shows a graph with thread details. Figure 4-1 Bottlenecks - Threads - GraphDescription of "Figure 4-1 Bottlenecks - Threads - Graph"
8-1	3092-3097	Stack	
8-2	3098-3104	traces	
8-3	3105-3108	for	
8-4	3109-3117	selected	
8-5	3118-3125	threads	
8-6	3125-3126	.	
8-7	3127-3131	Here	
8-8	3132-3134	is	
8-9	3135-3136	a	
8-10	3137-3143	sample	
8-11	3144-3150	figure	
8-12	3151-3153	of	
8-13	3154-3155	a	
8-14	3156-3165	recording	
8-15	3165-3166	,	
8-16	3167-3172	which	
8-17	3173-3178	shows	
8-18	3179-3180	a	
8-19	3181-3186	graph	
8-20	3187-3191	with	
8-21	3192-3198	thread	
8-22	3199-3206	details	
8-23	3206-3207	.	
8-24	3208-3214	Figure	
8-25	3215-3216	4	
8-26	3216-3217	-	
8-27	3217-3218	1	
8-28	3219-3230	Bottlenecks	
8-29	3231-3232	-	
8-30	3233-3240	Threads	
8-31	3241-3242	-	
8-32	3243-3259	GraphDescription	
8-33	3260-3262	of	
8-34	3263-3264	"	
8-35	3264-3270	Figure	
8-36	3271-3272	4	
8-37	3272-3273	-	
8-38	3273-3274	1	
8-39	3275-3286	Bottlenecks	
8-40	3287-3288	-	
8-41	3289-3296	Threads	
8-42	3297-3298	-	
8-43	3299-3304	Graph	
8-44	3304-3305	"	

#Text=In the graph, each row is a thread, and each thread can have several lines. In the figure, each thread has a line, which represents the Java Application events that were enabled for this recording. The selected Java Application events all have the important property that they are all thread-stalling events. Thread stalling indicates that the thread was not running your application during the event, and they are all duration events. The duration event measures the duration the application was not running. In the graph, each color represents a different type of event. For example: Yellow represents Java Monitor Wait events. The yellow part is when threads are waiting for an object. This often means that the thread is idle, perhaps waiting for a task.
9-1	3306-3308	In	
9-2	3309-3312	the	
9-3	3313-3318	graph	
9-4	3318-3319	,	
9-5	3320-3324	each	
9-6	3325-3328	row	
9-7	3329-3331	is	
9-8	3332-3333	a	
9-9	3334-3340	thread	
9-10	3340-3341	,	
9-11	3342-3345	and	
9-12	3346-3350	each	
9-13	3351-3357	thread	
9-14	3358-3361	can	
9-15	3362-3366	have	
9-16	3367-3374	several	
9-17	3375-3380	lines	
9-18	3380-3381	.	
9-19	3382-3384	In	
9-20	3385-3388	the	
9-21	3389-3395	figure	
9-22	3395-3396	,	
9-23	3397-3401	each	
9-24	3402-3408	thread	
9-25	3409-3412	has	
9-26	3413-3414	a	
9-27	3415-3419	line	
9-28	3419-3420	,	
9-29	3421-3426	which	
9-30	3427-3437	represents	
9-31	3438-3441	the	
9-32	3442-3446	Java	
9-33	3447-3458	Application	
9-34	3459-3465	events	
9-35	3466-3470	that	
9-36	3471-3475	were	
9-37	3476-3483	enabled	
9-38	3484-3487	for	
9-39	3488-3492	this	
9-40	3493-3502	recording	
9-41	3502-3503	.	
9-42	3504-3507	The	
9-43	3508-3516	selected	
9-44	3517-3521	Java	
9-45	3522-3533	Application	
9-46	3534-3540	events	
9-47	3541-3544	all	
9-48	3545-3549	have	
9-49	3550-3553	the	
9-50	3554-3563	important	
9-51	3564-3572	property	
9-52	3573-3577	that	
9-53	3578-3582	they	
9-54	3583-3586	are	
9-55	3587-3590	all	
9-56	3591-3606	thread-stalling	
9-57	3607-3613	events	
9-58	3613-3614	.	
9-59	3615-3621	Thread	
9-60	3622-3630	stalling	
9-61	3631-3640	indicates	
9-62	3641-3645	that	
9-63	3646-3649	the	
9-64	3650-3656	thread	
9-65	3657-3660	was	
9-66	3661-3664	not	
9-67	3665-3672	running	
9-68	3673-3677	your	
9-69	3678-3689	application	
9-70	3690-3696	during	
9-71	3697-3700	the	
9-72	3701-3706	event	
9-73	3706-3707	,	
9-74	3708-3711	and	
9-75	3712-3716	they	
9-76	3717-3720	are	
9-77	3721-3724	all	
9-78	3725-3733	duration	
9-79	3734-3740	events	
9-80	3740-3741	.	
9-81	3742-3745	The	
9-82	3746-3754	duration	
9-83	3755-3760	event	
9-84	3761-3769	measures	
9-85	3770-3773	the	
9-86	3774-3782	duration	
9-87	3783-3786	the	
9-88	3787-3798	application	
9-89	3799-3802	was	
9-90	3803-3806	not	
9-91	3807-3814	running	
9-92	3814-3815	.	
9-93	3816-3818	In	
9-94	3819-3822	the	
9-95	3823-3828	graph	
9-96	3828-3829	,	
9-97	3830-3834	each	
9-98	3835-3840	color	
9-99	3841-3851	represents	
9-100	3852-3853	a	
9-101	3854-3863	different	
9-102	3864-3868	type	
9-103	3869-3871	of	
9-104	3872-3877	event	
9-105	3877-3878	.	
9-106	3879-3882	For	
9-107	3883-3890	example	
9-108	3890-3891	:	
9-109	3892-3898	Yellow	
9-110	3899-3909	represents	
9-111	3910-3914	Java	
9-112	3915-3922	Monitor	
9-113	3923-3927	Wait	
9-114	3928-3934	events	
9-115	3934-3935	.	
9-116	3936-3939	The	
9-117	3940-3946	yellow	
9-118	3947-3951	part	
9-119	3952-3954	is	
9-120	3955-3959	when	
9-121	3960-3967	threads	
9-122	3968-3971	are	
9-123	3972-3979	waiting	
9-124	3980-3983	for	
9-125	3984-3986	an	
9-126	3987-3993	object	
9-127	3993-3994	.	
9-128	3995-3999	This	
9-129	4000-4005	often	
9-130	4006-4011	means	
9-131	4012-4016	that	
9-132	4017-4020	the	
9-133	4021-4027	thread	
9-134	4028-4030	is	
9-135	4031-4035	idle	
9-136	4035-4036	,	
9-137	4037-4044	perhaps	
9-138	4045-4052	waiting	
9-139	4053-4056	for	
9-140	4057-4058	a	
9-141	4059-4063	task	
9-142	4063-4064	.	

#Text=Salmon represents the Java Monitor Blocked events or synchronization events. If your Java application's important threads spend a lot of time being blocked, then that means that a critical section of the application is single threaded, which is a bottleneck. Red represents the Socket Reads and Socket Writes events. Again, if the Java application spends a lot of time waiting for sockets, then the main bottleneck may be in the network or with the other machines that the application communicates.
10-1	4065-4071	Salmon	
10-2	4072-4082	represents	
10-3	4083-4086	the	
10-4	4087-4091	Java	
10-5	4092-4099	Monitor	
10-6	4100-4107	Blocked	
10-7	4108-4114	events	
10-8	4115-4117	or	
10-9	4118-4133	synchronization	
10-10	4134-4140	events	
10-11	4140-4141	.	
10-12	4142-4144	If	
10-13	4145-4149	your	
10-14	4150-4154	Java	
10-15	4155-4168	application's	
10-16	4169-4178	important	
10-17	4179-4186	threads	
10-18	4187-4192	spend	
10-19	4193-4194	a	
10-20	4195-4198	lot	
10-21	4199-4201	of	
10-22	4202-4206	time	
10-23	4207-4212	being	
10-24	4213-4220	blocked	
10-25	4220-4221	,	
10-26	4222-4226	then	
10-27	4227-4231	that	
10-28	4232-4237	means	
10-29	4238-4242	that	
10-30	4243-4244	a	
10-31	4245-4253	critical	
10-32	4254-4261	section	
10-33	4262-4264	of	
10-34	4265-4268	the	
10-35	4269-4280	application	
10-36	4281-4283	is	
10-37	4284-4290	single	
10-38	4291-4299	threaded	
10-39	4299-4300	,	
10-40	4301-4306	which	
10-41	4307-4309	is	
10-42	4310-4311	a	
10-43	4312-4322	bottleneck	
10-44	4322-4323	.	
10-45	4324-4327	Red	
10-46	4328-4338	represents	
10-47	4339-4342	the	
10-48	4343-4349	Socket	
10-49	4350-4355	Reads	
10-50	4356-4359	and	
10-51	4360-4366	Socket	
10-52	4367-4373	Writes	
10-53	4374-4380	events	
10-54	4380-4381	.	
10-55	4382-4387	Again	
10-56	4387-4388	,	
10-57	4389-4391	if	
10-58	4392-4395	the	
10-59	4396-4400	Java	
10-60	4401-4412	application	
10-61	4413-4419	spends	
10-62	4420-4421	a	
10-63	4422-4425	lot	
10-64	4426-4428	of	
10-65	4429-4433	time	
10-66	4434-4441	waiting	
10-67	4442-4445	for	
10-68	4446-4453	sockets	
10-69	4453-4454	,	
10-70	4455-4459	then	
10-71	4460-4463	the	
10-72	4464-4468	main	
10-73	4469-4479	bottleneck	
10-74	4480-4483	may	
10-75	4484-4486	be	
10-76	4487-4489	in	
10-77	4490-4493	the	
10-78	4494-4501	network	
10-79	4502-4504	or	
10-80	4505-4509	with	
10-81	4510-4513	the	
10-82	4514-4519	other	
10-83	4520-4528	machines	
10-84	4529-4533	that	
10-85	4534-4537	the	
10-86	4538-4549	application	
10-87	4550-4562	communicates	
10-88	4562-4563	.	

#Text=Green represents parts that don't have any events. This part means that the thread is not sleeping, waiting, reading to or from a socket, or not being blocked. In general, this is where the application code is run. If your Java application's important threads are spending a lot of time without generating any application events, then the bottleneck in the application is the time spent executing code or the CPU itself. Note:For most Java Application event types, only events longer than 20 ms are recorded. (This threshold can be modified when starting the flight recording.) The areas may not have recorded events because the application is doing a lot of short tasks, such as writing to a file (a small part at a time) or spending time in synchronization for very short amounts of time.
11-1	4564-4569	Green	
11-2	4570-4580	represents	
11-3	4581-4586	parts	
11-4	4587-4591	that	
11-5	4592-4597	don't	
11-6	4598-4602	have	
11-7	4603-4606	any	
11-8	4607-4613	events	
11-9	4613-4614	.	
11-10	4615-4619	This	
11-11	4620-4624	part	
11-12	4625-4630	means	
11-13	4631-4635	that	
11-14	4636-4639	the	
11-15	4640-4646	thread	
11-16	4647-4649	is	
11-17	4650-4653	not	
11-18	4654-4662	sleeping	
11-19	4662-4663	,	
11-20	4664-4671	waiting	
11-21	4671-4672	,	
11-22	4673-4680	reading	
11-23	4681-4683	to	
11-24	4684-4686	or	
11-25	4687-4691	from	
11-26	4692-4693	a	
11-27	4694-4700	socket	
11-28	4700-4701	,	
11-29	4702-4704	or	
11-30	4705-4708	not	
11-31	4709-4714	being	
11-32	4715-4722	blocked	
11-33	4722-4723	.	
11-34	4724-4726	In	
11-35	4727-4734	general	
11-36	4734-4735	,	
11-37	4736-4740	this	
11-38	4741-4743	is	
11-39	4744-4749	where	
11-40	4750-4753	the	
11-41	4754-4765	application	
11-42	4766-4770	code	
11-43	4771-4773	is	
11-44	4774-4777	run	
11-45	4777-4778	.	
11-46	4779-4781	If	
11-47	4782-4786	your	
11-48	4787-4791	Java	
11-49	4792-4805	application's	
11-50	4806-4815	important	
11-51	4816-4823	threads	
11-52	4824-4827	are	
11-53	4828-4836	spending	
11-54	4837-4838	a	
11-55	4839-4842	lot	
11-56	4843-4845	of	
11-57	4846-4850	time	
11-58	4851-4858	without	
11-59	4859-4869	generating	
11-60	4870-4873	any	
11-61	4874-4885	application	
11-62	4886-4892	events	
11-63	4892-4893	,	
11-64	4894-4898	then	
11-65	4899-4902	the	
11-66	4903-4913	bottleneck	
11-67	4914-4916	in	
11-68	4917-4920	the	
11-69	4921-4932	application	
11-70	4933-4935	is	
11-71	4936-4939	the	
11-72	4940-4944	time	
11-73	4945-4950	spent	
11-74	4951-4960	executing	
11-75	4961-4965	code	
11-76	4966-4968	or	
11-77	4969-4972	the	
11-78	4973-4976	CPU	
11-79	4977-4983	itself	
11-80	4983-4984	.	
11-81	4985-4989	Note	
11-82	4989-4990	:	
11-83	4990-4993	For	
11-84	4994-4998	most	
11-85	4999-5003	Java	
11-86	5004-5015	Application	
11-87	5016-5021	event	
11-88	5022-5027	types	
11-89	5027-5028	,	
11-90	5029-5033	only	
11-91	5034-5040	events	
11-92	5041-5047	longer	
11-93	5048-5052	than	
11-94	5053-5055	20	
11-95	5056-5058	ms	
11-96	5059-5062	are	
11-97	5063-5071	recorded	
11-98	5071-5072	.	
11-99	5073-5074	(	
11-100	5074-5078	This	
11-101	5079-5088	threshold	
11-102	5089-5092	can	
11-103	5093-5095	be	
11-104	5096-5104	modified	
11-105	5105-5109	when	
11-106	5110-5118	starting	
11-107	5119-5122	the	
11-108	5123-5129	flight	
11-109	5130-5139	recording	
11-110	5139-5140	.	
11-111	5140-5141	)	
11-112	5142-5145	The	
11-113	5146-5151	areas	
11-114	5152-5155	may	
11-115	5156-5159	not	
11-116	5160-5164	have	
11-117	5165-5173	recorded	
11-118	5174-5180	events	
11-119	5181-5188	because	
11-120	5189-5192	the	
11-121	5193-5204	application	
11-122	5205-5207	is	
11-123	5208-5213	doing	
11-124	5214-5215	a	
11-125	5216-5219	lot	
11-126	5220-5222	of	
11-127	5223-5228	short	
11-128	5229-5234	tasks	
11-129	5234-5235	,	
11-130	5236-5240	such	
11-131	5241-5243	as	
11-132	5244-5251	writing	
11-133	5252-5254	to	
11-134	5255-5256	a	
11-135	5257-5261	file	
11-136	5262-5263	(	
11-137	5263-5264	a	
11-138	5265-5270	small	
11-139	5271-5275	part	
11-140	5276-5278	at	
11-141	5279-5280	a	
11-142	5281-5285	time	
11-143	5285-5286	)	
11-144	5287-5289	or	
11-145	5290-5298	spending	
11-146	5299-5303	time	
11-147	5304-5306	in	
11-148	5307-5322	synchronization	
11-149	5323-5326	for	
11-150	5327-5331	very	
11-151	5332-5337	short	
11-152	5338-5345	amounts	
11-153	5346-5348	of	
11-154	5349-5353	time	
11-155	5353-5354	.	

#Text=The Automated Analysis Results page also shows information about garbage collections. To see if garbage collections may be a bottleneck, see the next topic about garbage collection performance. Use the jfr Tool to Find Bottlenecks Different applications have different bottlenecks. For some applications, a bottleneck may be waiting for I/O or networking, it may be synchronization between threads, or it may be actual CPU usage. For others, a bottleneck may be garbage collection times. It is possible that an application has more than one bottleneck.
12-1	5355-5358	The	
12-2	5359-5368	Automated	
12-3	5369-5377	Analysis	
12-4	5378-5385	Results	
12-5	5386-5390	page	
12-6	5391-5395	also	
12-7	5396-5401	shows	
12-8	5402-5413	information	
12-9	5414-5419	about	
12-10	5420-5427	garbage	
12-11	5428-5439	collections	
12-12	5439-5440	.	
12-13	5441-5443	To	
12-14	5444-5447	see	
12-15	5448-5450	if	
12-16	5451-5458	garbage	
12-17	5459-5470	collections	
12-18	5471-5474	may	
12-19	5475-5477	be	
12-20	5478-5479	a	
12-21	5480-5490	bottleneck	
12-22	5490-5491	,	
12-23	5492-5495	see	
12-24	5496-5499	the	
12-25	5500-5504	next	
12-26	5505-5510	topic	
12-27	5511-5516	about	
12-28	5517-5524	garbage	
12-29	5525-5535	collection	
12-30	5536-5547	performance	
12-31	5547-5548	.	
12-32	5549-5552	Use	
12-33	5553-5556	the	
12-34	5557-5560	jfr	
12-35	5561-5565	Tool	
12-36	5566-5568	to	
12-37	5569-5573	Find	
12-38	5574-5585	Bottlenecks	
12-39	5586-5595	Different	
12-40	5596-5608	applications	
12-41	5609-5613	have	
12-42	5614-5623	different	
12-43	5624-5635	bottlenecks	
12-44	5635-5636	.	
12-45	5637-5640	For	
12-46	5641-5645	some	
12-47	5646-5658	applications	
12-48	5658-5659	,	
12-49	5660-5661	a	
12-50	5662-5672	bottleneck	
12-51	5673-5676	may	
12-52	5677-5679	be	
12-53	5680-5687	waiting	
12-54	5688-5691	for	
12-55	5692-5693	I	
12-56	5693-5694	/	
12-57	5694-5695	O	
12-58	5696-5698	or	
12-59	5699-5709	networking	
12-60	5709-5710	,	
12-61	5711-5713	it	
12-62	5714-5717	may	
12-63	5718-5720	be	
12-64	5721-5736	synchronization	
12-65	5737-5744	between	
12-66	5745-5752	threads	
12-67	5752-5753	,	
12-68	5754-5756	or	
12-69	5757-5759	it	
12-70	5760-5763	may	
12-71	5764-5766	be	
12-72	5767-5773	actual	
12-73	5774-5777	CPU	
12-74	5778-5783	usage	
12-75	5783-5784	.	
12-76	5785-5788	For	
12-77	5789-5795	others	
12-78	5795-5796	,	
12-79	5797-5798	a	
12-80	5799-5809	bottleneck	
12-81	5810-5813	may	
12-82	5814-5816	be	
12-83	5817-5824	garbage	
12-84	5825-5835	collection	
12-85	5836-5841	times	
12-86	5841-5842	.	
12-87	5843-5845	It	
12-88	5846-5848	is	
12-89	5849-5857	possible	
12-90	5858-5862	that	
12-91	5863-5865	an	
12-92	5866-5877	application	
12-93	5878-5881	has	
12-94	5882-5886	more	
12-95	5887-5891	than	
12-96	5892-5895	one	
12-97	5896-5906	bottleneck	
12-98	5906-5907	.	

#Text=One way to find the application bottlenecks is to look at the following events in your flight recording. Make sure that all of these events are enabled in the recording template that you are using: jdk.FileRead jdk.FileWrite jdk.SocketRead jdk.SocketWrite jdk.JavaErrorThrow jdk.JavaExceptionThrow
13-1	5908-5911	One	
13-2	5912-5915	way	
13-3	5916-5918	to	
13-4	5919-5923	find	
13-5	5924-5927	the	
13-6	5928-5939	application	
13-7	5940-5951	bottlenecks	
13-8	5952-5954	is	
13-9	5955-5957	to	
13-10	5958-5962	look	
13-11	5963-5965	at	
13-12	5966-5969	the	
13-13	5970-5979	following	
13-14	5980-5986	events	
13-15	5987-5989	in	
13-16	5990-5994	your	
13-17	5995-6001	flight	
13-18	6002-6011	recording	
13-19	6011-6012	.	
13-20	6013-6017	Make	
13-21	6018-6022	sure	
13-22	6023-6027	that	
13-23	6028-6031	all	
13-24	6032-6034	of	
13-25	6035-6040	these	
13-26	6041-6047	events	
13-27	6048-6051	are	
13-28	6052-6059	enabled	
13-29	6060-6062	in	
13-30	6063-6066	the	
13-31	6067-6076	recording	
13-32	6077-6085	template	
13-33	6086-6090	that	
13-34	6091-6094	you	
13-35	6095-6098	are	
13-36	6099-6104	using	
13-37	6104-6105	:	
13-38	6106-6118	jdk.FileRead	
13-39	6119-6132	jdk.FileWrite	
13-40	6133-6147	jdk.SocketRead	
13-41	6148-6163	jdk.SocketWrite	
13-42	6164-6182	jdk.JavaErrorThrow	
13-43	6183-6205	jdk.JavaExceptionThrow	

#Text=jdk.JavaMonitorEnter jdk.JavaMonitorWait jdk.ThreadStart jdk.ThreadEnd jdk.ThreadSleep jdk.ThreadPark
14-1	6206-6226	jdk.JavaMonitorEnter	
14-2	6227-6246	jdk.JavaMonitorWait	
14-3	6247-6262	jdk.ThreadStart	
14-4	6263-6276	jdk.ThreadEnd	
14-5	6277-6292	jdk.ThreadSleep	
14-6	6293-6307	jdk.ThreadPark	

#Text=The selected Java Application events all have the important property that they are all thread-stalling events. Thread stalling indicates that the thread was not running your application during the event, and they are all duration events. The duration event measures the duration the application was not running. Use the jfr tool to print the events that were recorded and look for the following information: jdk.JavaMonitorWait events show how much time a thread spends waiting for a monitor. jdk.ThreadSleep and jdk.ThreadPark events show when a thread is sleeping or parked.
15-1	6308-6311	The	
15-2	6312-6320	selected	
15-3	6321-6325	Java	
15-4	6326-6337	Application	
15-5	6338-6344	events	
15-6	6345-6348	all	
15-7	6349-6353	have	
15-8	6354-6357	the	
15-9	6358-6367	important	
15-10	6368-6376	property	
15-11	6377-6381	that	
15-12	6382-6386	they	
15-13	6387-6390	are	
15-14	6391-6394	all	
15-15	6395-6410	thread-stalling	
15-16	6411-6417	events	
15-17	6417-6418	.	
15-18	6419-6425	Thread	
15-19	6426-6434	stalling	
15-20	6435-6444	indicates	
15-21	6445-6449	that	
15-22	6450-6453	the	
15-23	6454-6460	thread	
15-24	6461-6464	was	
15-25	6465-6468	not	
15-26	6469-6476	running	
15-27	6477-6481	your	
15-28	6482-6493	application	
15-29	6494-6500	during	
15-30	6501-6504	the	
15-31	6505-6510	event	
15-32	6510-6511	,	
15-33	6512-6515	and	
15-34	6516-6520	they	
15-35	6521-6524	are	
15-36	6525-6528	all	
15-37	6529-6537	duration	
15-38	6538-6544	events	
15-39	6544-6545	.	
15-40	6546-6549	The	
15-41	6550-6558	duration	
15-42	6559-6564	event	
15-43	6565-6573	measures	
15-44	6574-6577	the	
15-45	6578-6586	duration	
15-46	6587-6590	the	
15-47	6591-6602	application	
15-48	6603-6606	was	
15-49	6607-6610	not	
15-50	6611-6618	running	
15-51	6618-6619	.	
15-52	6620-6623	Use	
15-53	6624-6627	the	
15-54	6628-6631	jfr	
15-55	6632-6636	tool	
15-56	6637-6639	to	
15-57	6640-6645	print	
15-58	6646-6649	the	
15-59	6650-6656	events	
15-60	6657-6661	that	
15-61	6662-6666	were	
15-62	6667-6675	recorded	
15-63	6676-6679	and	
15-64	6680-6684	look	
15-65	6685-6688	for	
15-66	6689-6692	the	
15-67	6693-6702	following	
15-68	6703-6714	information	
15-69	6714-6715	:	
15-70	6716-6735	jdk.JavaMonitorWait	
15-71	6736-6742	events	
15-72	6743-6747	show	
15-73	6748-6751	how	
15-74	6752-6756	much	
15-75	6757-6761	time	
15-76	6762-6763	a	
15-77	6764-6770	thread	
15-78	6771-6777	spends	
15-79	6778-6785	waiting	
15-80	6786-6789	for	
15-81	6790-6791	a	
15-82	6792-6799	monitor	
15-83	6799-6800	.	
15-84	6801-6816	jdk.ThreadSleep	
15-85	6817-6820	and	
15-86	6821-6835	jdk.ThreadPark	
15-87	6836-6842	events	
15-88	6843-6847	show	
15-89	6848-6852	when	
15-90	6853-6854	a	
15-91	6855-6861	thread	
15-92	6862-6864	is	
15-93	6865-6873	sleeping	
15-94	6874-6876	or	
15-95	6877-6883	parked	
15-96	6883-6884	.	

#Text=Read and write events show how much time is spent in I/O. If your Java application's important threads spend a lot of time being blocked, then that means that a critical section of the application is single threaded, which is a bottleneck. If the Java application spends a lot of time waiting for sockets, then the main bottleneck may be in the network or with the other machines that the application communicates with. If your Java application's important threads are spending a lot of time without generating any application events, then the bottleneck in the application is the time spent executing code or the CPU itself. Each of these bottlenecks can be further investigated within the flight recording.
16-1	6885-6889	Read	
16-2	6890-6893	and	
16-3	6894-6899	write	
16-4	6900-6906	events	
16-5	6907-6911	show	
16-6	6912-6915	how	
16-7	6916-6920	much	
16-8	6921-6925	time	
16-9	6926-6928	is	
16-10	6929-6934	spent	
16-11	6935-6937	in	
16-12	6938-6939	I	
16-13	6939-6940	/	
16-14	6940-6941	O	
16-15	6941-6942	.	
16-16	6943-6945	If	
16-17	6946-6950	your	
16-18	6951-6955	Java	
16-19	6956-6969	application's	
16-20	6970-6979	important	
16-21	6980-6987	threads	
16-22	6988-6993	spend	
16-23	6994-6995	a	
16-24	6996-6999	lot	
16-25	7000-7002	of	
16-26	7003-7007	time	
16-27	7008-7013	being	
16-28	7014-7021	blocked	
16-29	7021-7022	,	
16-30	7023-7027	then	
16-31	7028-7032	that	
16-32	7033-7038	means	
16-33	7039-7043	that	
16-34	7044-7045	a	
16-35	7046-7054	critical	
16-36	7055-7062	section	
16-37	7063-7065	of	
16-38	7066-7069	the	
16-39	7070-7081	application	
16-40	7082-7084	is	
16-41	7085-7091	single	
16-42	7092-7100	threaded	
16-43	7100-7101	,	
16-44	7102-7107	which	
16-45	7108-7110	is	
16-46	7111-7112	a	
16-47	7113-7123	bottleneck	
16-48	7123-7124	.	
16-49	7125-7127	If	
16-50	7128-7131	the	
16-51	7132-7136	Java	
16-52	7137-7148	application	
16-53	7149-7155	spends	
16-54	7156-7157	a	
16-55	7158-7161	lot	
16-56	7162-7164	of	
16-57	7165-7169	time	
16-58	7170-7177	waiting	
16-59	7178-7181	for	
16-60	7182-7189	sockets	
16-61	7189-7190	,	
16-62	7191-7195	then	
16-63	7196-7199	the	
16-64	7200-7204	main	
16-65	7205-7215	bottleneck	
16-66	7216-7219	may	
16-67	7220-7222	be	
16-68	7223-7225	in	
16-69	7226-7229	the	
16-70	7230-7237	network	
16-71	7238-7240	or	
16-72	7241-7245	with	
16-73	7246-7249	the	
16-74	7250-7255	other	
16-75	7256-7264	machines	
16-76	7265-7269	that	
16-77	7270-7273	the	
16-78	7274-7285	application	
16-79	7286-7298	communicates	
16-80	7299-7303	with	
16-81	7303-7304	.	
16-82	7305-7307	If	
16-83	7308-7312	your	
16-84	7313-7317	Java	
16-85	7318-7331	application's	
16-86	7332-7341	important	
16-87	7342-7349	threads	
16-88	7350-7353	are	
16-89	7354-7362	spending	
16-90	7363-7364	a	
16-91	7365-7368	lot	
16-92	7369-7371	of	
16-93	7372-7376	time	
16-94	7377-7384	without	
16-95	7385-7395	generating	
16-96	7396-7399	any	
16-97	7400-7411	application	
16-98	7412-7418	events	
16-99	7418-7419	,	
16-100	7420-7424	then	
16-101	7425-7428	the	
16-102	7429-7439	bottleneck	
16-103	7440-7442	in	
16-104	7443-7446	the	
16-105	7447-7458	application	
16-106	7459-7461	is	
16-107	7462-7465	the	
16-108	7466-7470	time	
16-109	7471-7476	spent	
16-110	7477-7486	executing	
16-111	7487-7491	code	
16-112	7492-7494	or	
16-113	7495-7498	the	
16-114	7499-7502	CPU	
16-115	7503-7509	itself	
16-116	7509-7510	.	
16-117	7511-7515	Each	
16-118	7516-7518	of	
16-119	7519-7524	these	
16-120	7525-7536	bottlenecks	
16-121	7537-7540	can	
16-122	7541-7543	be	
16-123	7544-7551	further	
16-124	7552-7564	investigated	
16-125	7565-7571	within	
16-126	7572-7575	the	
16-127	7576-7582	flight	
16-128	7583-7592	recording	
16-129	7592-7593	.	

#Text=Note:For most Java Application event types, only events longer than 20 ms are recorded. (This threshold can be modified when starting the flight recording.) To summarize, the areas may not have recorded events because the application is doing a lot of short tasks, such as writing to a file (a small part at a time) or spending time in synchronization for very short amounts of time. Garbage Collection Performance Flight recordings can help you diagnose garbage collection issues in Java application. Topics: Use JDK Mission Control to Debug Garbage Collection Issues Use the jfr Tool to Debug Garbage Collection Issues
17-1	7594-7598	Note	
17-2	7598-7599	:	
17-3	7599-7602	For	
17-4	7603-7607	most	
17-5	7608-7612	Java	
17-6	7613-7624	Application	
17-7	7625-7630	event	
17-8	7631-7636	types	
17-9	7636-7637	,	
17-10	7638-7642	only	
17-11	7643-7649	events	
17-12	7650-7656	longer	
17-13	7657-7661	than	
17-14	7662-7664	20	
17-15	7665-7667	ms	
17-16	7668-7671	are	
17-17	7672-7680	recorded	
17-18	7680-7681	.	
17-19	7682-7683	(	
17-20	7683-7687	This	
17-21	7688-7697	threshold	
17-22	7698-7701	can	
17-23	7702-7704	be	
17-24	7705-7713	modified	
17-25	7714-7718	when	
17-26	7719-7727	starting	
17-27	7728-7731	the	
17-28	7732-7738	flight	
17-29	7739-7748	recording	
17-30	7748-7749	.	
17-31	7749-7750	)	
17-32	7751-7753	To	
17-33	7754-7763	summarize	
17-34	7763-7764	,	
17-35	7765-7768	the	
17-36	7769-7774	areas	
17-37	7775-7778	may	
17-38	7779-7782	not	
17-39	7783-7787	have	
17-40	7788-7796	recorded	
17-41	7797-7803	events	
17-42	7804-7811	because	
17-43	7812-7815	the	
17-44	7816-7827	application	
17-45	7828-7830	is	
17-46	7831-7836	doing	
17-47	7837-7838	a	
17-48	7839-7842	lot	
17-49	7843-7845	of	
17-50	7846-7851	short	
17-51	7852-7857	tasks	
17-52	7857-7858	,	
17-53	7859-7863	such	
17-54	7864-7866	as	
17-55	7867-7874	writing	
17-56	7875-7877	to	
17-57	7878-7879	a	
17-58	7880-7884	file	
17-59	7885-7886	(	
17-60	7886-7887	a	
17-61	7888-7893	small	
17-62	7894-7898	part	
17-63	7899-7901	at	
17-64	7902-7903	a	
17-65	7904-7908	time	
17-66	7908-7909	)	
17-67	7910-7912	or	
17-68	7913-7921	spending	
17-69	7922-7926	time	
17-70	7927-7929	in	
17-71	7930-7945	synchronization	
17-72	7946-7949	for	
17-73	7950-7954	very	
17-74	7955-7960	short	
17-75	7961-7968	amounts	
17-76	7969-7971	of	
17-77	7972-7976	time	
17-78	7976-7977	.	
17-79	7978-7985	Garbage	
17-80	7986-7996	Collection	
17-81	7997-8008	Performance	
17-82	8009-8015	Flight	
17-83	8016-8026	recordings	
17-84	8027-8030	can	
17-85	8031-8035	help	
17-86	8036-8039	you	
17-87	8040-8048	diagnose	
17-88	8049-8056	garbage	
17-89	8057-8067	collection	
17-90	8068-8074	issues	
17-91	8075-8077	in	
17-92	8078-8082	Java	
17-93	8083-8094	application	
17-94	8094-8095	.	
17-95	8096-8102	Topics	
17-96	8102-8103	:	
17-97	8104-8107	Use	
17-98	8108-8111	JDK	
17-99	8112-8119	Mission	
17-100	8120-8127	Control	
17-101	8128-8130	to	
17-102	8131-8136	Debug	
17-103	8137-8144	Garbage	
17-104	8145-8155	Collection	
17-105	8156-8162	Issues	
17-106	8163-8166	Use	
17-107	8167-8170	the	
17-108	8171-8174	jfr	
17-109	8175-8179	Tool	
17-110	8180-8182	to	
17-111	8183-8188	Debug	
17-112	8189-8196	Garbage	
17-113	8197-8207	Collection	
17-114	8208-8214	Issues	

#Text=Use JDK Mission Control to Debug Garbage Collection Issues You can use JMC to debug garbage collections (GC) issues. Tuning the HotSpot Garbage Collector can have a big effect on performance. See Garbage Collection Tuning Guide for general information.
18-1	8215-8218	Use	
18-2	8219-8222	JDK	
18-3	8223-8230	Mission	
18-4	8231-8238	Control	
18-5	8239-8241	to	
18-6	8242-8247	Debug	
18-7	8248-8255	Garbage	
18-8	8256-8266	Collection	
18-9	8267-8273	Issues	
18-10	8274-8277	You	
18-11	8278-8281	can	
18-12	8282-8285	use	
18-13	8286-8289	JMC	
18-14	8290-8292	to	
18-15	8293-8298	debug	
18-16	8299-8306	garbage	
18-17	8307-8318	collections	
18-18	8319-8320	(	
18-19	8320-8322	GC	
18-20	8322-8323	)	
18-21	8324-8330	issues	
18-22	8330-8331	.	
18-23	8332-8338	Tuning	
18-24	8339-8342	the	
18-25	8343-8350	HotSpot	
18-26	8351-8358	Garbage	
18-27	8359-8368	Collector	
18-28	8369-8372	can	
18-29	8373-8377	have	
18-30	8378-8379	a	
18-31	8380-8383	big	
18-32	8384-8390	effect	
18-33	8391-8393	on	
18-34	8394-8405	performance	
18-35	8405-8406	.	
18-36	8407-8410	See	
18-37	8411-8418	Garbage	
18-38	8419-8429	Collection	
18-39	8430-8436	Tuning	
18-40	8437-8442	Guide	
18-41	8443-8446	for	
18-42	8447-8454	general	
18-43	8455-8466	information	
18-44	8466-8467	.	

#Text=Take a profiling flight recording of your running application. Do not include the heap statistics, as that will trigger additional old garbage collections. To get a good sample, take a longer recording, for example one hour. Open the recording in JMC. Look at the Garbage Collections section in the Automated Analysis Results page. Here is a sample figure of a recording, which provides a snapshot of garbage collection performance during runtime. Figure 4-2 Automated Analysis Results - Garbage Collections Description of "Figure 4-2 Automated Analysis Results - Garbage Collections "
19-1	8468-8472	Take	
19-2	8473-8474	a	
19-3	8475-8484	profiling	
19-4	8485-8491	flight	
19-5	8492-8501	recording	
19-6	8502-8504	of	
19-7	8505-8509	your	
19-8	8510-8517	running	
19-9	8518-8529	application	
19-10	8529-8530	.	
19-11	8531-8533	Do	
19-12	8534-8537	not	
19-13	8538-8545	include	
19-14	8546-8549	the	
19-15	8550-8554	heap	
19-16	8555-8565	statistics	
19-17	8565-8566	,	
19-18	8567-8569	as	
19-19	8570-8574	that	
19-20	8575-8579	will	
19-21	8580-8587	trigger	
19-22	8588-8598	additional	
19-23	8599-8602	old	
19-24	8603-8610	garbage	
19-25	8611-8622	collections	
19-26	8622-8623	.	
19-27	8624-8626	To	
19-28	8627-8630	get	
19-29	8631-8632	a	
19-30	8633-8637	good	
19-31	8638-8644	sample	
19-32	8644-8645	,	
19-33	8646-8650	take	
19-34	8651-8652	a	
19-35	8653-8659	longer	
19-36	8660-8669	recording	
19-37	8669-8670	,	
19-38	8671-8674	for	
19-39	8675-8682	example	
19-40	8683-8686	one	
19-41	8687-8691	hour	
19-42	8691-8692	.	
19-43	8693-8697	Open	
19-44	8698-8701	the	
19-45	8702-8711	recording	
19-46	8712-8714	in	
19-47	8715-8718	JMC	
19-48	8718-8719	.	
19-49	8720-8724	Look	
19-50	8725-8727	at	
19-51	8728-8731	the	
19-52	8732-8739	Garbage	
19-53	8740-8751	Collections	
19-54	8752-8759	section	
19-55	8760-8762	in	
19-56	8763-8766	the	
19-57	8767-8776	Automated	
19-58	8777-8785	Analysis	
19-59	8786-8793	Results	
19-60	8794-8798	page	
19-61	8798-8799	.	
19-62	8800-8804	Here	
19-63	8805-8807	is	
19-64	8808-8809	a	
19-65	8810-8816	sample	
19-66	8817-8823	figure	
19-67	8824-8826	of	
19-68	8827-8828	a	
19-69	8829-8838	recording	
19-70	8838-8839	,	
19-71	8840-8845	which	
19-72	8846-8854	provides	
19-73	8855-8856	a	
19-74	8857-8865	snapshot	
19-75	8866-8868	of	
19-76	8869-8876	garbage	
19-77	8877-8887	collection	
19-78	8888-8899	performance	
19-79	8900-8906	during	
19-80	8907-8914	runtime	
19-81	8914-8915	.	
19-82	8916-8922	Figure	
19-83	8923-8924	4	
19-84	8924-8925	-	
19-85	8925-8926	2	
19-86	8927-8936	Automated	
19-87	8937-8945	Analysis	
19-88	8946-8953	Results	
19-89	8954-8955	-	
19-90	8956-8963	Garbage	
19-91	8964-8975	Collections	
19-92	8976-8987	Description	
19-93	8988-8990	of	
19-94	8991-8992	"	
19-95	8992-8998	Figure	
19-96	8999-9000	4	
19-97	9000-9001	-	
19-98	9001-9002	2	
19-99	9003-9012	Automated	
19-100	9013-9021	Analysis	
19-101	9022-9029	Results	
19-102	9030-9031	-	
19-103	9032-9039	Garbage	
19-104	9040-9051	Collections	
19-105	9052-9053	"	

#Text=You can observe from the figure that there is a Full GC event. This is indicative of the fact that application needs more memory than what you have allocated. For further analysis, open the Garbage Collections page under the JVM Internals page to investigate the overall performance impact of the GC. Here is a sample figure of a recording, which shows a graph with GC pauses.
20-1	9054-9057	You	
20-2	9058-9061	can	
20-3	9062-9069	observe	
20-4	9070-9074	from	
20-5	9075-9078	the	
20-6	9079-9085	figure	
20-7	9086-9090	that	
20-8	9091-9096	there	
20-9	9097-9099	is	
20-10	9100-9101	a	
20-11	9102-9106	Full	
20-12	9107-9109	GC	
20-13	9110-9115	event	
20-14	9115-9116	.	
20-15	9117-9121	This	
20-16	9122-9124	is	
20-17	9125-9135	indicative	
20-18	9136-9138	of	
20-19	9139-9142	the	
20-20	9143-9147	fact	
20-21	9148-9152	that	
20-22	9153-9164	application	
20-23	9165-9170	needs	
20-24	9171-9175	more	
20-25	9176-9182	memory	
20-26	9183-9187	than	
20-27	9188-9192	what	
20-28	9193-9196	you	
20-29	9197-9201	have	
20-30	9202-9211	allocated	
20-31	9211-9212	.	
20-32	9213-9216	For	
20-33	9217-9224	further	
20-34	9225-9233	analysis	
20-35	9233-9234	,	
20-36	9235-9239	open	
20-37	9240-9243	the	
20-38	9244-9251	Garbage	
20-39	9252-9263	Collections	
20-40	9264-9268	page	
20-41	9269-9274	under	
20-42	9275-9278	the	
20-43	9279-9282	JVM	
20-44	9283-9292	Internals	
20-45	9293-9297	page	
20-46	9298-9300	to	
20-47	9301-9312	investigate	
20-48	9313-9316	the	
20-49	9317-9324	overall	
20-50	9325-9336	performance	
20-51	9337-9343	impact	
20-52	9344-9346	of	
20-53	9347-9350	the	
20-54	9351-9353	GC	
20-55	9353-9354	.	
20-56	9355-9359	Here	
20-57	9360-9362	is	
20-58	9363-9364	a	
20-59	9365-9371	sample	
20-60	9372-9378	figure	
20-61	9379-9381	of	
20-62	9382-9383	a	
20-63	9384-9393	recording	
20-64	9393-9394	,	
20-65	9395-9400	which	
20-66	9401-9406	shows	
20-67	9407-9408	a	
20-68	9409-9414	graph	
20-69	9415-9419	with	
20-70	9420-9422	GC	
20-71	9423-9429	pauses	
20-72	9429-9430	.	

#Text=Figure 4-3 Garbage Collection Performance - GC PausesDescription of "Figure 4-3 Garbage Collection Performance - GC Pauses" From the graph look at the Sum of Pauses from the recording. The Sum of Pauses is the total amount of time that the application was paused during a GC. Many GCs do most of their work in the background. In those cases, the length of the GC does not matter and what matters is how long the application actually had to stop. Therefore, the Sum of Pauses is a good measure for the GC effect.
21-1	9431-9437	Figure	
21-2	9438-9439	4	
21-3	9439-9440	-	
21-4	9440-9441	3	
21-5	9442-9449	Garbage	
21-6	9450-9460	Collection	
21-7	9461-9472	Performance	
21-8	9473-9474	-	
21-9	9475-9477	GC	
21-10	9478-9495	PausesDescription	
21-11	9496-9498	of	
21-12	9499-9500	"	
21-13	9500-9506	Figure	
21-14	9507-9508	4	
21-15	9508-9509	-	
21-16	9509-9510	3	
21-17	9511-9518	Garbage	
21-18	9519-9529	Collection	
21-19	9530-9541	Performance	
21-20	9542-9543	-	
21-21	9544-9546	GC	
21-22	9547-9553	Pauses	
21-23	9553-9554	"	
21-24	9555-9559	From	
21-25	9560-9563	the	
21-26	9564-9569	graph	
21-27	9570-9574	look	
21-28	9575-9577	at	
21-29	9578-9581	the	
21-30	9582-9585	Sum	
21-31	9586-9588	of	
21-32	9589-9595	Pauses	
21-33	9596-9600	from	
21-34	9601-9604	the	
21-35	9605-9614	recording	
21-36	9614-9615	.	
21-37	9616-9619	The	
21-38	9620-9623	Sum	
21-39	9624-9626	of	
21-40	9627-9633	Pauses	
21-41	9634-9636	is	
21-42	9637-9640	the	
21-43	9641-9646	total	
21-44	9647-9653	amount	
21-45	9654-9656	of	
21-46	9657-9661	time	
21-47	9662-9666	that	
21-48	9667-9670	the	
21-49	9671-9682	application	
21-50	9683-9686	was	
21-51	9687-9693	paused	
21-52	9694-9700	during	
21-53	9701-9702	a	
21-54	9703-9705	GC	
21-55	9705-9706	.	
21-56	9707-9711	Many	
21-57	9712-9715	GCs	
21-58	9716-9718	do	
21-59	9719-9723	most	
21-60	9724-9726	of	
21-61	9727-9732	their	
21-62	9733-9737	work	
21-63	9738-9740	in	
21-64	9741-9744	the	
21-65	9745-9755	background	
21-66	9755-9756	.	
21-67	9757-9759	In	
21-68	9760-9765	those	
21-69	9766-9771	cases	
21-70	9771-9772	,	
21-71	9773-9776	the	
21-72	9777-9783	length	
21-73	9784-9786	of	
21-74	9787-9790	the	
21-75	9791-9793	GC	
21-76	9794-9798	does	
21-77	9799-9802	not	
21-78	9803-9809	matter	
21-79	9810-9813	and	
21-80	9814-9818	what	
21-81	9819-9826	matters	
21-82	9827-9829	is	
21-83	9830-9833	how	
21-84	9834-9838	long	
21-85	9839-9842	the	
21-86	9843-9854	application	
21-87	9855-9863	actually	
21-88	9864-9867	had	
21-89	9868-9870	to	
21-90	9871-9875	stop	
21-91	9875-9876	.	
21-92	9877-9886	Therefore	
21-93	9886-9887	,	
21-94	9888-9891	the	
21-95	9892-9895	Sum	
21-96	9896-9898	of	
21-97	9899-9905	Pauses	
21-98	9906-9908	is	
21-99	9909-9910	a	
21-100	9911-9915	good	
21-101	9916-9923	measure	
21-102	9924-9927	for	
21-103	9928-9931	the	
21-104	9932-9934	GC	
21-105	9935-9941	effect	
21-106	9941-9942	.	

#Text=The main performance problems with garbage collections are usually either that individual GCs take too long, or that too much time is spent in paused GCs (total GC pauses). When an individual GC takes too long, you may need to change the GC strategy. Different GCs have different trade-offs when it comes to pause times verses throughput performance. See Behavior-Based Tuning. For example, you may also need to fix your application so that it makes less use of finalizers or semireferences.
22-1	9943-9946	The	
22-2	9947-9951	main	
22-3	9952-9963	performance	
22-4	9964-9972	problems	
22-5	9973-9977	with	
22-6	9978-9985	garbage	
22-7	9986-9997	collections	
22-8	9998-10001	are	
22-9	10002-10009	usually	
22-10	10010-10016	either	
22-11	10017-10021	that	
22-12	10022-10032	individual	
22-13	10033-10036	GCs	
22-14	10037-10041	take	
22-15	10042-10045	too	
22-16	10046-10050	long	
22-17	10050-10051	,	
22-18	10052-10054	or	
22-19	10055-10059	that	
22-20	10060-10063	too	
22-21	10064-10068	much	
22-22	10069-10073	time	
22-23	10074-10076	is	
22-24	10077-10082	spent	
22-25	10083-10085	in	
22-26	10086-10092	paused	
22-27	10093-10096	GCs	
22-28	10097-10098	(	
22-29	10098-10103	total	
22-30	10104-10106	GC	
22-31	10107-10113	pauses	
22-32	10113-10114	)	
22-33	10114-10115	.	
22-34	10116-10120	When	
22-35	10121-10123	an	
22-36	10124-10134	individual	
22-37	10135-10137	GC	
22-38	10138-10143	takes	
22-39	10144-10147	too	
22-40	10148-10152	long	
22-41	10152-10153	,	
22-42	10154-10157	you	
22-43	10158-10161	may	
22-44	10162-10166	need	
22-45	10167-10169	to	
22-46	10170-10176	change	
22-47	10177-10180	the	
22-48	10181-10183	GC	
22-49	10184-10192	strategy	
22-50	10192-10193	.	
22-51	10194-10203	Different	
22-52	10204-10207	GCs	
22-53	10208-10212	have	
22-54	10213-10222	different	
22-55	10223-10233	trade-offs	
22-56	10234-10238	when	
22-57	10239-10241	it	
22-58	10242-10247	comes	
22-59	10248-10250	to	
22-60	10251-10256	pause	
22-61	10257-10262	times	
22-62	10263-10269	verses	
22-63	10270-10280	throughput	
22-64	10281-10292	performance	
22-65	10292-10293	.	
22-66	10294-10297	See	
22-67	10298-10312	Behavior-Based	
22-68	10313-10319	Tuning	
22-69	10319-10320	.	
22-70	10321-10324	For	
22-71	10325-10332	example	
22-72	10332-10333	,	
22-73	10334-10337	you	
22-74	10338-10341	may	
22-75	10342-10346	also	
22-76	10347-10351	need	
22-77	10352-10354	to	
22-78	10355-10358	fix	
22-79	10359-10363	your	
22-80	10364-10375	application	
22-81	10376-10378	so	
22-82	10379-10383	that	
22-83	10384-10386	it	
22-84	10387-10392	makes	
22-85	10393-10397	less	
22-86	10398-10401	use	
22-87	10402-10404	of	
22-88	10405-10415	finalizers	
22-89	10416-10418	or	
22-90	10419-10433	semireferences	
22-91	10433-10434	.	

#Text=If the application spends too much time paused, you can look into different ways to overcome this. One way is to increase the Java heap size. Look at the GC Configuration page to estimate the heap size used by the application, and change the initial heap size and maximum heap size to a higher value. The bigger the heap, the longer time it is between GCs. Watch out for any memory leaks in the Java application, because that may cause more frequent GCs until an OutOfMemoryError is thrown. For more information, see Use JDK Mission Control to Debug Memory Leak. Another way to reduce the GC cycles is to allocate fewer temporary objects. In the TLAB Allocations page, look at how much memory is allocated over the course of the recording. Small objects are allocated inside TLABs, and large objects are allocated outside TLABs. Often, the majority of allocations happen inside TLABs. Lastly, to reduce the need of GCs, decrease the allocation rate. Select the TLAB Allocations page and then look at the allocation sites that have the most memory pressure. You can either view it per class or thread to see which one consumes the most allocation. Some other settings may also increase GC performance of the Java application. See Garbage Collection Tuning Guide in the Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide to discuss GC performance. Use the jfr Tool to Debug Garbage Collection Issues
23-1	10435-10437	If	
23-2	10438-10441	the	
23-3	10442-10453	application	
23-4	10454-10460	spends	
23-5	10461-10464	too	
23-6	10465-10469	much	
23-7	10470-10474	time	
23-8	10475-10481	paused	
23-9	10481-10482	,	
23-10	10483-10486	you	
23-11	10487-10490	can	
23-12	10491-10495	look	
23-13	10496-10500	into	
23-14	10501-10510	different	
23-15	10511-10515	ways	
23-16	10516-10518	to	
23-17	10519-10527	overcome	
23-18	10528-10532	this	
23-19	10532-10533	.	
23-20	10534-10537	One	
23-21	10538-10541	way	
23-22	10542-10544	is	
23-23	10545-10547	to	
23-24	10548-10556	increase	
23-25	10557-10560	the	
23-26	10561-10565	Java	
23-27	10566-10570	heap	
23-28	10571-10575	size	
23-29	10575-10576	.	
23-30	10577-10581	Look	
23-31	10582-10584	at	
23-32	10585-10588	the	
23-33	10589-10591	GC	
23-34	10592-10605	Configuration	
23-35	10606-10610	page	
23-36	10611-10613	to	
23-37	10614-10622	estimate	
23-38	10623-10626	the	
23-39	10627-10631	heap	
23-40	10632-10636	size	
23-41	10637-10641	used	
23-42	10642-10644	by	
23-43	10645-10648	the	
23-44	10649-10660	application	
23-45	10660-10661	,	
23-46	10662-10665	and	
23-47	10666-10672	change	
23-48	10673-10676	the	
23-49	10677-10684	initial	
23-50	10685-10689	heap	
23-51	10690-10694	size	
23-52	10695-10698	and	
23-53	10699-10706	maximum	
23-54	10707-10711	heap	
23-55	10712-10716	size	
23-56	10717-10719	to	
23-57	10720-10721	a	
23-58	10722-10728	higher	
23-59	10729-10734	value	
23-60	10734-10735	.	
23-61	10736-10739	The	
23-62	10740-10746	bigger	
23-63	10747-10750	the	
23-64	10751-10755	heap	
23-65	10755-10756	,	
23-66	10757-10760	the	
23-67	10761-10767	longer	
23-68	10768-10772	time	
23-69	10773-10775	it	
23-70	10776-10778	is	
23-71	10779-10786	between	
23-72	10787-10790	GCs	
23-73	10790-10791	.	
23-74	10792-10797	Watch	
23-75	10798-10801	out	
23-76	10802-10805	for	
23-77	10806-10809	any	
23-78	10810-10816	memory	
23-79	10817-10822	leaks	
23-80	10823-10825	in	
23-81	10826-10829	the	
23-82	10830-10834	Java	
23-83	10835-10846	application	
23-84	10846-10847	,	
23-85	10848-10855	because	
23-86	10856-10860	that	
23-87	10861-10864	may	
23-88	10865-10870	cause	
23-89	10871-10875	more	
23-90	10876-10884	frequent	
23-91	10885-10888	GCs	
23-92	10889-10894	until	
23-93	10895-10897	an	
23-94	10898-10914	OutOfMemoryError	
23-95	10915-10917	is	
23-96	10918-10924	thrown	
23-97	10924-10925	.	
23-98	10926-10929	For	
23-99	10930-10934	more	
23-100	10935-10946	information	
23-101	10946-10947	,	
23-102	10948-10951	see	
23-103	10952-10955	Use	
23-104	10956-10959	JDK	
23-105	10960-10967	Mission	
23-106	10968-10975	Control	
23-107	10976-10978	to	
23-108	10979-10984	Debug	
23-109	10985-10991	Memory	
23-110	10992-10996	Leak	
23-111	10996-10997	.	
23-112	10998-11005	Another	
23-113	11006-11009	way	
23-114	11010-11012	to	
23-115	11013-11019	reduce	
23-116	11020-11023	the	
23-117	11024-11026	GC	
23-118	11027-11033	cycles	
23-119	11034-11036	is	
23-120	11037-11039	to	
23-121	11040-11048	allocate	
23-122	11049-11054	fewer	
23-123	11055-11064	temporary	
23-124	11065-11072	objects	
23-125	11072-11073	.	
23-126	11074-11076	In	
23-127	11077-11080	the	
23-128	11081-11085	TLAB	
23-129	11086-11097	Allocations	
23-130	11098-11102	page	
23-131	11102-11103	,	
23-132	11104-11108	look	
23-133	11109-11111	at	
23-134	11112-11115	how	
23-135	11116-11120	much	
23-136	11121-11127	memory	
23-137	11128-11130	is	
23-138	11131-11140	allocated	
23-139	11141-11145	over	
23-140	11146-11149	the	
23-141	11150-11156	course	
23-142	11157-11159	of	
23-143	11160-11163	the	
23-144	11164-11173	recording	
23-145	11173-11174	.	
23-146	11175-11180	Small	
23-147	11181-11188	objects	
23-148	11189-11192	are	
23-149	11193-11202	allocated	
23-150	11203-11209	inside	
23-151	11210-11215	TLABs	
23-152	11215-11216	,	
23-153	11217-11220	and	
23-154	11221-11226	large	
23-155	11227-11234	objects	
23-156	11235-11238	are	
23-157	11239-11248	allocated	
23-158	11249-11256	outside	
23-159	11257-11262	TLABs	
23-160	11262-11263	.	
23-161	11264-11269	Often	
23-162	11269-11270	,	
23-163	11271-11274	the	
23-164	11275-11283	majority	
23-165	11284-11286	of	
23-166	11287-11298	allocations	
23-167	11299-11305	happen	
23-168	11306-11312	inside	
23-169	11313-11318	TLABs	
23-170	11318-11319	.	
23-171	11320-11326	Lastly	
23-172	11326-11327	,	
23-173	11328-11330	to	
23-174	11331-11337	reduce	
23-175	11338-11341	the	
23-176	11342-11346	need	
23-177	11347-11349	of	
23-178	11350-11353	GCs	
23-179	11353-11354	,	
23-180	11355-11363	decrease	
23-181	11364-11367	the	
23-182	11368-11378	allocation	
23-183	11379-11383	rate	
23-184	11383-11384	.	
23-185	11385-11391	Select	
23-186	11392-11395	the	
23-187	11396-11400	TLAB	
23-188	11401-11412	Allocations	
23-189	11413-11417	page	
23-190	11418-11421	and	
23-191	11422-11426	then	
23-192	11427-11431	look	
23-193	11432-11434	at	
23-194	11435-11438	the	
23-195	11439-11449	allocation	
23-196	11450-11455	sites	
23-197	11456-11460	that	
23-198	11461-11465	have	
23-199	11466-11469	the	
23-200	11470-11474	most	
23-201	11475-11481	memory	
23-202	11482-11490	pressure	
23-203	11490-11491	.	
23-204	11492-11495	You	
23-205	11496-11499	can	
23-206	11500-11506	either	
23-207	11507-11511	view	
23-208	11512-11514	it	
23-209	11515-11518	per	
23-210	11519-11524	class	
23-211	11525-11527	or	
23-212	11528-11534	thread	
23-213	11535-11537	to	
23-214	11538-11541	see	
23-215	11542-11547	which	
23-216	11548-11551	one	
23-217	11552-11560	consumes	
23-218	11561-11564	the	
23-219	11565-11569	most	
23-220	11570-11580	allocation	
23-221	11580-11581	.	
23-222	11582-11586	Some	
23-223	11587-11592	other	
23-224	11593-11601	settings	
23-225	11602-11605	may	
23-226	11606-11610	also	
23-227	11611-11619	increase	
23-228	11620-11622	GC	
23-229	11623-11634	performance	
23-230	11635-11637	of	
23-231	11638-11641	the	
23-232	11642-11646	Java	
23-233	11647-11658	application	
23-234	11658-11659	.	
23-235	11660-11663	See	
23-236	11664-11671	Garbage	
23-237	11672-11682	Collection	
23-238	11683-11689	Tuning	
23-239	11690-11695	Guide	
23-240	11696-11698	in	
23-241	11699-11702	the	
23-242	11703-11707	Java	
23-243	11708-11716	Platform	
23-244	11716-11717	,	
23-245	11718-11726	Standard	
23-246	11727-11734	Edition	
23-247	11735-11742	HotSpot	
23-248	11743-11750	Virtual	
23-249	11751-11758	Machine	
23-250	11759-11766	Garbage	
23-251	11767-11777	Collection	
23-252	11778-11784	Tuning	
23-253	11785-11790	Guide	
23-254	11791-11793	to	
23-255	11794-11801	discuss	
23-256	11802-11804	GC	
23-257	11805-11816	performance	
23-258	11816-11817	.	
23-259	11818-11821	Use	
23-260	11822-11825	the	
23-261	11826-11829	jfr	
23-262	11830-11834	Tool	
23-263	11835-11837	to	
23-264	11838-11843	Debug	
23-265	11844-11851	Garbage	
23-266	11852-11862	Collection	
23-267	11863-11869	Issues	

#Text=Recordings from Flight Recorder can help diagnose Java application issues with garbage collections. Tuning the HotSpot Garbage Collector can have a big effect on performance. See Introduction to Garbage Collection Tuning in the Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide for information.
24-1	11870-11880	Recordings	
24-2	11881-11885	from	
24-3	11886-11892	Flight	
24-4	11893-11901	Recorder	
24-5	11902-11905	can	
24-6	11906-11910	help	
24-7	11911-11919	diagnose	
24-8	11920-11924	Java	
24-9	11925-11936	application	
24-10	11937-11943	issues	
24-11	11944-11948	with	
24-12	11949-11956	garbage	
24-13	11957-11968	collections	
24-14	11968-11969	.	
24-15	11970-11976	Tuning	
24-16	11977-11980	the	
24-17	11981-11988	HotSpot	
24-18	11989-11996	Garbage	
24-19	11997-12006	Collector	
24-20	12007-12010	can	
24-21	12011-12015	have	
24-22	12016-12017	a	
24-23	12018-12021	big	
24-24	12022-12028	effect	
24-25	12029-12031	on	
24-26	12032-12043	performance	
24-27	12043-12044	.	
24-28	12045-12048	See	
24-29	12049-12061	Introduction	
24-30	12062-12064	to	
24-31	12065-12072	Garbage	
24-32	12073-12083	Collection	
24-33	12084-12090	Tuning	
24-34	12091-12093	in	
24-35	12094-12097	the	
24-36	12098-12102	Java	
24-37	12103-12111	Platform	
24-38	12111-12112	,	
24-39	12113-12121	Standard	
24-40	12122-12129	Edition	
24-41	12130-12137	HotSpot	
24-42	12138-12145	Virtual	
24-43	12146-12153	Machine	
24-44	12154-12161	Garbage	
24-45	12162-12172	Collection	
24-46	12173-12179	Tuning	
24-47	12180-12185	Guide	
24-48	12186-12189	for	
24-49	12190-12201	information	
24-50	12201-12202	.	

#Text=To investigate garbage collection issues, take a profiling flight recording of your application while it is running. Do not include the heap statistics, because that triggers extra old collections. To get a good sample, take a longer recording, for example, 1 hour. Use the jfr tool to print the jdk.GCPhasePause events that were recorded. The following example shows the information contained in the event: c:\\Program Files\\Java\\jdk-15\\bin>jfr print --events jdk.GCPhasePause \\
25-1	12203-12205	To	
25-2	12206-12217	investigate	
25-3	12218-12225	garbage	
25-4	12226-12236	collection	
25-5	12237-12243	issues	
25-6	12243-12244	,	
25-7	12245-12249	take	
25-8	12250-12251	a	
25-9	12252-12261	profiling	
25-10	12262-12268	flight	
25-11	12269-12278	recording	
25-12	12279-12281	of	
25-13	12282-12286	your	
25-14	12287-12298	application	
25-15	12299-12304	while	
25-16	12305-12307	it	
25-17	12308-12310	is	
25-18	12311-12318	running	
25-19	12318-12319	.	
25-20	12320-12322	Do	
25-21	12323-12326	not	
25-22	12327-12334	include	
25-23	12335-12338	the	
25-24	12339-12343	heap	
25-25	12344-12354	statistics	
25-26	12354-12355	,	
25-27	12356-12363	because	
25-28	12364-12368	that	
25-29	12369-12377	triggers	
25-30	12378-12383	extra	
25-31	12384-12387	old	
25-32	12388-12399	collections	
25-33	12399-12400	.	
25-34	12401-12403	To	
25-35	12404-12407	get	
25-36	12408-12409	a	
25-37	12410-12414	good	
25-38	12415-12421	sample	
25-39	12421-12422	,	
25-40	12423-12427	take	
25-41	12428-12429	a	
25-42	12430-12436	longer	
25-43	12437-12446	recording	
25-44	12446-12447	,	
25-45	12448-12451	for	
25-46	12452-12459	example	
25-47	12459-12460	,	
25-48	12461-12462	1	
25-49	12463-12467	hour	
25-50	12467-12468	.	
25-51	12469-12472	Use	
25-52	12473-12476	the	
25-53	12477-12480	jfr	
25-54	12481-12485	tool	
25-55	12486-12488	to	
25-56	12489-12494	print	
25-57	12495-12498	the	
25-58	12499-12515	jdk.GCPhasePause	
25-59	12516-12522	events	
25-60	12523-12527	that	
25-61	12528-12532	were	
25-62	12533-12541	recorded	
25-63	12541-12542	.	
25-64	12543-12546	The	
25-65	12547-12556	following	
25-66	12557-12564	example	
25-67	12565-12570	shows	
25-68	12571-12574	the	
25-69	12575-12586	information	
25-70	12587-12596	contained	
25-71	12597-12599	in	
25-72	12600-12603	the	
25-73	12604-12609	event	
25-74	12609-12610	:	
25-75	12611-12612	c	
25-76	12612-12613	:	
25-77	12613-12614	\	
25-78	12614-12621	Program	
25-79	12622-12627	Files	
25-80	12627-12628	\	
25-81	12628-12632	Java	
25-82	12632-12633	\	
25-83	12633-12636	jdk	
25-84	12636-12637	-	
25-85	12637-12639	15	
25-86	12639-12640	\	
25-87	12640-12643	bin	
25-88	12643-12644	>	
25-89	12644-12647	jfr	
25-90	12648-12653	print	
25-91	12654-12655	-	
25-92	12655-12656	-	
25-93	12656-12662	events	
25-94	12663-12679	jdk.GCPhasePause	
25-95	12680-12681	\	

#Text=gctest.jfr jdk.GCPhasePause { startTime = 11:19:13.779 duration = 3.419 ms gcId = 1 name = "GC Pause"
26-1	12682-12692	gctest.jfr	
26-2	12693-12709	jdk.GCPhasePause	
26-3	12710-12711	{	
26-4	12712-12721	startTime	
26-5	12722-12723	=	
26-6	12724-12726	11	
26-7	12726-12727	:	
26-8	12727-12729	19	
26-9	12729-12730	:	
26-10	12730-12736	13.779	
26-11	12737-12745	duration	
26-12	12746-12747	=	
26-13	12748-12753	3.419	
26-14	12754-12756	ms	
26-15	12757-12761	gcId	
26-16	12762-12763	=	
26-17	12764-12765	1	
26-18	12766-12770	name	
26-19	12771-12772	=	
26-20	12773-12774	"	
26-21	12774-12776	GC	
26-22	12777-12782	Pause	
26-23	12782-12783	"	

#Text=eventThread = "VM Thread" (osThreadId = 17528) }Using the information from the jdk.GCPhasePause events, you can calculate the average sum of pauses for each GC, the maximum sum of pauses, and the total pause time. The sum of pauses is the total amount of time that the application was paused during a GC. Many GCs do most of their work in the background. In those cases, the length of the GC does not matter and what matters is how long the application actually had to stop. Therefore, the sum of pauses is a good measure for the GC effect.
27-1	12784-12795	eventThread	
27-2	12796-12797	=	
27-3	12798-12799	"	
27-4	12799-12801	VM	
27-5	12802-12808	Thread	
27-6	12808-12809	"	
27-7	12810-12811	(	
27-8	12811-12821	osThreadId	
27-9	12822-12823	=	
27-10	12824-12829	17528	
27-11	12829-12830	)	
27-12	12831-12832	}	
27-13	12832-12837	Using	
27-14	12838-12841	the	
27-15	12842-12853	information	
27-16	12854-12858	from	
27-17	12859-12862	the	
27-18	12863-12879	jdk.GCPhasePause	
27-19	12880-12886	events	
27-20	12886-12887	,	
27-21	12888-12891	you	
27-22	12892-12895	can	
27-23	12896-12905	calculate	
27-24	12906-12909	the	
27-25	12910-12917	average	
27-26	12918-12921	sum	
27-27	12922-12924	of	
27-28	12925-12931	pauses	
27-29	12932-12935	for	
27-30	12936-12940	each	
27-31	12941-12943	GC	
27-32	12943-12944	,	
27-33	12945-12948	the	
27-34	12949-12956	maximum	
27-35	12957-12960	sum	
27-36	12961-12963	of	
27-37	12964-12970	pauses	
27-38	12970-12971	,	
27-39	12972-12975	and	
27-40	12976-12979	the	
27-41	12980-12985	total	
27-42	12986-12991	pause	
27-43	12992-12996	time	
27-44	12996-12997	.	
27-45	12998-13001	The	
27-46	13002-13005	sum	
27-47	13006-13008	of	
27-48	13009-13015	pauses	
27-49	13016-13018	is	
27-50	13019-13022	the	
27-51	13023-13028	total	
27-52	13029-13035	amount	
27-53	13036-13038	of	
27-54	13039-13043	time	
27-55	13044-13048	that	
27-56	13049-13052	the	
27-57	13053-13064	application	
27-58	13065-13068	was	
27-59	13069-13075	paused	
27-60	13076-13082	during	
27-61	13083-13084	a	
27-62	13085-13087	GC	
27-63	13087-13088	.	
27-64	13089-13093	Many	
27-65	13094-13097	GCs	
27-66	13098-13100	do	
27-67	13101-13105	most	
27-68	13106-13108	of	
27-69	13109-13114	their	
27-70	13115-13119	work	
27-71	13120-13122	in	
27-72	13123-13126	the	
27-73	13127-13137	background	
27-74	13137-13138	.	
27-75	13139-13141	In	
27-76	13142-13147	those	
27-77	13148-13153	cases	
27-78	13153-13154	,	
27-79	13155-13158	the	
27-80	13159-13165	length	
27-81	13166-13168	of	
27-82	13169-13172	the	
27-83	13173-13175	GC	
27-84	13176-13180	does	
27-85	13181-13184	not	
27-86	13185-13191	matter	
27-87	13192-13195	and	
27-88	13196-13200	what	
27-89	13201-13208	matters	
27-90	13209-13211	is	
27-91	13212-13215	how	
27-92	13216-13220	long	
27-93	13221-13224	the	
27-94	13225-13236	application	
27-95	13237-13245	actually	
27-96	13246-13249	had	
27-97	13250-13252	to	
27-98	13253-13257	stop	
27-99	13257-13258	.	
27-100	13259-13268	Therefore	
27-101	13268-13269	,	
27-102	13270-13273	the	
27-103	13274-13277	sum	
27-104	13278-13280	of	
27-105	13281-13287	pauses	
27-106	13288-13290	is	
27-107	13291-13292	a	
27-108	13293-13297	good	
27-109	13298-13305	measure	
27-110	13306-13309	for	
27-111	13310-13313	the	
27-112	13314-13316	GC	
27-113	13317-13323	effect	
27-114	13323-13324	.	

#Text=The main performance problems with garbage collections are usually either that individual GCs take too long, or that too much time is spent in paused GCs (total GC pauses). When an individual GC takes too long, you may need to change the GC strategy. Different GCs have different trade-offs when it comes to pause times verses throughput performance. For example, you may also need to fix your application so that it makes less use of finalizers or semireferences. See Behavior-Based Tuning in the Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide.
28-1	13325-13328	The	
28-2	13329-13333	main	
28-3	13334-13345	performance	
28-4	13346-13354	problems	
28-5	13355-13359	with	
28-6	13360-13367	garbage	
28-7	13368-13379	collections	
28-8	13380-13383	are	
28-9	13384-13391	usually	
28-10	13392-13398	either	
28-11	13399-13403	that	
28-12	13404-13414	individual	
28-13	13415-13418	GCs	
28-14	13419-13423	take	
28-15	13424-13427	too	
28-16	13428-13432	long	
28-17	13432-13433	,	
28-18	13434-13436	or	
28-19	13437-13441	that	
28-20	13442-13445	too	
28-21	13446-13450	much	
28-22	13451-13455	time	
28-23	13456-13458	is	
28-24	13459-13464	spent	
28-25	13465-13467	in	
28-26	13468-13474	paused	
28-27	13475-13478	GCs	
28-28	13479-13480	(	
28-29	13480-13485	total	
28-30	13486-13488	GC	
28-31	13489-13495	pauses	
28-32	13495-13496	)	
28-33	13496-13497	.	
28-34	13498-13502	When	
28-35	13503-13505	an	
28-36	13506-13516	individual	
28-37	13517-13519	GC	
28-38	13520-13525	takes	
28-39	13526-13529	too	
28-40	13530-13534	long	
28-41	13534-13535	,	
28-42	13536-13539	you	
28-43	13540-13543	may	
28-44	13544-13548	need	
28-45	13549-13551	to	
28-46	13552-13558	change	
28-47	13559-13562	the	
28-48	13563-13565	GC	
28-49	13566-13574	strategy	
28-50	13574-13575	.	
28-51	13576-13585	Different	
28-52	13586-13589	GCs	
28-53	13590-13594	have	
28-54	13595-13604	different	
28-55	13605-13615	trade-offs	
28-56	13616-13620	when	
28-57	13621-13623	it	
28-58	13624-13629	comes	
28-59	13630-13632	to	
28-60	13633-13638	pause	
28-61	13639-13644	times	
28-62	13645-13651	verses	
28-63	13652-13662	throughput	
28-64	13663-13674	performance	
28-65	13674-13675	.	
28-66	13676-13679	For	
28-67	13680-13687	example	
28-68	13687-13688	,	
28-69	13689-13692	you	
28-70	13693-13696	may	
28-71	13697-13701	also	
28-72	13702-13706	need	
28-73	13707-13709	to	
28-74	13710-13713	fix	
28-75	13714-13718	your	
28-76	13719-13730	application	
28-77	13731-13733	so	
28-78	13734-13738	that	
28-79	13739-13741	it	
28-80	13742-13747	makes	
28-81	13748-13752	less	
28-82	13753-13756	use	
28-83	13757-13759	of	
28-84	13760-13770	finalizers	
28-85	13771-13773	or	
28-86	13774-13788	semireferences	
28-87	13788-13789	.	
28-88	13790-13793	See	
28-89	13794-13808	Behavior-Based	
28-90	13809-13815	Tuning	
28-91	13816-13818	in	
28-92	13819-13822	the	
28-93	13823-13827	Java	
28-94	13828-13836	Platform	
28-95	13836-13837	,	
28-96	13838-13846	Standard	
28-97	13847-13854	Edition	
28-98	13855-13862	HotSpot	
28-99	13863-13870	Virtual	
28-100	13871-13878	Machine	
28-101	13879-13886	Garbage	
28-102	13887-13897	Collection	
28-103	13898-13904	Tuning	
28-104	13905-13910	Guide	
28-105	13910-13911	.	

#Text=When the application spends too much time paused, there are different ways to work around that: Increase the Java heap size. The bigger the Java heap, the longer time it is between GCs. Watch out for any memory leaks in the Java application, because that may cause more and more frequent GCs until an OutOfMemoryError is thrown. For more information, see Use JDK Mission Control to Debug Memory Leak.
29-1	13912-13916	When	
29-2	13917-13920	the	
29-3	13921-13932	application	
29-4	13933-13939	spends	
29-5	13940-13943	too	
29-6	13944-13948	much	
29-7	13949-13953	time	
29-8	13954-13960	paused	
29-9	13960-13961	,	
29-10	13962-13967	there	
29-11	13968-13971	are	
29-12	13972-13981	different	
29-13	13982-13986	ways	
29-14	13987-13989	to	
29-15	13990-13994	work	
29-16	13995-14001	around	
29-17	14002-14006	that	
29-18	14006-14007	:	
29-19	14008-14016	Increase	
29-20	14017-14020	the	
29-21	14021-14025	Java	
29-22	14026-14030	heap	
29-23	14031-14035	size	
29-24	14035-14036	.	
29-25	14037-14040	The	
29-26	14041-14047	bigger	
29-27	14048-14051	the	
29-28	14052-14056	Java	
29-29	14057-14061	heap	
29-30	14061-14062	,	
29-31	14063-14066	the	
29-32	14067-14073	longer	
29-33	14074-14078	time	
29-34	14079-14081	it	
29-35	14082-14084	is	
29-36	14085-14092	between	
29-37	14093-14096	GCs	
29-38	14096-14097	.	
29-39	14098-14103	Watch	
29-40	14104-14107	out	
29-41	14108-14111	for	
29-42	14112-14115	any	
29-43	14116-14122	memory	
29-44	14123-14128	leaks	
29-45	14129-14131	in	
29-46	14132-14135	the	
29-47	14136-14140	Java	
29-48	14141-14152	application	
29-49	14152-14153	,	
29-50	14154-14161	because	
29-51	14162-14166	that	
29-52	14167-14170	may	
29-53	14171-14176	cause	
29-54	14177-14181	more	
29-55	14182-14185	and	
29-56	14186-14190	more	
29-57	14191-14199	frequent	
29-58	14200-14203	GCs	
29-59	14204-14209	until	
29-60	14210-14212	an	
29-61	14213-14229	OutOfMemoryError	
29-62	14230-14232	is	
29-63	14233-14239	thrown	
29-64	14239-14240	.	
29-65	14241-14244	For	
29-66	14245-14249	more	
29-67	14250-14261	information	
29-68	14261-14262	,	
29-69	14263-14266	see	
29-70	14267-14270	Use	
29-71	14271-14274	JDK	
29-72	14275-14282	Mission	
29-73	14283-14290	Control	
29-74	14291-14293	to	
29-75	14294-14299	Debug	
29-76	14300-14306	Memory	
29-77	14307-14311	Leak	
29-78	14311-14312	.	

#Text=To reduce the number of GCs, allocate fewer temporary objects. Small objects are allocated inside TLABs, and large objects are allocated outside TLABs. Often, the majority of allocations happen inside TLABs. The jdk.ObjectAllocationInNewTLAB and jdk.ObjectAllocationOutsideTLAB events provide information about the allocation of temporary objects. To reduce the need of GCs, decrease the allocation rate. The jdk.ThreadAllocationStatistics event provides information about the allocations per thread.
30-1	14313-14315	To	
30-2	14316-14322	reduce	
30-3	14323-14326	the	
30-4	14327-14333	number	
30-5	14334-14336	of	
30-6	14337-14340	GCs	
30-7	14340-14341	,	
30-8	14342-14350	allocate	
30-9	14351-14356	fewer	
30-10	14357-14366	temporary	
30-11	14367-14374	objects	
30-12	14374-14375	.	
30-13	14376-14381	Small	
30-14	14382-14389	objects	
30-15	14390-14393	are	
30-16	14394-14403	allocated	
30-17	14404-14410	inside	
30-18	14411-14416	TLABs	
30-19	14416-14417	,	
30-20	14418-14421	and	
30-21	14422-14427	large	
30-22	14428-14435	objects	
30-23	14436-14439	are	
30-24	14440-14449	allocated	
30-25	14450-14457	outside	
30-26	14458-14463	TLABs	
30-27	14463-14464	.	
30-28	14465-14470	Often	
30-29	14470-14471	,	
30-30	14472-14475	the	
30-31	14476-14484	majority	
30-32	14485-14487	of	
30-33	14488-14499	allocations	
30-34	14500-14506	happen	
30-35	14507-14513	inside	
30-36	14514-14519	TLABs	
30-37	14519-14520	.	
30-38	14521-14524	The	
30-39	14525-14554	jdk.ObjectAllocationInNewTLAB	
30-40	14555-14558	and	
30-41	14559-14590	jdk.ObjectAllocationOutsideTLAB	
30-42	14591-14597	events	
30-43	14598-14605	provide	
30-44	14606-14617	information	
30-45	14618-14623	about	
30-46	14624-14627	the	
30-47	14628-14638	allocation	
30-48	14639-14641	of	
30-49	14642-14651	temporary	
30-50	14652-14659	objects	
30-51	14659-14660	.	
30-52	14661-14663	To	
30-53	14664-14670	reduce	
30-54	14671-14674	the	
30-55	14675-14679	need	
30-56	14680-14682	of	
30-57	14683-14686	GCs	
30-58	14686-14687	,	
30-59	14688-14696	decrease	
30-60	14697-14700	the	
30-61	14701-14711	allocation	
30-62	14712-14716	rate	
30-63	14716-14717	.	
30-64	14718-14721	The	
30-65	14722-14752	jdk.ThreadAllocationStatistics	
30-66	14753-14758	event	
30-67	14759-14767	provides	
30-68	14768-14779	information	
30-69	14780-14785	about	
30-70	14786-14789	the	
30-71	14790-14801	allocations	
30-72	14802-14805	per	
30-73	14806-14812	thread	
30-74	14812-14813	.	

#Text=Some other settings may also increase GC performance of the Java application. See Garbage-First Garbage Collection in the Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide for more information about GC performance. Synchronization Performance Java applications encounter synchronization issues when the application threads spend a lot of time waiting to enter a monitor. Topics: Use JDK Mission Control to Debug Synchronization Issues
31-1	14814-14818	Some	
31-2	14819-14824	other	
31-3	14825-14833	settings	
31-4	14834-14837	may	
31-5	14838-14842	also	
31-6	14843-14851	increase	
31-7	14852-14854	GC	
31-8	14855-14866	performance	
31-9	14867-14869	of	
31-10	14870-14873	the	
31-11	14874-14878	Java	
31-12	14879-14890	application	
31-13	14890-14891	.	
31-14	14892-14895	See	
31-15	14896-14909	Garbage-First	
31-16	14910-14917	Garbage	
31-17	14918-14928	Collection	
31-18	14929-14931	in	
31-19	14932-14935	the	
31-20	14936-14940	Java	
31-21	14941-14949	Platform	
31-22	14949-14950	,	
31-23	14951-14959	Standard	
31-24	14960-14967	Edition	
31-25	14968-14975	HotSpot	
31-26	14976-14983	Virtual	
31-27	14984-14991	Machine	
31-28	14992-14999	Garbage	
31-29	15000-15010	Collection	
31-30	15011-15017	Tuning	
31-31	15018-15023	Guide	
31-32	15024-15027	for	
31-33	15028-15032	more	
31-34	15033-15044	information	
31-35	15045-15050	about	
31-36	15051-15053	GC	
31-37	15054-15065	performance	
31-38	15065-15066	.	
31-39	15067-15082	Synchronization	
31-40	15083-15094	Performance	
31-41	15095-15099	Java	
31-42	15100-15112	applications	
31-43	15113-15122	encounter	
31-44	15123-15138	synchronization	
31-45	15139-15145	issues	
31-46	15146-15150	when	
31-47	15151-15154	the	
31-48	15155-15166	application	
31-49	15167-15174	threads	
31-50	15175-15180	spend	
31-51	15181-15182	a	
31-52	15183-15186	lot	
31-53	15187-15189	of	
31-54	15190-15194	time	
31-55	15195-15202	waiting	
31-56	15203-15205	to	
31-57	15206-15211	enter	
31-58	15212-15213	a	
31-59	15214-15221	monitor	
31-60	15221-15222	.	
31-61	15223-15229	Topics	
31-62	15229-15230	:	
31-63	15231-15234	Use	
31-64	15235-15238	JDK	
31-65	15239-15246	Mission	
31-66	15247-15254	Control	
31-67	15255-15257	to	
31-68	15258-15263	Debug	
31-69	15264-15279	Synchronization	
31-70	15280-15286	Issues	

#Text=Use jdk.JavaMonitorWait Events to Debug Synchronization Issues Use JDK Mission Control to Debug Synchronization Issues You can use JMC to debug Java Application synchronization issues. Open the flight recording in JMC and look at the Automated Analysis Results page. Here is a sample figure of a recording, which shows threads that are blocked on locks.
32-1	15287-15290	Use	
32-2	15291-15310	jdk.JavaMonitorWait	
32-3	15311-15317	Events	
32-4	15318-15320	to	
32-5	15321-15326	Debug	
32-6	15327-15342	Synchronization	
32-7	15343-15349	Issues	
32-8	15350-15353	Use	
32-9	15354-15357	JDK	
32-10	15358-15365	Mission	
32-11	15366-15373	Control	
32-12	15374-15376	to	
32-13	15377-15382	Debug	
32-14	15383-15398	Synchronization	
32-15	15399-15405	Issues	
32-16	15406-15409	You	
32-17	15410-15413	can	
32-18	15414-15417	use	
32-19	15418-15421	JMC	
32-20	15422-15424	to	
32-21	15425-15430	debug	
32-22	15431-15435	Java	
32-23	15436-15447	Application	
32-24	15448-15463	synchronization	
32-25	15464-15470	issues	
32-26	15470-15471	.	
32-27	15472-15476	Open	
32-28	15477-15480	the	
32-29	15481-15487	flight	
32-30	15488-15497	recording	
32-31	15498-15500	in	
32-32	15501-15504	JMC	
32-33	15505-15508	and	
32-34	15509-15513	look	
32-35	15514-15516	at	
32-36	15517-15520	the	
32-37	15521-15530	Automated	
32-38	15531-15539	Analysis	
32-39	15540-15547	Results	
32-40	15548-15552	page	
32-41	15552-15553	.	
32-42	15554-15558	Here	
32-43	15559-15561	is	
32-44	15562-15563	a	
32-45	15564-15570	sample	
32-46	15571-15577	figure	
32-47	15578-15580	of	
32-48	15581-15582	a	
32-49	15583-15592	recording	
32-50	15592-15593	,	
32-51	15594-15599	which	
32-52	15600-15605	shows	
32-53	15606-15613	threads	
32-54	15614-15618	that	
32-55	15619-15622	are	
32-56	15623-15630	blocked	
32-57	15631-15633	on	
32-58	15634-15639	locks	
32-59	15639-15640	.	

#Text=Figure 4-4 Synchronization Issue - Automated Analysis Results PageDescription of "Figure 4-4 Synchronization Issue - Automated Analysis Results Page" Focus on the Lock Instances section of the page, which is highlighted in red. This is indicative of a potential problem. You can observe that there are threads that are blocked on locks. For further analysis, open the Lock Instances
33-1	15641-15647	Figure	
33-2	15648-15649	4	
33-3	15649-15650	-	
33-4	15650-15651	4	
33-5	15652-15667	Synchronization	
33-6	15668-15673	Issue	
33-7	15674-15675	-	
33-8	15676-15685	Automated	
33-9	15686-15694	Analysis	
33-10	15695-15702	Results	
33-11	15703-15718	PageDescription	
33-12	15719-15721	of	
33-13	15722-15723	"	
33-14	15723-15729	Figure	
33-15	15730-15731	4	
33-16	15731-15732	-	
33-17	15732-15733	4	
33-18	15734-15749	Synchronization	
33-19	15750-15755	Issue	
33-20	15756-15757	-	
33-21	15758-15767	Automated	
33-22	15768-15776	Analysis	
33-23	15777-15784	Results	
33-24	15785-15789	Page	
33-25	15789-15790	"	
33-26	15791-15796	Focus	
33-27	15797-15799	on	
33-28	15800-15803	the	
33-29	15804-15808	Lock	
33-30	15809-15818	Instances	
33-31	15819-15826	section	
33-32	15827-15829	of	
33-33	15830-15833	the	
33-34	15834-15838	page	
33-35	15838-15839	,	
33-36	15840-15845	which	
33-37	15846-15848	is	
33-38	15849-15860	highlighted	
33-39	15861-15863	in	
33-40	15864-15867	red	
33-41	15867-15868	.	
33-42	15869-15873	This	
33-43	15874-15876	is	
33-44	15877-15887	indicative	
33-45	15888-15890	of	
33-46	15891-15892	a	
33-47	15893-15902	potential	
33-48	15903-15910	problem	
33-49	15910-15911	.	
33-50	15912-15915	You	
33-51	15916-15919	can	
33-52	15920-15927	observe	
33-53	15928-15932	that	
33-54	15933-15938	there	
33-55	15939-15942	are	
33-56	15943-15950	threads	
33-57	15951-15955	that	
33-58	15956-15959	are	
33-59	15960-15967	blocked	
33-60	15968-15970	on	
33-61	15971-15976	locks	
33-62	15976-15977	.	
33-63	15978-15981	For	
33-64	15982-15989	further	
33-65	15990-15998	analysis	
33-66	15998-15999	,	
33-67	16000-16004	open	
33-68	16005-16008	the	
33-69	16009-16013	Lock	
33-70	16014-16023	Instances	

#Text=page. Here is a sample figure of a recording, which shows the thread that is blocked on locks the most and the stack trace of the thread waiting to acquire the lock. Figure 4-5 Synchronization Issue - Lock InstanceDescription of "Figure 4-5 Synchronization Issue - Lock Instance" You can notice that threads in the application were blocked on locks for a total time of 3 hours. The most common monitor class in contention was Logger, which was blocked 2972 times.
34-1	16024-16028	page	
34-2	16028-16029	.	
34-3	16030-16034	Here	
34-4	16035-16037	is	
34-5	16038-16039	a	
34-6	16040-16046	sample	
34-7	16047-16053	figure	
34-8	16054-16056	of	
34-9	16057-16058	a	
34-10	16059-16068	recording	
34-11	16068-16069	,	
34-12	16070-16075	which	
34-13	16076-16081	shows	
34-14	16082-16085	the	
34-15	16086-16092	thread	
34-16	16093-16097	that	
34-17	16098-16100	is	
34-18	16101-16108	blocked	
34-19	16109-16111	on	
34-20	16112-16117	locks	
34-21	16118-16121	the	
34-22	16122-16126	most	
34-23	16127-16130	and	
34-24	16131-16134	the	
34-25	16135-16140	stack	
34-26	16141-16146	trace	
34-27	16147-16149	of	
34-28	16150-16153	the	
34-29	16154-16160	thread	
34-30	16161-16168	waiting	
34-31	16169-16171	to	
34-32	16172-16179	acquire	
34-33	16180-16183	the	
34-34	16184-16188	lock	
34-35	16188-16189	.	
34-36	16190-16196	Figure	
34-37	16197-16198	4	
34-38	16198-16199	-	
34-39	16199-16200	5	
34-40	16201-16216	Synchronization	
34-41	16217-16222	Issue	
34-42	16223-16224	-	
34-43	16225-16229	Lock	
34-44	16230-16249	InstanceDescription	
34-45	16250-16252	of	
34-46	16253-16254	"	
34-47	16254-16260	Figure	
34-48	16261-16262	4	
34-49	16262-16263	-	
34-50	16263-16264	5	
34-51	16265-16280	Synchronization	
34-52	16281-16286	Issue	
34-53	16287-16288	-	
34-54	16289-16293	Lock	
34-55	16294-16302	Instance	
34-56	16302-16303	"	
34-57	16304-16307	You	
34-58	16308-16311	can	
34-59	16312-16318	notice	
34-60	16319-16323	that	
34-61	16324-16331	threads	
34-62	16332-16334	in	
34-63	16335-16338	the	
34-64	16339-16350	application	
34-65	16351-16355	were	
34-66	16356-16363	blocked	
34-67	16364-16366	on	
34-68	16367-16372	locks	
34-69	16373-16376	for	
34-70	16377-16378	a	
34-71	16379-16384	total	
34-72	16385-16389	time	
34-73	16390-16392	of	
34-74	16393-16394	3	
34-75	16395-16400	hours	
34-76	16400-16401	.	
34-77	16402-16405	The	
34-78	16406-16410	most	
34-79	16411-16417	common	
34-80	16418-16425	monitor	
34-81	16426-16431	class	
34-82	16432-16434	in	
34-83	16435-16445	contention	
34-84	16446-16449	was	
34-85	16450-16456	Logger	
34-86	16456-16457	,	
34-87	16458-16463	which	
34-88	16464-16467	was	
34-89	16468-16475	blocked	
34-90	16476-16480	2972	
34-91	16481-16486	times	
34-92	16486-16487	.	

#Text=Typically, logging is an area that can be a bottleneck in applications. In this scenario, the blocking events all seem to be due to calls to the log method. You can review and make required code changes to fix this issue. Use jdk.JavaMonitorWait Events to Debug Synchronization Issues To debug Java Application synchronization issues, which is where the application threads spend a lot of time waiting to enter a monitor, look at the jdk.JavaMonitorWait events in a recording from Flight Recorder.
35-1	16488-16497	Typically	
35-2	16497-16498	,	
35-3	16499-16506	logging	
35-4	16507-16509	is	
35-5	16510-16512	an	
35-6	16513-16517	area	
35-7	16518-16522	that	
35-8	16523-16526	can	
35-9	16527-16529	be	
35-10	16530-16531	a	
35-11	16532-16542	bottleneck	
35-12	16543-16545	in	
35-13	16546-16558	applications	
35-14	16558-16559	.	
35-15	16560-16562	In	
35-16	16563-16567	this	
35-17	16568-16576	scenario	
35-18	16576-16577	,	
35-19	16578-16581	the	
35-20	16582-16590	blocking	
35-21	16591-16597	events	
35-22	16598-16601	all	
35-23	16602-16606	seem	
35-24	16607-16609	to	
35-25	16610-16612	be	
35-26	16613-16616	due	
35-27	16617-16619	to	
35-28	16620-16625	calls	
35-29	16626-16628	to	
35-30	16629-16632	the	
35-31	16633-16636	log	
35-32	16637-16643	method	
35-33	16643-16644	.	
35-34	16645-16648	You	
35-35	16649-16652	can	
35-36	16653-16659	review	
35-37	16660-16663	and	
35-38	16664-16668	make	
35-39	16669-16677	required	
35-40	16678-16682	code	
35-41	16683-16690	changes	
35-42	16691-16693	to	
35-43	16694-16697	fix	
35-44	16698-16702	this	
35-45	16703-16708	issue	
35-46	16708-16709	.	
35-47	16710-16713	Use	
35-48	16714-16733	jdk.JavaMonitorWait	
35-49	16734-16740	Events	
35-50	16741-16743	to	
35-51	16744-16749	Debug	
35-52	16750-16765	Synchronization	
35-53	16766-16772	Issues	
35-54	16773-16775	To	
35-55	16776-16781	debug	
35-56	16782-16786	Java	
35-57	16787-16798	Application	
35-58	16799-16814	synchronization	
35-59	16815-16821	issues	
35-60	16821-16822	,	
35-61	16823-16828	which	
35-62	16829-16831	is	
35-63	16832-16837	where	
35-64	16838-16841	the	
35-65	16842-16853	application	
35-66	16854-16861	threads	
35-67	16862-16867	spend	
35-68	16868-16869	a	
35-69	16870-16873	lot	
35-70	16874-16876	of	
35-71	16877-16881	time	
35-72	16882-16889	waiting	
35-73	16890-16892	to	
35-74	16893-16898	enter	
35-75	16899-16900	a	
35-76	16901-16908	monitor	
35-77	16908-16909	,	
35-78	16910-16914	look	
35-79	16915-16917	at	
35-80	16918-16921	the	
35-81	16922-16941	jdk.JavaMonitorWait	
35-82	16942-16948	events	
35-83	16949-16951	in	
35-84	16952-16953	a	
35-85	16954-16963	recording	
35-86	16964-16968	from	
35-87	16969-16975	Flight	
35-88	16976-16984	Recorder	
35-89	16984-16985	.	

#Text=Look at the locks that are contended the most and the stack trace of the threads waiting to acquire the lock. Typically, look for contention that you did not think would be an issue. Logging is a common area that can be an unexpected bottleneck in some applications. When you see performance degradation after a program update or at any specific times in the Java application, take a flight recording when things are good, and take another one when things are bad to look for a synchronization site that increases a lot.
36-1	16986-16990	Look	
36-2	16991-16993	at	
36-3	16994-16997	the	
36-4	16998-17003	locks	
36-5	17004-17008	that	
36-6	17009-17012	are	
36-7	17013-17022	contended	
36-8	17023-17026	the	
36-9	17027-17031	most	
36-10	17032-17035	and	
36-11	17036-17039	the	
36-12	17040-17045	stack	
36-13	17046-17051	trace	
36-14	17052-17054	of	
36-15	17055-17058	the	
36-16	17059-17066	threads	
36-17	17067-17074	waiting	
36-18	17075-17077	to	
36-19	17078-17085	acquire	
36-20	17086-17089	the	
36-21	17090-17094	lock	
36-22	17094-17095	.	
36-23	17096-17105	Typically	
36-24	17105-17106	,	
36-25	17107-17111	look	
36-26	17112-17115	for	
36-27	17116-17126	contention	
36-28	17127-17131	that	
36-29	17132-17135	you	
36-30	17136-17139	did	
36-31	17140-17143	not	
36-32	17144-17149	think	
36-33	17150-17155	would	
36-34	17156-17158	be	
36-35	17159-17161	an	
36-36	17162-17167	issue	
36-37	17167-17168	.	
36-38	17169-17176	Logging	
36-39	17177-17179	is	
36-40	17180-17181	a	
36-41	17182-17188	common	
36-42	17189-17193	area	
36-43	17194-17198	that	
36-44	17199-17202	can	
36-45	17203-17205	be	
36-46	17206-17208	an	
36-47	17209-17219	unexpected	
36-48	17220-17230	bottleneck	
36-49	17231-17233	in	
36-50	17234-17238	some	
36-51	17239-17251	applications	
36-52	17251-17252	.	
36-53	17253-17257	When	
36-54	17258-17261	you	
36-55	17262-17265	see	
36-56	17266-17277	performance	
36-57	17278-17289	degradation	
36-58	17290-17295	after	
36-59	17296-17297	a	
36-60	17298-17305	program	
36-61	17306-17312	update	
36-62	17313-17315	or	
36-63	17316-17318	at	
36-64	17319-17322	any	
36-65	17323-17331	specific	
36-66	17332-17337	times	
36-67	17338-17340	in	
36-68	17341-17344	the	
36-69	17345-17349	Java	
36-70	17350-17361	application	
36-71	17361-17362	,	
36-72	17363-17367	take	
36-73	17368-17369	a	
36-74	17370-17376	flight	
36-75	17377-17386	recording	
36-76	17387-17391	when	
36-77	17392-17398	things	
36-78	17399-17402	are	
36-79	17403-17407	good	
36-80	17407-17408	,	
36-81	17409-17412	and	
36-82	17413-17417	take	
36-83	17418-17425	another	
36-84	17426-17429	one	
36-85	17430-17434	when	
36-86	17435-17441	things	
36-87	17442-17445	are	
36-88	17446-17449	bad	
36-89	17450-17452	to	
36-90	17453-17457	look	
36-91	17458-17461	for	
36-92	17462-17463	a	
36-93	17464-17479	synchronization	
36-94	17480-17484	site	
36-95	17485-17489	that	
36-96	17490-17499	increases	
36-97	17500-17501	a	
36-98	17502-17505	lot	
36-99	17505-17506	.	

#Text=Note:By default, contention events with a duration longer than 20 ms are recorded. This threshold can be modified when starting the flight recording. Shorter thresholds give more events and also potentially more overhead. If you believe contention is an issue, then you could take a shorter recording with a very low threshold of only a few milliseconds. When this is done on a live application, make sure to start with a very short recording, and monitor the performance overhead. I/O Performance Topics: Use JDK Mission Control to Debug I/O Issues Use the Socket Read and Write Events to Debug I/O Issues Use JDK Mission Control to Debug I/O Issues
37-1	17507-17511	Note	
37-2	17511-17512	:	
37-3	17512-17514	By	
37-4	17515-17522	default	
37-5	17522-17523	,	
37-6	17524-17534	contention	
37-7	17535-17541	events	
37-8	17542-17546	with	
37-9	17547-17548	a	
37-10	17549-17557	duration	
37-11	17558-17564	longer	
37-12	17565-17569	than	
37-13	17570-17572	20	
37-14	17573-17575	ms	
37-15	17576-17579	are	
37-16	17580-17588	recorded	
37-17	17588-17589	.	
37-18	17590-17594	This	
37-19	17595-17604	threshold	
37-20	17605-17608	can	
37-21	17609-17611	be	
37-22	17612-17620	modified	
37-23	17621-17625	when	
37-24	17626-17634	starting	
37-25	17635-17638	the	
37-26	17639-17645	flight	
37-27	17646-17655	recording	
37-28	17655-17656	.	
37-29	17657-17664	Shorter	
37-30	17665-17675	thresholds	
37-31	17676-17680	give	
37-32	17681-17685	more	
37-33	17686-17692	events	
37-34	17693-17696	and	
37-35	17697-17701	also	
37-36	17702-17713	potentially	
37-37	17714-17718	more	
37-38	17719-17727	overhead	
37-39	17727-17728	.	
37-40	17729-17731	If	
37-41	17732-17735	you	
37-42	17736-17743	believe	
37-43	17744-17754	contention	
37-44	17755-17757	is	
37-45	17758-17760	an	
37-46	17761-17766	issue	
37-47	17766-17767	,	
37-48	17768-17772	then	
37-49	17773-17776	you	
37-50	17777-17782	could	
37-51	17783-17787	take	
37-52	17788-17789	a	
37-53	17790-17797	shorter	
37-54	17798-17807	recording	
37-55	17808-17812	with	
37-56	17813-17814	a	
37-57	17815-17819	very	
37-58	17820-17823	low	
37-59	17824-17833	threshold	
37-60	17834-17836	of	
37-61	17837-17841	only	
37-62	17842-17843	a	
37-63	17844-17847	few	
37-64	17848-17860	milliseconds	
37-65	17860-17861	.	
37-66	17862-17866	When	
37-67	17867-17871	this	
37-68	17872-17874	is	
37-69	17875-17879	done	
37-70	17880-17882	on	
37-71	17883-17884	a	
37-72	17885-17889	live	
37-73	17890-17901	application	
37-74	17901-17902	,	
37-75	17903-17907	make	
37-76	17908-17912	sure	
37-77	17913-17915	to	
37-78	17916-17921	start	
37-79	17922-17926	with	
37-80	17927-17928	a	
37-81	17929-17933	very	
37-82	17934-17939	short	
37-83	17940-17949	recording	
37-84	17949-17950	,	
37-85	17951-17954	and	
37-86	17955-17962	monitor	
37-87	17963-17966	the	
37-88	17967-17978	performance	
37-89	17979-17987	overhead	
37-90	17987-17988	.	
37-91	17989-17990	I	
37-92	17990-17991	/	
37-93	17991-17992	O	
37-94	17993-18004	Performance	
37-95	18005-18011	Topics	
37-96	18011-18012	:	
37-97	18013-18016	Use	
37-98	18017-18020	JDK	
37-99	18021-18028	Mission	
37-100	18029-18036	Control	
37-101	18037-18039	to	
37-102	18040-18045	Debug	
37-103	18046-18047	I	
37-104	18047-18048	/	
37-105	18048-18049	O	
37-106	18050-18056	Issues	
37-107	18057-18060	Use	
37-108	18061-18064	the	
37-109	18065-18071	Socket	
37-110	18072-18076	Read	
37-111	18077-18080	and	
37-112	18081-18086	Write	
37-113	18087-18093	Events	
37-114	18094-18096	to	
37-115	18097-18102	Debug	
37-116	18103-18104	I	
37-117	18104-18105	/	
37-118	18105-18106	O	
37-119	18107-18113	Issues	
37-120	18114-18117	Use	
37-121	18118-18121	JDK	
37-122	18122-18129	Mission	
37-123	18130-18137	Control	
37-124	18138-18140	to	
37-125	18141-18146	Debug	
37-126	18147-18148	I	
37-127	18148-18149	/	
37-128	18149-18150	O	
37-129	18151-18157	Issues	

#Text=You can diagnose I/O issues in an application by monitoring the Socket I/O or the File I/O pages in JMC. When a Java application spends a lot of time either in Socket Read, Socket Write, File Read, or File Write, then I/O or networking can cause bottleneck. To diagnose I/O issues in applications, open the Socket I/O page under the Java Application page in the Automated Analysis Results page. Here is a sample figure of a recording, which shows Socket I/O details.
38-1	18158-18161	You	
38-2	18162-18165	can	
38-3	18166-18174	diagnose	
38-4	18175-18176	I	
38-5	18176-18177	/	
38-6	18177-18178	O	
38-7	18179-18185	issues	
38-8	18186-18188	in	
38-9	18189-18191	an	
38-10	18192-18203	application	
38-11	18204-18206	by	
38-12	18207-18217	monitoring	
38-13	18218-18221	the	
38-14	18222-18228	Socket	
38-15	18229-18230	I	
38-16	18230-18231	/	
38-17	18231-18232	O	
38-18	18233-18235	or	
38-19	18236-18239	the	
38-20	18240-18244	File	
38-21	18245-18246	I	
38-22	18246-18247	/	
38-23	18247-18248	O	
38-24	18249-18254	pages	
38-25	18255-18257	in	
38-26	18258-18261	JMC	
38-27	18261-18262	.	
38-28	18263-18267	When	
38-29	18268-18269	a	
38-30	18270-18274	Java	
38-31	18275-18286	application	
38-32	18287-18293	spends	
38-33	18294-18295	a	
38-34	18296-18299	lot	
38-35	18300-18302	of	
38-36	18303-18307	time	
38-37	18308-18314	either	
38-38	18315-18317	in	
38-39	18318-18324	Socket	
38-40	18325-18329	Read	
38-41	18329-18330	,	
38-42	18331-18337	Socket	
38-43	18338-18343	Write	
38-44	18343-18344	,	
38-45	18345-18349	File	
38-46	18350-18354	Read	
38-47	18354-18355	,	
38-48	18356-18358	or	
38-49	18359-18363	File	
38-50	18364-18369	Write	
38-51	18369-18370	,	
38-52	18371-18375	then	
38-53	18376-18377	I	
38-54	18377-18378	/	
38-55	18378-18379	O	
38-56	18380-18382	or	
38-57	18383-18393	networking	
38-58	18394-18397	can	
38-59	18398-18403	cause	
38-60	18404-18414	bottleneck	
38-61	18414-18415	.	
38-62	18416-18418	To	
38-63	18419-18427	diagnose	
38-64	18428-18429	I	
38-65	18429-18430	/	
38-66	18430-18431	O	
38-67	18432-18438	issues	
38-68	18439-18441	in	
38-69	18442-18454	applications	
38-70	18454-18455	,	
38-71	18456-18460	open	
38-72	18461-18464	the	
38-73	18465-18471	Socket	
38-74	18472-18473	I	
38-75	18473-18474	/	
38-76	18474-18475	O	
38-77	18476-18480	page	
38-78	18481-18486	under	
38-79	18487-18490	the	
38-80	18491-18495	Java	
38-81	18496-18507	Application	
38-82	18508-18512	page	
38-83	18513-18515	in	
38-84	18516-18519	the	
38-85	18520-18529	Automated	
38-86	18530-18538	Analysis	
38-87	18539-18546	Results	
38-88	18547-18551	page	
38-89	18551-18552	.	
38-90	18553-18557	Here	
38-91	18558-18560	is	
38-92	18561-18562	a	
38-93	18563-18569	sample	
38-94	18570-18576	figure	
38-95	18577-18579	of	
38-96	18580-18581	a	
38-97	18582-18591	recording	
38-98	18591-18592	,	
38-99	18593-18598	which	
38-100	18599-18604	shows	
38-101	18605-18611	Socket	
38-102	18612-18613	I	
38-103	18613-18614	/	
38-104	18614-18615	O	
38-105	18616-18623	details	
38-106	18623-18624	.	

#Text=Figure 4-6 Socket I/O - Java ApplicationDescription of "Figure 4-6 Socket I/O - Java Application" The figure shows that for the application the longest recorded socket write took 349.745 ms to write 81 B to the host. File or networking I/O issues are diagnosed in a similar fashion. Look at the files read from or written to the most, then see each file read/write and the time spent on I/O.
39-1	18625-18631	Figure	
39-2	18632-18633	4	
39-3	18633-18634	-	
39-4	18634-18635	6	
39-5	18636-18642	Socket	
39-6	18643-18644	I	
39-7	18644-18645	/	
39-8	18645-18646	O	
39-9	18647-18648	-	
39-10	18649-18653	Java	
39-11	18654-18676	ApplicationDescription	
39-12	18677-18679	of	
39-13	18680-18681	"	
39-14	18681-18687	Figure	
39-15	18688-18689	4	
39-16	18689-18690	-	
39-17	18690-18691	6	
39-18	18692-18698	Socket	
39-19	18699-18700	I	
39-20	18700-18701	/	
39-21	18701-18702	O	
39-22	18703-18704	-	
39-23	18705-18709	Java	
39-24	18710-18721	Application	
39-25	18721-18722	"	
39-26	18723-18726	The	
39-27	18727-18733	figure	
39-28	18734-18739	shows	
39-29	18740-18744	that	
39-30	18745-18748	for	
39-31	18749-18752	the	
39-32	18753-18764	application	
39-33	18765-18768	the	
39-34	18769-18776	longest	
39-35	18777-18785	recorded	
39-36	18786-18792	socket	
39-37	18793-18798	write	
39-38	18799-18803	took	
39-39	18804-18811	349.745	
39-40	18812-18814	ms	
39-41	18815-18817	to	
39-42	18818-18823	write	
39-43	18824-18826	81	
39-44	18827-18828	B	
39-45	18829-18831	to	
39-46	18832-18835	the	
39-47	18836-18840	host	
39-48	18840-18841	.	
39-49	18842-18846	File	
39-50	18847-18849	or	
39-51	18850-18860	networking	
39-52	18861-18862	I	
39-53	18862-18863	/	
39-54	18863-18864	O	
39-55	18865-18871	issues	
39-56	18872-18875	are	
39-57	18876-18885	diagnosed	
39-58	18886-18888	in	
39-59	18889-18890	a	
39-60	18891-18898	similar	
39-61	18899-18906	fashion	
39-62	18906-18907	.	
39-63	18908-18912	Look	
39-64	18913-18915	at	
39-65	18916-18919	the	
39-66	18920-18925	files	
39-67	18926-18930	read	
39-68	18931-18935	from	
39-69	18936-18938	or	
39-70	18939-18946	written	
39-71	18947-18949	to	
39-72	18950-18953	the	
39-73	18954-18958	most	
39-74	18958-18959	,	
39-75	18960-18964	then	
39-76	18965-18968	see	
39-77	18969-18973	each	
39-78	18974-18978	file	
39-79	18979-18983	read	
39-80	18983-18984	/	
39-81	18984-18989	write	
39-82	18990-18993	and	
39-83	18994-18997	the	
39-84	18998-19002	time	
39-85	19003-19008	spent	
39-86	19009-19011	on	
39-87	19012-19013	I	
39-88	19013-19014	/	
39-89	19014-19015	O	
39-90	19015-19016	.	

#Text=By default, the Socket I/O page lists events with a duration longer than 10 ms. When starting a flight recording, you can lower the File I/O Threshold or Socket I/O Threshold to gather more data, but this could potentially have a higher performance overhead. Use the Socket Read and Write Events to Debug I/O Issues When a Java application spends a lot of time reading or writing sockets or files, then I/O or networking may be the bottleneck. Recordings from Flight Recorder can help identify problem areas.
40-1	19017-19019	By	
40-2	19020-19027	default	
40-3	19027-19028	,	
40-4	19029-19032	the	
40-5	19033-19039	Socket	
40-6	19040-19041	I	
40-7	19041-19042	/	
40-8	19042-19043	O	
40-9	19044-19048	page	
40-10	19049-19054	lists	
40-11	19055-19061	events	
40-12	19062-19066	with	
40-13	19067-19068	a	
40-14	19069-19077	duration	
40-15	19078-19084	longer	
40-16	19085-19089	than	
40-17	19090-19092	10	
40-18	19093-19095	ms	
40-19	19095-19096	.	
40-20	19097-19101	When	
40-21	19102-19110	starting	
40-22	19111-19112	a	
40-23	19113-19119	flight	
40-24	19120-19129	recording	
40-25	19129-19130	,	
40-26	19131-19134	you	
40-27	19135-19138	can	
40-28	19139-19144	lower	
40-29	19145-19148	the	
40-30	19149-19153	File	
40-31	19154-19155	I	
40-32	19155-19156	/	
40-33	19156-19157	O	
40-34	19158-19167	Threshold	
40-35	19168-19170	or	
40-36	19171-19177	Socket	
40-37	19178-19179	I	
40-38	19179-19180	/	
40-39	19180-19181	O	
40-40	19182-19191	Threshold	
40-41	19192-19194	to	
40-42	19195-19201	gather	
40-43	19202-19206	more	
40-44	19207-19211	data	
40-45	19211-19212	,	
40-46	19213-19216	but	
40-47	19217-19221	this	
40-48	19222-19227	could	
40-49	19228-19239	potentially	
40-50	19240-19244	have	
40-51	19245-19246	a	
40-52	19247-19253	higher	
40-53	19254-19265	performance	
40-54	19266-19274	overhead	
40-55	19274-19275	.	
40-56	19276-19279	Use	
40-57	19280-19283	the	
40-58	19284-19290	Socket	
40-59	19291-19295	Read	
40-60	19296-19299	and	
40-61	19300-19305	Write	
40-62	19306-19312	Events	
40-63	19313-19315	to	
40-64	19316-19321	Debug	
40-65	19322-19323	I	
40-66	19323-19324	/	
40-67	19324-19325	O	
40-68	19326-19332	Issues	
40-69	19333-19337	When	
40-70	19338-19339	a	
40-71	19340-19344	Java	
40-72	19345-19356	application	
40-73	19357-19363	spends	
40-74	19364-19365	a	
40-75	19366-19369	lot	
40-76	19370-19372	of	
40-77	19373-19377	time	
40-78	19378-19385	reading	
40-79	19386-19388	or	
40-80	19389-19396	writing	
40-81	19397-19404	sockets	
40-82	19405-19407	or	
40-83	19408-19413	files	
40-84	19413-19414	,	
40-85	19415-19419	then	
40-86	19420-19421	I	
40-87	19421-19422	/	
40-88	19422-19423	O	
40-89	19424-19426	or	
40-90	19427-19437	networking	
40-91	19438-19441	may	
40-92	19442-19444	be	
40-93	19445-19448	the	
40-94	19449-19459	bottleneck	
40-95	19459-19460	.	
40-96	19461-19471	Recordings	
40-97	19472-19476	from	
40-98	19477-19483	Flight	
40-99	19484-19492	Recorder	
40-100	19493-19496	can	
40-101	19497-19501	help	
40-102	19502-19510	identify	
40-103	19511-19518	problem	
40-104	19519-19524	areas	
40-105	19524-19525	.	

#Text=To diagnose I/O issues in applications, look at the following events in your flight recording. Make sure that all of these events are enabled in the recording template that you are using: jdk.SocketWrite jdk.SocketRead jdk.FileWrite jdk.FileRead
41-1	19526-19528	To	
41-2	19529-19537	diagnose	
41-3	19538-19539	I	
41-4	19539-19540	/	
41-5	19540-19541	O	
41-6	19542-19548	issues	
41-7	19549-19551	in	
41-8	19552-19564	applications	
41-9	19564-19565	,	
41-10	19566-19570	look	
41-11	19571-19573	at	
41-12	19574-19577	the	
41-13	19578-19587	following	
41-14	19588-19594	events	
41-15	19595-19597	in	
41-16	19598-19602	your	
41-17	19603-19609	flight	
41-18	19610-19619	recording	
41-19	19619-19620	.	
41-20	19621-19625	Make	
41-21	19626-19630	sure	
41-22	19631-19635	that	
41-23	19636-19639	all	
41-24	19640-19642	of	
41-25	19643-19648	these	
41-26	19649-19655	events	
41-27	19656-19659	are	
41-28	19660-19667	enabled	
41-29	19668-19670	in	
41-30	19671-19674	the	
41-31	19675-19684	recording	
41-32	19685-19693	template	
41-33	19694-19698	that	
41-34	19699-19702	you	
41-35	19703-19706	are	
41-36	19707-19712	using	
41-37	19712-19713	:	
41-38	19714-19729	jdk.SocketWrite	
41-39	19730-19744	jdk.SocketRead	
41-40	19745-19758	jdk.FileWrite	
41-41	19759-19771	jdk.FileRead	

#Text=Use the socket read and write information in your flight recording to calculate the number of reads from a specific remote address, the total number of bytes read, and the total time spent waiting. Look at each event to analyze the time spent and data read. File or networking I/O issues are diagnosed in a similar fashion. Look at the files read to or written to the most, then see each file read/write and the time spent on I/O.
42-1	19772-19775	Use	
42-2	19776-19779	the	
42-3	19780-19786	socket	
42-4	19787-19791	read	
42-5	19792-19795	and	
42-6	19796-19801	write	
42-7	19802-19813	information	
42-8	19814-19816	in	
42-9	19817-19821	your	
42-10	19822-19828	flight	
42-11	19829-19838	recording	
42-12	19839-19841	to	
42-13	19842-19851	calculate	
42-14	19852-19855	the	
42-15	19856-19862	number	
42-16	19863-19865	of	
42-17	19866-19871	reads	
42-18	19872-19876	from	
42-19	19877-19878	a	
42-20	19879-19887	specific	
42-21	19888-19894	remote	
42-22	19895-19902	address	
42-23	19902-19903	,	
42-24	19904-19907	the	
42-25	19908-19913	total	
42-26	19914-19920	number	
42-27	19921-19923	of	
42-28	19924-19929	bytes	
42-29	19930-19934	read	
42-30	19934-19935	,	
42-31	19936-19939	and	
42-32	19940-19943	the	
42-33	19944-19949	total	
42-34	19950-19954	time	
42-35	19955-19960	spent	
42-36	19961-19968	waiting	
42-37	19968-19969	.	
42-38	19970-19974	Look	
42-39	19975-19977	at	
42-40	19978-19982	each	
42-41	19983-19988	event	
42-42	19989-19991	to	
42-43	19992-19999	analyze	
42-44	20000-20003	the	
42-45	20004-20008	time	
42-46	20009-20014	spent	
42-47	20015-20018	and	
42-48	20019-20023	data	
42-49	20024-20028	read	
42-50	20028-20029	.	
42-51	20030-20034	File	
42-52	20035-20037	or	
42-53	20038-20048	networking	
42-54	20049-20050	I	
42-55	20050-20051	/	
42-56	20051-20052	O	
42-57	20053-20059	issues	
42-58	20060-20063	are	
42-59	20064-20073	diagnosed	
42-60	20074-20076	in	
42-61	20077-20078	a	
42-62	20079-20086	similar	
42-63	20087-20094	fashion	
42-64	20094-20095	.	
42-65	20096-20100	Look	
42-66	20101-20103	at	
42-67	20104-20107	the	
42-68	20108-20113	files	
42-69	20114-20118	read	
42-70	20119-20121	to	
42-71	20122-20124	or	
42-72	20125-20132	written	
42-73	20133-20135	to	
42-74	20136-20139	the	
42-75	20140-20144	most	
42-76	20144-20145	,	
42-77	20146-20150	then	
42-78	20151-20154	see	
42-79	20155-20159	each	
42-80	20160-20164	file	
42-81	20165-20169	read	
42-82	20169-20170	/	
42-83	20170-20175	write	
42-84	20176-20179	and	
42-85	20180-20183	the	
42-86	20184-20188	time	
42-87	20189-20194	spent	
42-88	20195-20197	on	
42-89	20198-20199	I	
42-90	20199-20200	/	
42-91	20200-20201	O	
42-92	20201-20202	.	

#Text=By default, only events with a duration longer than 20 ms are recorded. When starting a flight recording, you can lower the file I/O threshold or the socket I/O threshold to gather more data, potentially with a higher performance effect. Code Execution Performance Topics: Use JDK Mission Control to Monitor Code Execution Performance Use jdk.CPULoad and jdk.ThreadCPULoad Events to Monitor Code Execution Performance
43-1	20203-20205	By	
43-2	20206-20213	default	
43-3	20213-20214	,	
43-4	20215-20219	only	
43-5	20220-20226	events	
43-6	20227-20231	with	
43-7	20232-20233	a	
43-8	20234-20242	duration	
43-9	20243-20249	longer	
43-10	20250-20254	than	
43-11	20255-20257	20	
43-12	20258-20260	ms	
43-13	20261-20264	are	
43-14	20265-20273	recorded	
43-15	20273-20274	.	
43-16	20275-20279	When	
43-17	20280-20288	starting	
43-18	20289-20290	a	
43-19	20291-20297	flight	
43-20	20298-20307	recording	
43-21	20307-20308	,	
43-22	20309-20312	you	
43-23	20313-20316	can	
43-24	20317-20322	lower	
43-25	20323-20326	the	
43-26	20327-20331	file	
43-27	20332-20333	I	
43-28	20333-20334	/	
43-29	20334-20335	O	
43-30	20336-20345	threshold	
43-31	20346-20348	or	
43-32	20349-20352	the	
43-33	20353-20359	socket	
43-34	20360-20361	I	
43-35	20361-20362	/	
43-36	20362-20363	O	
43-37	20364-20373	threshold	
43-38	20374-20376	to	
43-39	20377-20383	gather	
43-40	20384-20388	more	
43-41	20389-20393	data	
43-42	20393-20394	,	
43-43	20395-20406	potentially	
43-44	20407-20411	with	
43-45	20412-20413	a	
43-46	20414-20420	higher	
43-47	20421-20432	performance	
43-48	20433-20439	effect	
43-49	20439-20440	.	
43-50	20441-20445	Code	
43-51	20446-20455	Execution	
43-52	20456-20467	Performance	
43-53	20468-20474	Topics	
43-54	20474-20475	:	
43-55	20476-20479	Use	
43-56	20480-20483	JDK	
43-57	20484-20491	Mission	
43-58	20492-20499	Control	
43-59	20500-20502	to	
43-60	20503-20510	Monitor	
43-61	20511-20515	Code	
43-62	20516-20525	Execution	
43-63	20526-20537	Performance	
43-64	20538-20541	Use	
43-65	20542-20553	jdk.CPULoad	
43-66	20554-20557	and	
43-67	20558-20575	jdk.ThreadCPULoad	
43-68	20576-20582	Events	
43-69	20583-20585	to	
43-70	20586-20593	Monitor	
43-71	20594-20598	Code	
43-72	20599-20608	Execution	
43-73	20609-20620	Performance	

#Text=Use JDK Mission Control to Monitor Code Execution Performance You can use JMC to monitor the code execution performance. When there are not a lot of Java Application events, it could be that the main bottleneck of your application is the running code. In such scenarios, look at the Method Profiling section of the Automated Analysis Results page. Here is a sample figure of a recording, which indicates that there is value in optimizing certain methods.
44-1	20621-20624	Use	
44-2	20625-20628	JDK	
44-3	20629-20636	Mission	
44-4	20637-20644	Control	
44-5	20645-20647	to	
44-6	20648-20655	Monitor	
44-7	20656-20660	Code	
44-8	20661-20670	Execution	
44-9	20671-20682	Performance	
44-10	20683-20686	You	
44-11	20687-20690	can	
44-12	20691-20694	use	
44-13	20695-20698	JMC	
44-14	20699-20701	to	
44-15	20702-20709	monitor	
44-16	20710-20713	the	
44-17	20714-20718	code	
44-18	20719-20728	execution	
44-19	20729-20740	performance	
44-20	20740-20741	.	
44-21	20742-20746	When	
44-22	20747-20752	there	
44-23	20753-20756	are	
44-24	20757-20760	not	
44-25	20761-20762	a	
44-26	20763-20766	lot	
44-27	20767-20769	of	
44-28	20770-20774	Java	
44-29	20775-20786	Application	
44-30	20787-20793	events	
44-31	20793-20794	,	
44-32	20795-20797	it	
44-33	20798-20803	could	
44-34	20804-20806	be	
44-35	20807-20811	that	
44-36	20812-20815	the	
44-37	20816-20820	main	
44-38	20821-20831	bottleneck	
44-39	20832-20834	of	
44-40	20835-20839	your	
44-41	20840-20851	application	
44-42	20852-20854	is	
44-43	20855-20858	the	
44-44	20859-20866	running	
44-45	20867-20871	code	
44-46	20871-20872	.	
44-47	20873-20875	In	
44-48	20876-20880	such	
44-49	20881-20890	scenarios	
44-50	20890-20891	,	
44-51	20892-20896	look	
44-52	20897-20899	at	
44-53	20900-20903	the	
44-54	20904-20910	Method	
44-55	20911-20920	Profiling	
44-56	20921-20928	section	
44-57	20929-20931	of	
44-58	20932-20935	the	
44-59	20936-20945	Automated	
44-60	20946-20954	Analysis	
44-61	20955-20962	Results	
44-62	20963-20967	page	
44-63	20967-20968	.	
44-64	20969-20973	Here	
44-65	20974-20976	is	
44-66	20977-20978	a	
44-67	20979-20985	sample	
44-68	20986-20992	figure	
44-69	20993-20995	of	
44-70	20996-20997	a	
44-71	20998-21007	recording	
44-72	21007-21008	,	
44-73	21009-21014	which	
44-74	21015-21024	indicates	
44-75	21025-21029	that	
44-76	21030-21035	there	
44-77	21036-21038	is	
44-78	21039-21044	value	
44-79	21045-21047	in	
44-80	21048-21058	optimizing	
44-81	21059-21066	certain	
44-82	21067-21074	methods	
44-83	21074-21075	.	

#Text=Figure 4-7 Code Execution Performance - Automated Analysis Results PageDescription of "Figure 4-7 Code Execution Performance - Automated Analysis Results Page" Now, open the Java Application page. Here is a sample figure of a recording, which shows the Method Profiling graph and the stack traces. Figure 4-8 Code Execution Performance - Java ApplicationDescription of "Figure 4-8 Code Execution Performance - Java Application"
45-1	21076-21082	Figure	
45-2	21083-21084	4	
45-3	21084-21085	-	
45-4	21085-21086	7	
45-5	21087-21091	Code	
45-6	21092-21101	Execution	
45-7	21102-21113	Performance	
45-8	21114-21115	-	
45-9	21116-21125	Automated	
45-10	21126-21134	Analysis	
45-11	21135-21142	Results	
45-12	21143-21158	PageDescription	
45-13	21159-21161	of	
45-14	21162-21163	"	
45-15	21163-21169	Figure	
45-16	21170-21171	4	
45-17	21171-21172	-	
45-18	21172-21173	7	
45-19	21174-21178	Code	
45-20	21179-21188	Execution	
45-21	21189-21200	Performance	
45-22	21201-21202	-	
45-23	21203-21212	Automated	
45-24	21213-21221	Analysis	
45-25	21222-21229	Results	
45-26	21230-21234	Page	
45-27	21234-21235	"	
45-28	21236-21239	Now	
45-29	21239-21240	,	
45-30	21241-21245	open	
45-31	21246-21249	the	
45-32	21250-21254	Java	
45-33	21255-21266	Application	
45-34	21267-21271	page	
45-35	21271-21272	.	
45-36	21273-21277	Here	
45-37	21278-21280	is	
45-38	21281-21282	a	
45-39	21283-21289	sample	
45-40	21290-21296	figure	
45-41	21297-21299	of	
45-42	21300-21301	a	
45-43	21302-21311	recording	
45-44	21311-21312	,	
45-45	21313-21318	which	
45-46	21319-21324	shows	
45-47	21325-21328	the	
45-48	21329-21335	Method	
45-49	21336-21345	Profiling	
45-50	21346-21351	graph	
45-51	21352-21355	and	
45-52	21356-21359	the	
45-53	21360-21365	stack	
45-54	21366-21372	traces	
45-55	21372-21373	.	
45-56	21374-21380	Figure	
45-57	21381-21382	4	
45-58	21382-21383	-	
45-59	21383-21384	8	
45-60	21385-21389	Code	
45-61	21390-21399	Execution	
45-62	21400-21411	Performance	
45-63	21412-21413	-	
45-64	21414-21418	Java	
45-65	21419-21441	ApplicationDescription	
45-66	21442-21444	of	
45-67	21445-21446	"	
45-68	21446-21452	Figure	
45-69	21453-21454	4	
45-70	21454-21455	-	
45-71	21455-21456	8	
45-72	21457-21461	Code	
45-73	21462-21471	Execution	
45-74	21472-21483	Performance	
45-75	21484-21485	-	
45-76	21486-21490	Java	
45-77	21491-21502	Application	
45-78	21502-21503	"	

#Text=You can observe that the stack trace view shows the aggregated stack traces of any selection in the editor and also the stack traces for the profiling samples. In the figure, you can notice that one of these methods has a lot more samples than the others. This means that the JVM has spent more time executing that method relative to the other methods. To identify which method would be the one to optimize to improve the performance of the application, open the Method Profiling page. Here is a sample figure of a recording, which shows the method that needs to be optimized.
46-1	21504-21507	You	
46-2	21508-21511	can	
46-3	21512-21519	observe	
46-4	21520-21524	that	
46-5	21525-21528	the	
46-6	21529-21534	stack	
46-7	21535-21540	trace	
46-8	21541-21545	view	
46-9	21546-21551	shows	
46-10	21552-21555	the	
46-11	21556-21566	aggregated	
46-12	21567-21572	stack	
46-13	21573-21579	traces	
46-14	21580-21582	of	
46-15	21583-21586	any	
46-16	21587-21596	selection	
46-17	21597-21599	in	
46-18	21600-21603	the	
46-19	21604-21610	editor	
46-20	21611-21614	and	
46-21	21615-21619	also	
46-22	21620-21623	the	
46-23	21624-21629	stack	
46-24	21630-21636	traces	
46-25	21637-21640	for	
46-26	21641-21644	the	
46-27	21645-21654	profiling	
46-28	21655-21662	samples	
46-29	21662-21663	.	
46-30	21664-21666	In	
46-31	21667-21670	the	
46-32	21671-21677	figure	
46-33	21677-21678	,	
46-34	21679-21682	you	
46-35	21683-21686	can	
46-36	21687-21693	notice	
46-37	21694-21698	that	
46-38	21699-21702	one	
46-39	21703-21705	of	
46-40	21706-21711	these	
46-41	21712-21719	methods	
46-42	21720-21723	has	
46-43	21724-21725	a	
46-44	21726-21729	lot	
46-45	21730-21734	more	
46-46	21735-21742	samples	
46-47	21743-21747	than	
46-48	21748-21751	the	
46-49	21752-21758	others	
46-50	21758-21759	.	
46-51	21760-21764	This	
46-52	21765-21770	means	
46-53	21771-21775	that	
46-54	21776-21779	the	
46-55	21780-21783	JVM	
46-56	21784-21787	has	
46-57	21788-21793	spent	
46-58	21794-21798	more	
46-59	21799-21803	time	
46-60	21804-21813	executing	
46-61	21814-21818	that	
46-62	21819-21825	method	
46-63	21826-21834	relative	
46-64	21835-21837	to	
46-65	21838-21841	the	
46-66	21842-21847	other	
46-67	21848-21855	methods	
46-68	21855-21856	.	
46-69	21857-21859	To	
46-70	21860-21868	identify	
46-71	21869-21874	which	
46-72	21875-21881	method	
46-73	21882-21887	would	
46-74	21888-21890	be	
46-75	21891-21894	the	
46-76	21895-21898	one	
46-77	21899-21901	to	
46-78	21902-21910	optimize	
46-79	21911-21913	to	
46-80	21914-21921	improve	
46-81	21922-21925	the	
46-82	21926-21937	performance	
46-83	21938-21940	of	
46-84	21941-21944	the	
46-85	21945-21956	application	
46-86	21956-21957	,	
46-87	21958-21962	open	
46-88	21963-21966	the	
46-89	21967-21973	Method	
46-90	21974-21983	Profiling	
46-91	21984-21988	page	
46-92	21988-21989	.	
46-93	21990-21994	Here	
46-94	21995-21997	is	
46-95	21998-21999	a	
46-96	22000-22006	sample	
46-97	22007-22013	figure	
46-98	22014-22016	of	
46-99	22017-22018	a	
46-100	22019-22028	recording	
46-101	22028-22029	,	
46-102	22030-22035	which	
46-103	22036-22041	shows	
46-104	22042-22045	the	
46-105	22046-22052	method	
46-106	22053-22057	that	
46-107	22058-22063	needs	
46-108	22064-22066	to	
46-109	22067-22069	be	
46-110	22070-22079	optimized	
46-111	22079-22080	.	

#Text=Figure 4-9 Code Execution Performance - Method ProfilingDescription of "Figure 4-9 Code Execution Performance - Method Profiling" As you can observe, in the stack trace view, the most sampled method was HolderOfUniqueValues.countIntersection(). You can review and make required code changes to optimize this method to effectively improve the performance of the application.
47-1	22081-22087	Figure	
47-2	22088-22089	4	
47-3	22089-22090	-	
47-4	22090-22091	9	
47-5	22092-22096	Code	
47-6	22097-22106	Execution	
47-7	22107-22118	Performance	
47-8	22119-22120	-	
47-9	22121-22127	Method	
47-10	22128-22148	ProfilingDescription	
47-11	22149-22151	of	
47-12	22152-22153	"	
47-13	22153-22159	Figure	
47-14	22160-22161	4	
47-15	22161-22162	-	
47-16	22162-22163	9	
47-17	22164-22168	Code	
47-18	22169-22178	Execution	
47-19	22179-22190	Performance	
47-20	22191-22192	-	
47-21	22193-22199	Method	
47-22	22200-22209	Profiling	
47-23	22209-22210	"	
47-24	22211-22213	As	
47-25	22214-22217	you	
47-26	22218-22221	can	
47-27	22222-22229	observe	
47-28	22229-22230	,	
47-29	22231-22233	in	
47-30	22234-22237	the	
47-31	22238-22243	stack	
47-32	22244-22249	trace	
47-33	22250-22254	view	
47-34	22254-22255	,	
47-35	22256-22259	the	
47-36	22260-22264	most	
47-37	22265-22272	sampled	
47-38	22273-22279	method	
47-39	22280-22283	was	
47-40	22284-22322	HolderOfUniqueValues.countIntersection	
47-41	22322-22323	(	
47-42	22323-22324	)	
47-43	22324-22325	.	
47-44	22326-22329	You	
47-45	22330-22333	can	
47-46	22334-22340	review	
47-47	22341-22344	and	
47-48	22345-22349	make	
47-49	22350-22358	required	
47-50	22359-22363	code	
47-51	22364-22371	changes	
47-52	22372-22374	to	
47-53	22375-22383	optimize	
47-54	22384-22388	this	
47-55	22389-22395	method	
47-56	22396-22398	to	
47-57	22399-22410	effectively	
47-58	22411-22418	improve	
47-59	22419-22422	the	
47-60	22423-22434	performance	
47-61	22435-22437	of	
47-62	22438-22441	the	
47-63	22442-22453	application	
47-64	22453-22454	.	

#Text=Use jdk.CPULoad and jdk.ThreadCPULoad Events to Monitor Code Execution Performance When there are not a lot of Java Application events, it could be that the main bottleneck of your application is the running code. Recordings from Flight Recorder can help identify problem areas.
48-1	22455-22458	Use	
48-2	22459-22470	jdk.CPULoad	
48-3	22471-22474	and	
48-4	22475-22492	jdk.ThreadCPULoad	
48-5	22493-22499	Events	
48-6	22500-22502	to	
48-7	22503-22510	Monitor	
48-8	22511-22515	Code	
48-9	22516-22525	Execution	
48-10	22526-22537	Performance	
48-11	22538-22542	When	
48-12	22543-22548	there	
48-13	22549-22552	are	
48-14	22553-22556	not	
48-15	22557-22558	a	
48-16	22559-22562	lot	
48-17	22563-22565	of	
48-18	22566-22570	Java	
48-19	22571-22582	Application	
48-20	22583-22589	events	
48-21	22589-22590	,	
48-22	22591-22593	it	
48-23	22594-22599	could	
48-24	22600-22602	be	
48-25	22603-22607	that	
48-26	22608-22611	the	
48-27	22612-22616	main	
48-28	22617-22627	bottleneck	
48-29	22628-22630	of	
48-30	22631-22635	your	
48-31	22636-22647	application	
48-32	22648-22650	is	
48-33	22651-22654	the	
48-34	22655-22662	running	
48-35	22663-22667	code	
48-36	22667-22668	.	
48-37	22669-22679	Recordings	
48-38	22680-22684	from	
48-39	22685-22691	Flight	
48-40	22692-22700	Recorder	
48-41	22701-22704	can	
48-42	22705-22709	help	
48-43	22710-22718	identify	
48-44	22719-22726	problem	
48-45	22727-22732	areas	
48-46	22732-22733	.	

#Text=Look at the jdk.CPULoad events and review the CPU usage over time. This shows the CPU usage of the JVM being recorded and the total CPU usage on the machine. If the JVM CPU usage is low, but the CPU usage of the machine is high, then some other application is likely taking a lot of CPU. In that case, look at the other applications running on the system using OS tools such as Top or the task manager to find out which processes are using a lot of CPU.
49-1	22734-22738	Look	
49-2	22739-22741	at	
49-3	22742-22745	the	
49-4	22746-22757	jdk.CPULoad	
49-5	22758-22764	events	
49-6	22765-22768	and	
49-7	22769-22775	review	
49-8	22776-22779	the	
49-9	22780-22783	CPU	
49-10	22784-22789	usage	
49-11	22790-22794	over	
49-12	22795-22799	time	
49-13	22799-22800	.	
49-14	22801-22805	This	
49-15	22806-22811	shows	
49-16	22812-22815	the	
49-17	22816-22819	CPU	
49-18	22820-22825	usage	
49-19	22826-22828	of	
49-20	22829-22832	the	
49-21	22833-22836	JVM	
49-22	22837-22842	being	
49-23	22843-22851	recorded	
49-24	22852-22855	and	
49-25	22856-22859	the	
49-26	22860-22865	total	
49-27	22866-22869	CPU	
49-28	22870-22875	usage	
49-29	22876-22878	on	
49-30	22879-22882	the	
49-31	22883-22890	machine	
49-32	22890-22891	.	
49-33	22892-22894	If	
49-34	22895-22898	the	
49-35	22899-22902	JVM	
49-36	22903-22906	CPU	
49-37	22907-22912	usage	
49-38	22913-22915	is	
49-39	22916-22919	low	
49-40	22919-22920	,	
49-41	22921-22924	but	
49-42	22925-22928	the	
49-43	22929-22932	CPU	
49-44	22933-22938	usage	
49-45	22939-22941	of	
49-46	22942-22945	the	
49-47	22946-22953	machine	
49-48	22954-22956	is	
49-49	22957-22961	high	
49-50	22961-22962	,	
49-51	22963-22967	then	
49-52	22968-22972	some	
49-53	22973-22978	other	
49-54	22979-22990	application	
49-55	22991-22993	is	
49-56	22994-23000	likely	
49-57	23001-23007	taking	
49-58	23008-23009	a	
49-59	23010-23013	lot	
49-60	23014-23016	of	
49-61	23017-23020	CPU	
49-62	23020-23021	.	
49-63	23022-23024	In	
49-64	23025-23029	that	
49-65	23030-23034	case	
49-66	23034-23035	,	
49-67	23036-23040	look	
49-68	23041-23043	at	
49-69	23044-23047	the	
49-70	23048-23053	other	
49-71	23054-23066	applications	
49-72	23067-23074	running	
49-73	23075-23077	on	
49-74	23078-23081	the	
49-75	23082-23088	system	
49-76	23089-23094	using	
49-77	23095-23097	OS	
49-78	23098-23103	tools	
49-79	23104-23108	such	
49-80	23109-23111	as	
49-81	23112-23115	Top	
49-82	23116-23118	or	
49-83	23119-23122	the	
49-84	23123-23127	task	
49-85	23128-23135	manager	
49-86	23136-23138	to	
49-87	23139-23143	find	
49-88	23144-23147	out	
49-89	23148-23153	which	
49-90	23154-23163	processes	
49-91	23164-23167	are	
49-92	23168-23173	using	
49-93	23174-23175	a	
49-94	23176-23179	lot	
49-95	23180-23182	of	
49-96	23183-23186	CPU	
49-97	23186-23187	.	
